
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>2. 스프링 모바일 디바이스 모듈</title>

<link rel="stylesheet" type="text/css" href="css/manual-multipage.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="index.html" title="Spring Mobile Reference Documentation">
<link rel="up" href="index.html" title="Spring Mobile Reference Documentation">
<link rel="prev" href="overview.html" title="1.&nbsp;Spring Mobile Overview">
<!-- My Custom Configuration -->
<script src="js/jquery-1.11.1.min.js"></script>
<script src="js/translate.js"></script>
<style>
@import url(http://fonts.googleapis.com/earlyaccess/kopubbatang.css);

.originalArticle {
  display: none;
  position: relative;
  width: 100%;
 
}

.translateArticle {
  font-family: 'KoPub Batang', serif; position : relative;
  width: 100%;
 
  position: relative;
}

.btnTr {
  position: absolute;
  right: 0px;
  top: 10px;
  width: 45px;
  height: 30px;
  cursor: pointer;
  z-index: 999;
  font-size: 10px;
}

.content{
  line-height: 20px;
}
</style>
<!-- //My Custom Configuration -->
<!-- SEO -->
<meta content="summary" name="twitter:card"/>
<meta content="@arahansa" name="twitter:site"/>
<meta name="twitter:title" content="스프링 모바일 레퍼런스 번역문서입니다.."/>
<meta name="twitter:description" content="스프링 모바일은 스프링 MVC의 확장을 포함해서 모바일 웹 어플리케이션을 개발하게 해줍니다. 이것은 서버사이드에서 모바일 감지하는 모듈을 포함합니다. "/>
<meta name="twitter:creator" content="@arahansa"/>
<meta name="twitter:image:src" content="images/spring_mobile.jpg"/>

<meta property="og:title" content="스프링 모바일 레퍼런스 번역문서입니다.."/>
<meta property="og:image" content="images/spring_mobile.jpg"/>
<meta property="og:description" content="스프링 모바일은 스프링 MVC의 확장을 포함해서 모바일 웹 어플리케이션을 개발하게 해줍니다. 이것은 서버사이드에서 모바일 감지하는 모듈을 포함합니다. "/>

<meta content="article" property="og:type"/>
<!-- //SEO -->
</head>


<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

    <div class="navheader">
        <table width="100%" summary="Navigation header">
            <tr><th colspan="3" align="center"><div class="translateArticle">2. 스프링 디바이스 모듈 </div><div class="originalArticle">2.&nbsp;Spring Mobile Device Module</div></th></tr>
            <tr><td width="20%" align="left"><a accesskey="p" href="overview.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th>
                <td width="20%" align="right">&nbsp;</td></tr>
        </table>
        <hr>
    </div>
    <div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="device" href="#device"></a>2.&nbsp;Spring Mobile Device Module</h1></div></div></div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="device-introduction" href="#device-introduction"></a>2.1&nbsp;Introduction</h2></div></div></div>
<div class="translateArticle"><p>디바이스 감지는 데스크탑 브라우저와 모바일 디바이스에 의한 요청이 다르게 처리 될 때 유용합니다. 스프링 모바일 디바이스모듈은 서버사이드 디바이스 감지 지원을 제공합니다. 이 지원은 디바이스 해석 프레임워크, 사이트 우선권 매니저, 사이트 스위처, 뷰 관리로 구성되어있습니다. </p></div><div class="originalArticle"><p>Device detection is useful when requests by mobile devices need to be handled differently from requests
made by desktop browsers. The Spring Mobile Device module provides support for server-side device detection.
This support consists of a device resolution framework, site preference management, site switcher, and view
management.</p></div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="device-howtoget" href="#device-howtoget"></a>2.2&nbsp;How to get</h2></div></div></div>
<div class="translateArticle"><p>모듈을 얻기 위해 스프링 모바일 디바이스 아티팩트를 클래스 패스에 추가하세요 : </p></div><div class="originalArticle"><p>To get the module, add the spring-mobile-device artifact to your classpath:</p></div>

<pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
    <span class="hl-tag">&lt;groupId&gt;</span>org.springframework.mobile<span class="hl-tag">&lt;/groupId&gt;</span>
    <span class="hl-tag">&lt;artifactId&gt;</span>spring-mobile-device<span class="hl-tag">&lt;/artifactId&gt;</span>
    <span class="hl-tag">&lt;version&gt;</span>${org.springframework.mobile-version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
            </pre><p>
</p>
<div class="translateArticle"><p>이 리파지토리에서 릴리즈 버젼이 사용가능합니다. </p></div><div class="originalArticle"><p>Release versions are available from the following repository:</p></div>
<pre class="programlisting">
<span class="hl-tag">&lt;repository&gt;</span>
    <span class="hl-tag">&lt;id&gt;</span>spring-repo<span class="hl-tag">&lt;/id&gt;</span>
    <span class="hl-tag">&lt;name&gt;</span>Spring Repository<span class="hl-tag">&lt;/name&gt;</span>
    <span class="hl-tag">&lt;url&gt;</span>http://repo.spring.io/release<span class="hl-tag">&lt;/url&gt;</span>
<span class="hl-tag">&lt;/repository&gt;</span>
            </pre><p>
</p>
<div class="translateArticle"><p>만약 당신이 릴리즈 후보나 마일스톤에 맞추지 않고 개발한다면 다음 artifact를 해석하기 위해 다음 리파지토리를 추가할 필요가 있을 것입니다. </p>
</div><div class="originalArticle"><p>If you are developing against a milestone or release candidate, you will need to add the following
repository in order to resolve the artifact:</p>
</div>
<pre class="programlisting">
<span class="hl-tag">&lt;repository&gt;</span>
    <span class="hl-tag">&lt;id&gt;</span>spring-milestone<span class="hl-tag">&lt;/id&gt;</span>
    <span class="hl-tag">&lt;name&gt;</span>Spring Milestone Repository<span class="hl-tag">&lt;/name&gt;</span>
    <span class="hl-tag">&lt;url&gt;</span>http://repo.spring.io/milestone<span class="hl-tag">&lt;/url&gt;</span>
<span class="hl-tag">&lt;/repository&gt;</span>
            </pre><p>
</p>
<div class="translateArticle"><p>만약 당신이 최근의 스냅샷 빌드버젼을 테스팅한다면, 당신은 다음의 리파지토리를 추가해야할 것입니다. </p></div><div class="originalArticle"><p>If you are testing the latest snapshot build version, you will need to add the following repository:</p></div>
<pre class="programlisting">
<span class="hl-tag">&lt;repository&gt;</span>
    <span class="hl-tag">&lt;id&gt;</span>spring-snapshot<span class="hl-tag">&lt;/id&gt;</span>
    <span class="hl-tag">&lt;name&gt;</span>Spring Snapshot Repository<span class="hl-tag">&lt;/name&gt;</span>
    <span class="hl-tag">&lt;url&gt;</span>http://repo.spring.io/snapshot<span class="hl-tag">&lt;/url&gt;</span>
<span class="hl-tag">&lt;/repository&gt;</span>
            </pre><p>
</p>
</div>
<div class="section"><div class="titlepage"><div><div>
    <div class="translateArticle"><h2 class="title" style="clear: both">2.3 디바이스 해석</h2></div><div class="originalArticle"><h2 class="title" style="clear: both"><a name="device-resolution" href="#device-resolution"></a>2.3&nbsp;Device resolution</h2></div>
</div></div></div>
<div class="translateArticle"><p> 디바이스 해석은 어떤 기기에서 요청이 들어왔는지 결정하기 위해 HTTP요청을 검사합니다. 이것은 일반적으로 User-Agent 헤더와 다른 요청헤더를 분석함으로써 이뤄집니다.
</p>
<p>기초적인 레벨에서 디바이스 해석은 이 질문에 대답을 합니다 "클라이언트가 모바일 혹은 타블렛을 사용하는가?". 이 대답은 당신의 어플리케이션이 작은 화면을 가지는 모바일 디바이스나 터치 인터페이스를 가지는 태블릿 디바이스에 대해 다르게 응답할 수 있게 해줍니다. 좀 더 복잡한 디바이스 해석기가 또한 좀 더 구체적인 스크린 사이즈, 제조업체, 모델, 선호된 마크업같은 디바이스 특징을 식별할 수 있습니다. </p>
<p>스프링 모바일에서는 <code class="interfacename">DeviceResolver</code> 인터페이스가 디바이스 해석을 위한 인터페이스를 정의합니다. :</p></div>

<div class="originalArticle"><p>Device resolution is the process of introspecting an HTTP request to determine the device that
originated the request. It is typically achieved by analyzing the User-Agent header and other request headers.
</p>
<p>At the most basic level, device resolution answers the question: "Is the client using a mobile or tablet
device?". This answer enables your application to respond differently to mobile devices that have small
screens, or tablet devices that have a touch interface. More sophisticated device resolvers are also capable
of identifying specific device capabilities, such as screen size, manufacturer, model, or preferred markup.</p>
<p>In Spring Mobile, the <code class="interfacename">DeviceResolver</code> interface defines the API for device
resolution:</p></div>

<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> DeviceResolver {

    Device resolveDevice(HttpServletRequest request);
    
}
            </pre><p>
</p>
<div class="translateArticle"><p>반환된 <code class="interfacename">Device</code> 모듈이 디바이스 해석의 결과를 모델링합니다. :</p></div><div class="originalArticle"><p>The returned <code class="interfacename">Device</code> models the result of device resolution:</p></div>
<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Device {
    
    <strong class="hl-tag" style="color: blue">/**
     * True if this device is not a mobile or tablet device.
     */</strong>
    <span class="hl-keyword">boolean</span> isNormal();

    <strong class="hl-tag" style="color: blue">/**
     * True if this device is a mobile device such as an Apple iPhone or an 
     * Android Nexus One. Could be used by a pre-handle interceptor to redirect 
     * the user to a dedicated mobile web site. Could be used to apply a 
     * different page layout or stylesheet when the device is a mobile device.
     */</strong>
    <span class="hl-keyword">boolean</span> isMobile();
    
    <strong class="hl-tag" style="color: blue">/**
     * True if this device is a tablet device such as an Apple iPad or a 
     * Motorola Xoom. Could be used by a pre-handle interceptor to redirect 
     * the user to a dedicated tablet web site. Could be used to apply a 
     * different page layout or stylesheet when the device is a tablet device.
     */</strong>
    <span class="hl-keyword">boolean</span> isTablet();

    <strong class="hl-tag" style="color: blue">/**
     *
     * @return resolved DevicePlatform
     */</strong>
    DevicePlatform getDevicePlatform();

}
            </pre><p>
</p>
<div class="translateArticle"><p>위에서 보신 대로, <code class="methodname">Device.isMobile()</code> 은 클라이언트가 스마트폰같은 모바일기기인지 검사하는 데 사용될 수 있습니다. 비슷하게  <code class="methodname">Device.isTablet()</code> 은 클라이언트가 태블릿인지 검사하는 데 사용될 수 있습니다. 추가적으로 디바이스 플랫폼은 <code class="methodname">Device.getDevicePlatform()</code> 프로퍼티를 검사함으로써 결정될 수 있습니다. 사용하고 있는 <code class="interfacename">DeviceResolver</code>에 따라서, <code class="interfacename">Device</code> 는 추가적은 프로퍼티 정보를 갖지 않을 수 있습니다. 
</div>

<div class="originalArticle"><p>As shown above, <code class="methodname">Device.isMobile()</code> can be used to determine if the client is
using a mobile device, such as a smart phone. Similarly, <code class="methodname">Device.isTablet()</code> can be
used to determine if the client is running on a tablet device. Additionally, the device platform may be
determined by inspecting the <code class="methodname">Device.getDevicePlatform()</code> property. Depending on the
<code class="interfacename">DeviceResolver</code> in use, a <code class="interfacename">Device</code> may support
being downcast to access additional properties.</p></div>


<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="device-request-handling" href="#device-request-handling"></a>2.3.1&nbsp;When to perform</h3></div></div></div>
<div class="translateArticle"><p> 웹어플리케이션은 요청처리를 시작할 때, 어떤 요청핸들러가 발동되기 전에, 디바이스 해석을 수행해야 합니다. 이것은 어떤 처리가 발생하기 전에 리퀘스트scope에서 <code class="interfacename">Device</code> 모델이 만들어진다는 것을 보장합니다. 리퀘스트 핸들러는 그 후에 <code class="interfacename">Device</code> 인스턴스를 얻을 수 있고, 요청 상태에 따라 다르게 응답할 수 있게 하는 데 그 인스턴스를 사용합니다..</p>
</div><div class="originalArticle"><p>Web applications should perform device resolution at the beginning of request processing, before any
request handler is invoked. This ensures the <code class="interfacename">Device</code> model can be made
available in request scope before any processing occurs. Request handlers can then obtain the
<code class="interfacename">Device</code> instance and use it to respond differently based on its state.</p></div>


<div class="translateArticle"><p>기본적으로는,  <code class="classname">LiteDeviceResolver</code> 가 디바이스 해석을 위해 사용됩니다.  당신은 또한 생성자 아규먼트에 주입을 하여서 다른 <code class="interfacename">DeviceResolver</code>구현체를 플러그인할 수 있습니다.</p></div>

<div class="originalArticle"><p>By default, a <code class="classname">LiteDeviceResolver</code> is used for device resolution. You may
plug-in another <code class="interfacename">DeviceResolver</code> implementation by injecting a constructor
argument.</p></div>

<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="device-resolver-handler-interceptor" href="#device-resolver-handler-interceptor"></a>DeviceResolverHandlerInterceptor</h4></div></div></div>


<div class="translateArticle"><p>스프링 모바일은 <code class="interfacename">HandlerInterceptor</code>를 가지고 <code class="methodname">preHandle</code>에서 <code class="interfacename">DeviceResolver</code>에게 위임을 합니다. 해석된  <code class="interfacename">Device</code>는 'currentDevice'라는 요청속성(reqeust attribute) 아래에 색인되어서 요청처리를 통해 디바이스가  핸들러에서 사용가능하게 해줍니다.
.</p></div>

<div class="originalArticle"><p>Spring Mobile ships with a <code class="interfacename">HandlerInterceptor</code> that, on
<code class="methodname">preHandle</code>, delegates to a <code class="interfacename">DeviceResolver</code>. The
resolved <code class="interfacename">Device</code> is indexed under a request attribute named
'currentDevice', making it available to handlers throughout request processing.</p></div>


<div class="translateArticle"><p>
    활성화 시키기 위해 <code class="classname">DeviceResolverHandlerInterceptor</code>를 <code class="classname">DispatcherServlet</code> 설정에 정의된 인터셉터 목록에 추가하겠습니다. 
    </p>
</div>

<div class="originalArticle"><p>To enable, add the <code class="classname">DeviceResolverHandlerInterceptor</code> to the list of
interceptors defined in your <code class="classname">DispatcherServlet</code> configuration:</p>
</div>

<pre class="programlisting">
<span class="hl-tag">&lt;interceptors&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, resolve the device that originated the web request --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.DeviceResolverHandlerInterceptor"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/interceptors&gt;</span>
                    </pre><p>
</p>

<div class="translateArticle"><p>아니면, 당신은 <a class="ulink" href="http://docs.spring.io/spring/docs/3.2.4.RELEASE/spring-framework-reference/html/beans.html#beans-java" target="_top">
<em class="citetitle">자가기반의 콘테이너 설정</em></a>을 사용하는 <code class="classname">DeviceResolverHandlerInterceptor</code> 를 추가할 수 있습니다. :
</p>
</div><div class="originalArticle"><p>Alternatively, you can add the <code class="classname">DeviceResolverHandlerInterceptor</code> using
Spring's <a class="ulink" href="http://docs.spring.io/spring/docs/3.2.4.RELEASE/spring-framework-reference/html/beans.html#beans-java" target="_top">
<em class="citetitle">Java-based container configuration</em></a>:
</p>
</div>
<pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> DeviceResolverHandlerInterceptor deviceResolverHandlerInterceptor() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DeviceResolverHandlerInterceptor();
}

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(deviceResolverHandlerInterceptor());
}
                    </pre><p>
</p>
</div>


<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="device-resolver-request-filter" href="#device-resolver-request-filter"></a>DeviceResolverRequestFilter</h4></div></div></div>
        <div class="translateArticle">
            <p><code class="classname">DeviceResolverHandlerInterceptor</code>에 대한 대안으로 , 스프링 모바일은 또한 서블릿필터를 가지고서 <code class="interfacename">DeviceResolver</code>에게 위임할 수 있습니다. 해석된  <code class="interfacename">Device</code>는 'currentDevice'라는 요청속성(reqeust attribute) 아래에 색인되어서 요청처리를 통해 디바이스가  핸들러에서 사용가능하게 해줍니다.</p>
<p> 이것을 활성화하기 위해 <code class="classname">DeviceResolverRequestFilter</code>를 당신의 web.xml 에 추가하겠습니다. : 
</p>
        </div>
        <div class="originalArticle">
            <p>As an alternative to the <code class="classname">DeviceResolverHandlerInterceptor</code>, Spring Mobile
also ships with a Servlet Filter that delegates to a <code class="interfacename">DeviceResolver</code>.
As with the <code class="interfacename">HandlerInterceptor</code>, the
resolved <code class="interfacename">Device</code> is indexed under a request attribute named
'currentDevice', making it available to handlers throughout request processing.</p>
<p>To enable, add the <code class="classname">DeviceResolverRequestFilter</code> to your web.xml:
</p>
        </div>    

        

<pre class="programlisting">
<span class="hl-tag">&lt;filter&gt;</span>
  <span class="hl-tag">&lt;filter-name&gt;</span>deviceResolverRequestFilter<span class="hl-tag">&lt;/filter-name&gt;</span>
  <span class="hl-tag">&lt;filter-class&gt;</span>org.springframework.mobile.device.DeviceResolverRequestFilter<span class="hl-tag">&lt;/filter-class&gt;</span>
<span class="hl-tag">&lt;/filter&gt;</span>
                    </pre><p>
</p>
</div>
</div>


<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="device-web-argument-resolver" href="#device-web-argument-resolver"></a>2.3.2&nbsp;Obtaining a reference to the current device</h3></div></div></div>
<div class="translateArticle"><p>
    당신의 코드에서  현재 <code class="interfacename">Device</code> 를 찾을 필요가 있을 때, 당신은 몇 가지 방법으로 이것을 할 수가 있습니다.
    만약 당신이 이미  <code class="interfacename">ServletRequest</code> 나 스프링의 <code class="interfacename">WebRequest</code>에 대한 참조를 가지고 있다면 
    간단하게 <code class="classname">DeviceUtils</code>를 사용하세요 : 

</p>
</div><div class="originalArticle"><p>When you need to lookup the current <code class="interfacename">Device</code> in your code, you can do
so in several ways. If you already have a reference to a <code class="interfacename">ServletRequest</code> or
Spring <code class="interfacename">WebRequest</code>, simply use <code class="classname">DeviceUtils</code>:
</p>
</div>

<pre class="programlisting">
Device currentDevice = DeviceUtils.getCurrentDevice(servletRequest);
                </pre><p>
</p>


<div class="translateArticle"><p> 만약 당신이 현재 <code class="interfacename">Device</code>를 컨트롤러 메소드의 아규먼트로 전달하고 싶다면, <code class="classname">DeviceWebArgumentResolver</code>를 설정하세요 : 
</p>
</div>

<div class="originalArticle"><p>If you'd like to pass the current <code class="interfacename">Device</code> as an argument to one of
your <code class="interfacename">@Controller</code> methods, configure a
<code class="classname">DeviceWebArgumentResolver</code>:
</p>
</div>

<pre class="programlisting">
<span class="hl-tag">&lt;annotation-driven&gt;</span>
  <span class="hl-tag">&lt;argument-resolvers&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.DeviceWebArgumentResolver"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-tag">&lt;/argument-resolvers&gt;</span>
<span class="hl-tag">&lt;/annotation-driven&gt;</span>
                </pre><p>
</p>
<div class="translateArticle"><p>당신은 또한 자바 설정을 사용해서  <code class="classname">DeviceHandlerMethodArgumentResolver</code> 를 설정할 수 있습니다.  </p>
</div><div class="originalArticle"><p>You can alternatively configure a <code class="classname">DeviceHandlerMethodArgumentResolver</code> using
Java-based configuration:
</p>
</div>
<pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> DeviceHandlerMethodArgumentResolver deviceHandlerMethodArgumentResolver() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DeviceHandlerMethodArgumentResolver();
}

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {
    argumentResolvers.add(deviceHandlerMethodArgumentResolver());
}
                </pre><p>
</p>

<div class="translateArticle"><p>
당신은 또한  <code class="interfacename">Device</code> 를 당신의 <code class="interfacename">@Controller</code>에 다음과 같이 주입할 수 있습니다. 
</p>
</div>

<div class="originalArticle"><p>You can then inject the <code class="interfacename">Device</code> into your
<code class="interfacename">@Controllers</code> as shown below:
</p>
</div>
<pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Controller</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HomeController {

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> Logger logger = LoggerFactory.getLogger(HomeController.<span class="hl-keyword">class</span>);

    <em><span class="hl-annotation" style="color: gray">@RequestMapping("/")</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> home(Device device) {
        <span class="hl-keyword">if</span> (device.isMobile()) {
            logger.info(<span class="hl-string">"Hello mobile user!"</span>);
        } <span class="hl-keyword">else</span> <span class="hl-keyword">if</span> (device.isTablet()) {
            logger.info(<span class="hl-string">"Hello tablet user!"</span>);
        } <span class="hl-keyword">else</span> {
            logger.info(<span class="hl-string">"Hello desktop user!"</span>);         
        }
    }

}
                </pre><p>
</p>
</div>
<div class="section"><div class="titlepage"><div><div>
    <div class="translateArticle"> <h3 class="title"><a name="device-resolvers" href="#device-resolvers"></a>2.3.3&nbsp;지원되는 DeviceResolver 구현체</h3> </div>
    <div class="originalArticle">    <h3 class="title"><a name="device-resolvers" href="#device-resolvers"></a>2.3.3&nbsp;Supported DeviceResolver implementations</h3></div></div></div></div>


<div class="translateArticle"><p> 스프링 모바일은 다른 디바이스 리졸버 구현체들의 개발을 가능하게 해줘서 다양한 레벨의 해석가능성을 제공합니다. 첫번째로 기본적으로 <code class="classname">LiteDeciceResolver</code>는 모바일디바이스의 존재를 감지하지만, 구체적인 특징은 감지하지 못합니다..</p>
</div>

<div class="originalArticle"><p>Spring Mobile allows for the development of different DeviceResolver implementations that offer
varying levels of resolution capability. The first, and the default, is a
<code class="classname">LiteDeviceResolver</code> that detects the presence of a mobile device but does not detect
specific capabilities.</p>
</div>


<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="lite-device-resolver" href="#lite-device-resolver"></a>LiteDeviceResolver</h4></div></div></div>

<div class="translateArticle"><p>기본적인 <code class="interfacename">DeviceResolver</code> 구현체는 "lite"
<a class="ulink" href="http://plugins.trac.wordpress.org/browser/wordpress-mobile-pack/trunk/plugins/wpmp_switcher/lite_detection.php" target="_top">
<em class="citetitle">감지 알고리즘</em></a>에 기반을 두고 있으며 이것은 
<a class="ulink" href="http://wordpress.org/extend/plugins/wordpress-mobile-pack" target="_top"><em class="citetitle">Wordpress Mobile Pack
</em></a>의 일부로 구현되었습니다.. 이 해석기는 오직 모바일이나 태블릿 디바이스의 존재를 감지하고 구체적인 특징은 감지하지 못합니다. 이 해석기를 활성화하기 위해 어떠한 특별한 설정도 필요하지 않습니다. 단순히 기본적인 <code class="classname">DeviceResolverHandlerInteceptor</code>를 설정하면 이것은 당신을 위해 활성화될 것입니다..</p></div>


<div class="originalArticle"><p>The default <code class="interfacename">DeviceResolver</code> implementation is based on the "lite"
<a class="ulink" href="http://plugins.trac.wordpress.org/browser/wordpress-mobile-pack/trunk/plugins/wpmp_switcher/lite_detection.php" target="_top">
<em class="citetitle">detection algorithm</em></a> implemented as part of the
<a class="ulink" href="http://wordpress.org/extend/plugins/wordpress-mobile-pack" target="_top"><em class="citetitle">Wordpress Mobile Pack
</em></a>. This resolver only detects the presence of a mobile or tablet device, and does
not detect specific capabilities. No special configuration is required to enable this resolver, simply
configure a default <code class="classname">DeviceResolverHandlerInterceptor</code> and it will be enabled for
you.</p></div>

        <div class="translateArticle">
            
<p><code class="classname">LiteDeviceResolver</code> 가 부적절하게 User-Agent를 모바일 디바이스로 읽는 경우가 생길 수 있습니다. <code class="classname">LiteDeviceResolver</code>는 "보통"기기를 해석하기 위한 User-agent 키워드 목록을 세팅 할 수 있게 해주며, 효과적으로 기본 행동을 오버라이딩 할 수 있습니다. 이러한 키워드는 모바일이나 태블릿 디바이스 감지 키워드 이전에 우선권을 가지게 됩니다. 다음의 예제는 어떻게 보통 키워드를 <code class="classname">DeviceResolverHandlerInterceptor</code>의 설정에 생성자 아규먼트를 통해 설정하는지 보여줍니다. 이러한 경우 "iphone"이나 "android" 를 포함하는 User-Agenets는 더 이상 모바일 디바이스를 해석하지 않습니다. (맞나..?)   
</p>

        </div>
        <div class="originalArticle">
            
<p>It is possible that the <code class="classname">LiteDeviceResolver</code> incorrectly identifies a
User-Agent as a mobile device. The <code class="classname">LiteDeviceResolver</code> provides a configuration
option for setting a list of User-Agent keywords that should resolve to a "normal" device, effectively
overriding the default behavior. These keywords take precedence over the mobile and tablet device
detection keywords. The following example illustrates how to set the normal keywords in the
configuration of the <code class="classname">DeviceResolverHandlerInterceptor</code> by injecting a
constructor argument. In this case, User-Agents that contain "iphone" and "android" would no longer
resolve to a mobile device.
</p>

        </div>    

        

<pre class="programlisting">
<span class="hl-tag">&lt;interceptors&gt;</span>
  <span class="hl-comment">&lt;!-- Detects the client's Device --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.DeviceResolverHandlerInterceptor"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg&gt;</span>
      <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.LiteDeviceResolver"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;constructor-arg&gt;</span>
          <span class="hl-tag">&lt;list&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>iphone<span class="hl-tag">&lt;/value&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>android<span class="hl-tag">&lt;/value&gt;</span>
          <span class="hl-tag">&lt;/list&gt;</span>
        <span class="hl-tag">&lt;/constructor-arg&gt;</span>
      <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;/constructor-arg&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/interceptors&gt;</span>
                    </pre><p>
</p>


        <div class="translateArticle">
            <p>자바설정을 통해서도 할 수 있습니다. </p>

        </div>
        <div class="originalArticle">
            <p>The same thing can be accomplished using Java-based configuration.
</p>

        </div>    

        
<pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> LiteDeviceResolver liteDeviceResolver() {
    List&lt;String&gt; keywords = <span class="hl-keyword">new</span> ArrayList&lt;String&gt;();
    keywords.add(<span class="hl-string">"iphone"</span>);
    keywords.add(<span class="hl-string">"android"</span>);
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> LiteDeviceResolver(keywords);
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> DeviceResolverHandlerInterceptor deviceResolverHandlerInterceptor() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DeviceResolverHandlerInterceptor(liteDeviceResolver());
}

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(deviceResolverHandlerInterceptor());
}
                    </pre><p>
</p>
        <div class="translateArticle">
            <p>
                대안적으로, 당신은 <code class="classname">LiteDeviceResolver</code>를 상속하고 <code class="methodname">init()</code>메소드를 오버라이딩하여 당신의 값을 넣을 수 있습니다. 
</p>

        </div>
        <div class="originalArticle">
            <p>Alternatively, you may subclass <code class="classname">LiteDeviceResolver</code>, and set the
values by overriding the <code class="methodname">init()</code> method.
</p>

        </div>    

        

<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomLiteDeviceResolver <span class="hl-keyword">extends</span> LiteDeviceResolver {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> init() {
        <span class="hl-keyword">super</span>.init();
        getNormalUserAgentKeywords().addAll(Arrays.asList(NORMAL_KEYWORDS));
    };

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String[] NORMAL_KEYWORDS = <span class="hl-keyword">new</span> String[] { <span class="hl-string">"iphone"</span>, <span class="hl-string">"android"</span> };

}
                    </pre><p>
</p>
</div>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="site-preference" href="#site-preference"></a>2.4&nbsp;Site preference management</h2></div></div></div>


        <div class="translateArticle">
            <p> 디바이스 해석은 종종 어떤 사이트가 사용자에게 제공될 것인지 결정되는 데 사용됩니다. 예를 들자면, 모바일 유저가 작은 화면에 최적화된 내용을 포함하는 모바일 사이트를 제공받을 것이고, 아니면 데스크탑 유저가 평범한 사이트를 제공받을 것입니다.  여러 개의 사이트를 지원하는 것은 <code class="methodname">Device.isMobile()</code>과, 이 값에 의해 많은 컨트롤러와 뷰 렌더링 로직에 기반하여 가능합니다. 이와같이 태블릿에 대한 지원또한  <code class="methodname">Device.isTablet()</code>를 사용함으로써 가능합니다.  </p>

        </div>
        <div class="originalArticle">
            <p>Device resolution is often used to determine which "site" will be served to the user. For example, a
mobile user may be served a "mobile site" that contains content optimized for display on a small screen, while
a desktop user would be served the "normal site". Support for multiple sites can be achieved by introspecting
<code class="methodname">Device.isMobile()</code> and varying controller and view rendering logic based on its value.
Likewise, support for tablets is achieved by using <code class="methodname">Device.isTablet()</code>.</p>

        </div>    

        

        <div class="translateArticle">
            
<p>하지만, 어플리케이션이 여러 개의 사이트를 지원하면서 유저로 하여로 하여금 필요할 때 그 사이트들 간을 스위칭하게 하는 것은 좋은 사용경험으로 필요합니다. 예를 들면 모바일 유저가 현재 모바일 사이트를 보고 있지만, 보통 사이트를 대신 보고 할지도 모릅니다. 왜냐하면 몇몇 콘텐츠들은 모바일UI로 접근이 힘들기 때문입니다. </p>

        </div>
        <div class="originalArticle">
            
<p>However, when an application supports multiple sites, allowing the user to switch between them, if
desired, is considered a good usability practice. For example, a mobile user currently viewing the mobile site
may wish to access the normal site instead, perhaps because some content he or she would like to access is not
available through the mobile UI.</p>

        </div>    

        

        <div class="translateArticle">
            
<p> 디바이스 해석 시스템에서 Building 하는 것은 이러한 종류의 유저 사이트 선호를 제공하는 것입니다. 이러한 기능은 사용자에게 평범한 사이트, 모바일, 태블릿 사이트를 선호하는 지 가리키게 해줍니다. 가리켜진 <code class="interfacename">SitePreference</code>는 그 후에 많은 컨트롤과 뷰렌더링 로직에 사용될 것입니다.   </p>

        </div>
        <div class="originalArticle">
            
<p>Building on the device resolution system is a facility for this kind of "user site preference
management". This facility allows the user to indicate if he or she prefers the normal, mobile or tablet
sites. The indicated <code class="interfacename">SitePreference</code> may then be used to vary control and view
rendering logic.</p>

        </div>    

        

        <div class="translateArticle">
            <p> <code class="interfacename">SitePreferenceHandler</code> 인터페이스는 선호 사이트 관리를 위한 핵심 서비스 API를 정의합니다. </p>

        </div>
        <div class="originalArticle">
            <p>The <code class="interfacename">SitePreferenceHandler</code> interface defines the core service API for site
preference management:
</p>

        </div>    

        
<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> SitePreferenceHandler {

    <strong class="hl-tag" style="color: blue">/**
     * The name of the request attribute that holds the current user's site 
     * preference value.
     */</strong>
    <span class="hl-keyword">final</span> String CURRENT_SITE_PREFERENCE_ATTRIBUTE = <span class="hl-string">"currentSitePreference"</span>;

    <strong class="hl-tag" style="color: blue">/**
     * Handle the site preference aspect of the web request.
     * Implementations should first check if the user has indicated a site 
     * preference. If so, the indicated site preference should be saved and 
     * remembered for future requests. If no site preference has been 
     * indicated, an implementation may derive a default site preference from 
     * the {@link Device} that originated the request. After handling, the 
     * user's site preference is returned and also available as a request 
     * attribute named 'currentSitePreference'.
     */</strong>
     SitePreference handleSitePreference(HttpServletRequest request, HttpServletResponse response);

}
            </pre><p>
</p>
        <div class="translateArticle">
            <p>해석된 선호사이트는 이늄밸류값입니다. </p>

        </div>
        <div class="originalArticle">
            <p>The resolved SitePreference is an enum value:
</p>

        </div>    

        
<pre class="programlisting">
<span class="hl-keyword">public</span> enum SitePreference {
    
    <strong class="hl-tag" style="color: blue">/**
     * The user prefers the 'normal' site.
     */</strong>
    NORMAL {
        <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> isNormal() {
            <span class="hl-keyword">return</span> true;
        }
    },
    
    <strong class="hl-tag" style="color: blue">/**
     * The user prefers the 'mobile' site.
     */</strong>
    MOBILE {        
        <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> isMobile() {
            <span class="hl-keyword">return</span> true;
        }
    },
    
    <strong class="hl-tag" style="color: blue">/**
     * The user prefers the 'tablet' site.
     */</strong>
    TABLET {        
        <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> isTablet() {
            <span class="hl-keyword">return</span> true;
        }
    };
    
    <strong class="hl-tag" style="color: blue">/**
     * Tests if this is the 'normal' SitePreference.
     * Designed to support concise SitePreference boolean expressions 
     * e.g. &lt;c:if test="${currentSitePreference.normal}"&gt;&lt;/c:i&gt;.
     */</strong>
    <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> isNormal() {
        <span class="hl-keyword">return</span> (!isMobile() &amp;&amp; !isTablet());
    }

    <strong class="hl-tag" style="color: blue">/**
     * Tests if this is the 'mobile' SitePreference.
     * Designed to support concise SitePreference boolean expressions 
     * e.g. &lt;c:if test="${currentSitePreference.mobile}"&gt;&lt;/c:i&gt;.
     */</strong>
    <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> isMobile() {
        <span class="hl-keyword">return</span> false;
    }
    
    <strong class="hl-tag" style="color: blue">/**
     * Tests if this is the 'tablet' SitePreference.
     * Designed to support concise SitePreference boolean expressions 
     * e.g. &lt;c:if test="${currentSitePreference.tablet}"&gt;&lt;/c:i&gt;;.
     */</strong>
    <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> isTablet() {
        <span class="hl-keyword">return</span> false;
    }
    
}
            </pre><p>
</p>
        <div class="translateArticle">
            <p>
                스프링 모바일은 <code class="classname">StandardSitePreferenceHandler</code>라 이름붙여진 단일 <code class="interfacename">SitePreferenceHandler</code> 구현체를 제공하며 이것은 대부분의 필요에 적합합니다. 이것은 쿼리 파라미터기반의 선호사이트표시,  pluugable 한 <code class="classname">SitePreference</code>저장소 를 지원하며 스프링 MVC에서 HandlerInterceptor를 이용하여 활성화됩니다. 추가적으로 <code class="interfacename">SitePreference</code>가 명시되지 않았다면 기본값은 사용자의 기기에 의해 결정됩니다..
            </p>

        </div>
        <div class="originalArticle">
            <p>Spring Mobile provides a single <code class="interfacename">SitePreferenceHandler</code> implementation
named <code class="classname">StandardSitePreferenceHandler</code>, which should be suitable for most needs. It
supports query-parameter-based site preference indication, pluggable <code class="classname">SitePreference</code>
storage, and may be enabled in a Spring MVC application using a HandlerIntercepor. In addition, if no
<code class="interfacename">SitePreference</code> has been explcitly indicated by the user, a default will be
derived based on the user's Device (MOBILE for mobile devices, TABLET for tablet devices, and NORMAL
otherwise).</p>

        </div>    

        


<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="indicating-site-preference" href="#indicating-site-preference"></a>2.4.1&nbsp;Indicating a site preference</h3></div></div></div>

        <div class="translateArticle">
            <p> 사용자는 아마 다음의 선호 사이트쿼리파라미터를 전송하는 링크를 활성화하여서 선호하는 사이트를 지시할 것입니다. 
</p>

        </div>
        <div class="originalArticle">
            <p>The user may indicate a site preference by activating a link that submits the site_preference query
parameter:
</p>

        </div>    

        

<pre class="programlisting">
Site: <span class="hl-tag">&lt;a</span> <span class="hl-attribute">href</span>=<span class="hl-value">"${currentUrl}?site_preference=normal"</span><span class="hl-tag">&gt;</span>Normal<span class="hl-tag">&lt;/a&gt;</span> | 
<span class="hl-tag">&lt;a</span> <span class="hl-attribute">href</span>=<span class="hl-value">"${currentUrl}?site_preference=mobile"</span><span class="hl-tag">&gt;</span>Mobile<span class="hl-tag">&lt;/a&gt;</span>
                </pre>

        <div class="translateArticle">
                            <p>
사용자를 위해 지시된 선호 사이트는 
<code class="interfacename">SitePreferenceRepository</code> 에 저장되고, currentSitePreference라 이름붙여진 요청 속성으로 사용가능하게 해집니다. 
</p>


        </div>
        <div class="originalArticle">
                            <p>
The indicated site preference is saved for the user in a
<code class="interfacename">SitePreferenceRepository</code>, and made available as a request attribute
named 'currentSitePreference'.
</p>


        </div>    


</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="site-preference-storage" href="#site-preference-storage"></a>2.4.2&nbsp;Site preference storage</h3></div></div></div>

        <div class="translateArticle">
            <p>
                가리켜진 선호사이트는 <code class="interfacename">SitePreferenceRepository</code>에 저장될 수 있으며, 유저에 의해 만들어진 다음의 요청에서 기억될 것입니다. 
                <code class="classname">CookieSitePreferenceRepository</code> 는 기본 구현체이고 사용자의 선호를 클라이언트 사이트 쿠키에 저장합니다. 

</p>

        </div>
        <div class="originalArticle">
            <p>Indicated site preferences are stored in a <code class="interfacename">SitePreferenceRepository</code>
so they are remembered in future requests made by the user.
<code class="classname">CookieSitePreferenceRepository</code> is the default implementation and stores the user's'
preference in a client-side cookie.
</p>

        </div>    

        
<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> SitePreferenceRepository {

    <strong class="hl-tag" style="color: blue">/**
     * Load the user's site preference.
     * Returns null if the user has not specified a preference.
     */</strong>
    SitePreference loadSitePreference(HttpServletRequest request);
    
    <strong class="hl-tag" style="color: blue">/**
     * Save the user's site preference.
     */</strong>
    <span class="hl-keyword">void</span> saveSitePreference(SitePreference preference, HttpServletRequest request, HttpServletResponse response);

}
                </pre><p>
</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="site-preference-handler-interceptor" href="#site-preference-handler-interceptor"></a>2.4.3&nbsp;Enabling site preference management</h3></div></div></div>

        <div class="translateArticle">
            
<p> 요청이 처리 되기 전에 <code class="interfacename">SitePreference</code> 관리를 활성화하기 위해, <code class="classname">SitePreferenceHandlerInterceptor</code>를 당신의 <code class="classname">DispatcherServlet</code> 에 추가해줍시다.</p>

        </div>
        <div class="originalArticle">
            
<p>To enable <code class="interfacename">SitePreference</code> management before requests are processed,
add the <code class="classname">SitePreferenceHandlerInterceptor</code> to your
<code class="classname">DispatcherServlet</code> configuration:</p>

        </div>    

        

<pre class="programlisting">
<span class="hl-tag">&lt;interceptors&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, manage the user's site preference (declare after DeviceResolverHandlerInterceptor) --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.site.SitePreferenceHandlerInterceptor"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/interceptors&gt;</span>
            </pre>
        <div class="translateArticle">
            <p>자바 설정 또한 가능합니다. </p>
        </div>
        <div class="originalArticle">
            <p>Java-based configuration is also available:</p>
        </div>    

        
<pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> SitePreferenceHandlerInterceptor sitePreferenceHandlerInterceptor() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> SitePreferenceHandlerInterceptor();
}

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(sitePreferenceHandlerInterceptor());
}
            </pre>

        <div class="translateArticle">
            <p> 기본적으로, 인터셉터는  <code class="classname">CookieSitePreferenceRepository</code>와 함께 설정된 <code class="classname">StandardSitePreferenceHandler</code>에게 위임할 것입니다. 당신은 생성자 아규먼트를 주입하여 다른 <code class="interfacename">SitePreferenceHandler</code>를 플러그인 할 수가 있을 것입니다. 인터셉터가 동작한 이후에 <code class="classname">SitePreferece</code>는 currentSitePreference라는 이름의 리퀘스트 속성으로 사용가능해질 것입니다. 

            </p>

        </div>
        <div class="originalArticle">
            <p>By default, the interceptor will delegate to a <code class="classname">StandardSitePreferenceHandler</code>
configured with a <code class="classname">CookieSitePreferenceRepository</code>. You may plug-in another
<code class="interfacename">SitePreferenceHandler</code> by injecting a constructor argument. After the
interceptor is invoked, the <code class="classname">SitePreference</code> will be available as a request attribute
named 'currentSitePreference'.</p>

        </div>    

        

</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="site-preference-web-argument-resolver" href="#site-preference-web-argument-resolver"></a>2.4.4&nbsp;Obtaining a reference to the current site preference</h3></div></div></div>

    <div class="translateArticle">
      <p>
        당신의 코드에서  현재 <code class="classname">SitePreference</code>  를 찾을 필요가 있을 때, 당신은 몇 가지 방법으로 이것을 할 수가 있습니다.
    만약 당신이 이미  <code class="interfacename">ServletRequest</code> 나 스프링의 <code class="interfacename">WebRequest</code>에 대한 참조를 가지고 있다면 
    간단하게 <code class="classname">SitePreferenceUtils</code>를 사용하세요 : 
</p>

    </div>
    <div class="originalArticle">
      <p>When you need to lookup the current <code class="classname">SitePreference</code> in your code, you can do
so in several ways. If you already have a reference to a <code class="interfacename">ServletRequest</code> or
Spring <code class="interfacename">WebRequest</code>, simply use <code class="classname">SitePreferenceUtils</code>:
</p>

    </div>  

      
<pre class="programlisting">
SitePreference sitePreference = SitePreferenceUtils.getCurrentSitePreference(servletRequest);
            </pre>

    <div class="translateArticle">
      <p> 만약 당신이  현재 <code class="classname">SitePreference</code>를 <code class="interfacename">@Controller</code> 메소드들 중의 하나에 대한 아규먼트로 전달하고 싶다면, <code class="classname">SitePreferenceWebArgumentResolver</code>를 설정하세요.
</p>

    </div>
    <div class="originalArticle">
      <p>If you'd like to pass the current <code class="classname">SitePreference</code> as an argument to one of
your <code class="interfacename">@Controller</code> methods, configure a
<code class="classname">SitePreferenceWebArgumentResolver</code>:
</p>

    </div>  

      


<pre class="programlisting">
<span class="hl-tag">&lt;annotation-driven&gt;</span>
  <span class="hl-tag">&lt;argument-resolvers&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.site.SitePreferenceWebArgumentResolver"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-tag">&lt;/argument-resolvers&gt;</span>
<span class="hl-tag">&lt;/annotation-driven&gt;</span>
                </pre><p>
</p>

<div class="translateArticle"><p>자바 설정 또한 가능합니다 </p></div><div class="originalArticle"><p>Java-based configuration is also available:</p></div>

<pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> SitePreferenceHandlerMethodArgumentResolver sitePreferenceHandlerMethodArgumentResolver() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> SitePreferenceHandlerMethodArgumentResolver();
}

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) { 
    argumentResolvers.add(sitePreferenceHandlerMethodArgumentResolver());
}
                </pre><p>
</p>

    <div class="translateArticle">
      <p>당신은 그러면 지시된 <code class="classname">SitePreference</code>를 당신의 <code class="interfacename">@Controller</code> 에 다음과 같이 주입할 수 있습니다. 
</p>

    </div>
    <div class="originalArticle">
      <p>You can then inject the indicated <code class="classname">SitePreference</code> into your
<code class="interfacename">@Controller</code> as shown below:
</p>

    </div>  

      

<pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Controller</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HomeController {

    <em><span class="hl-annotation" style="color: gray">@RequestMapping("/")</span></em>
    <span class="hl-keyword">public</span> String home(SitePreference sitePreference, Model model) {
        <span class="hl-keyword">if</span> (sitePreference == SitePreference.NORMAL) {
            logger.info(<span class="hl-string">"Site preference is normal"</span>);
            <span class="hl-keyword">return</span> <span class="hl-string">"home"</span>;
        } <span class="hl-keyword">else</span> <span class="hl-keyword">if</span> (sitePreference == SitePreference.MOBILE) {
            logger.info(<span class="hl-string">"Site preference is mobile"</span>);
            <span class="hl-keyword">return</span> <span class="hl-string">"home-mobile"</span>;
        } <span class="hl-keyword">else</span> <span class="hl-keyword">if</span> (sitePreference == SitePreference.TABLET) {
            logger.info(<span class="hl-string">"Site preference is tablet"</span>);
            <span class="hl-keyword">return</span> <span class="hl-string">"home-tablet"</span>;
        } <span class="hl-keyword">else</span> {
            logger.info(<span class="hl-string">"no site preference"</span>);
            <span class="hl-keyword">return</span> <span class="hl-string">"home"</span>;
        }
    }

}
                </pre><p>
</p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="site-switcher-handler-interceptor" href="#site-switcher-handler-interceptor"></a>2.5&nbsp;Site switching</h2></div></div></div>


    <div class="translateArticle">
      <p>몇몇 어플리케이션은 그들의 모바일 사이트를 보통의 사이트와는 다른 다른 도메인에서 운영하고 싶을 것입니다. 예를 들자면 구글에 모바일 기기로 접근하면 <code class="literal">m.google.com</code> 로 접속되는 것같이 말입니다.  </p>

    </div>
    <div class="originalArticle">
      <p>Some applications may wish to host their "mobile site" at a different domain from their "normal site".
For example, Google will switch you to <code class="literal">m.google.com</code> if you access
<code class="literal">google.com</code> from your mobile phone.</p>

    </div>  

      

    <div class="translateArticle">
      
<p>스프링 모바일에서는 당신은 아마 <code class="classname">SiteSwitcherHandlerInterceptor</code>를 써서 모바일 유저를 모바일 사이트로 리다이렉트 시킬 것입니다. 
    사용자는 또한 아마 사이트 선호를 지시할 수 있을 것입니다. 예를 들자면, 모바일 유저가 여전히 평범한 사이트를 원하는 경우 같이 말입니다. 표준 사이트 스위칭 관례를 구현하는 편리한 정적 팩토리 메서드가 제공됩니다. 
   </p>

    </div>
    <div class="originalArticle">
      
<p>In Spring Mobile, you may use the <code class="classname">SiteSwitcherHandlerInterceptor</code> to redirect
mobile users to a dedicated mobile site. Users may also indicate a site preference; for example, a mobile user
may still wish to use the 'normal' site. Convenient static factory methods are provided that implement
standard site switching conventions.</p>

    </div>  

      

    <div class="translateArticle">
      
<p><code class="methodname">mDot</code>, <code class="methodname">dotMobi</code> 과  <code class="methodname">urlPath</code>
팩토리 메서드들은 쿠키 기반의 <code class="interfacename">SitePreference</code> 저장소를 설정합니다. 쿠키값은 모바일과 일반 웹사이트간에 공유될 것입니다. 내부적으로 인터셉터가 <code class="interfacename">SitePreferenceHandler</code>에게 위임을 하고 스위처를 쓸 때 <code class="classname">SitePreferenceHandlerInterceptor</code>를 등록할 필요가 없게 됩니다. 
</p>

    </div>
    <div class="originalArticle">
      
<p>The <code class="methodname">mDot</code>, <code class="methodname">dotMobi</code> and <code class="methodname">urlPath</code>
factory methods configure cookie-based <code class="interfacename">SitePreference</code> storage. The cookie value
will be shared across the mobile and normal site domains. Internally, the interceptor delegates to a
<code class="interfacename">SitePreferenceHandler</code>, so there is no need to register a
<code class="classname">SitePreferenceHandlerInterceptor</code> when using the switcher.</p>

    </div>  

      



<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="site-switcher-handler-interceptor-mdot" href="#site-switcher-handler-interceptor-mdot"></a>2.5.1&nbsp;mDot SiteSwitcher</h3></div></div></div>

    <div class="translateArticle">
      <p> <code class="methodname">mDot</code> 팩토리 메서드를 사이트 스위처를 생성하기 위해 사용합니다. 사이트 스위처는 모바일 유저를 m.${serverName}에 리다이렉트 시킵니다. 예를 들면 <code class="literal">m.myapp.com</code>같이 말입니다.
</p>

    </div>
    <div class="originalArticle">
      <p>Use the <code class="methodname">mDot</code> factory method to construct a SiteSwitcher that redirects
mobile users to m.${serverName}; for example, <code class="literal">m.myapp.com</code>:
</p>

    </div>  

      

<pre class="programlisting">
<span class="hl-tag">&lt;interceptors&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, resolve the device that originated the web request --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.DeviceResolverHandlerInterceptor"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, redirects mobile users to "m.myapp.com" (declare after DeviceResolverHandlerInterceptor) --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor"</span> 
      <span class="hl-attribute">factory-method</span>=<span class="hl-value">"mDot"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.String"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"myapp.com"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/interceptors&gt;</span>
                </pre>


    <div class="translateArticle">
      <p>
기본적으로는 태블릿 디바이스는 기본 사이트를 보게 됩니다. 두번째 생성자 아규먼트는 테이블 디바이스를 모바일 사이트로 리다이렉트하게 해주는 데 사용될 수 있습니다. 
</p>

    </div>
    <div class="originalArticle">
      <p>
By default, tablet devices see the 'normal' site. A second constructor argument is available for
specifying that tablet devices are redirected to the 'mobile' site:
</p>

    </div>  

      


<pre class="programlisting">
<span class="hl-tag">&lt;interceptors&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, resolve the device that originated the web request --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.DeviceResolverHandlerInterceptor"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, redirects mobile users to "m.myapp.com" (declare after DeviceResolverHandlerInterceptor) --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor"</span> 
      <span class="hl-attribute">factory-method</span>=<span class="hl-value">"mDot"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.String"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"myapp.com"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.Boolean"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/interceptors&gt;</span>
                </pre><p>
Java-based configuration is also available:
</p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> DeviceResolverHandlerInterceptor deviceResolverHandlerInterceptor() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DeviceResolverHandlerInterceptor();
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> SiteSwitcherHandlerInterceptor siteSwitcherHandlerInterceptor() {
    <span class="hl-keyword">return</span> SiteSwitcherHandlerInterceptor.mDot(<span class="hl-string">"myapp.com"</span>, true);
}

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(deviceResolverHandlerInterceptor());
    registry.addInterceptor(siteSwitcherHandlerInterceptor());
}
                </pre><p>
</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="site-switcher-handler-interceptor-dotmobi" href="#site-switcher-handler-interceptor-dotmobi"></a>2.5.2&nbsp;dotMobi SiteSwitcher</h3></div></div></div>

    <div class="translateArticle">
      <p>
<code class="methodname">dotMobi</code> 팩터리 메서드를 사용해서 사이트스위처를 생성하여, 모바일 유저를 ${serverName - lastDomain}.mobi; 로 리다이렉트 시키세요. 
예를 들자면 <code class="literal">myapp.mobi</code>같은 주소가 되게 됩니다. 
</p>

    </div>
    <div class="originalArticle">
      <p>
Use the <code class="methodname">dotMobi</code> factory method to construct a SiteSwitcher that redirects
mobile users to ${serverName - lastDomain}.mobi; for example, <code class="literal">myapp.mobi</code>:
</p>

    </div>  

      

<pre class="programlisting">
<span class="hl-tag">&lt;interceptors&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, resolve the device that originated the web request --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.DeviceResolverHandlerInterceptor"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, redirects mobile users to "myapp.mobi" (declare after DeviceResolverHandlerInterceptor) --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor"</span> 
      <span class="hl-attribute">factory-method</span>=<span class="hl-value">"dotMobi"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.String"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"myapp.com"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/interceptors&gt;</span>
                </pre>


    <div class="translateArticle">
      <p>
 이전에 <code class="methodname">mDot</code> 팩터리 메서드에서 소개된 것과 마찬가지로, 태블릿 디바이스는 기본 사이트를 봅니다. 두번째 아규먼트가 테블릿 디바이스가 모바일 사이트로 가게 할 수 가 있습니다. 
</p>

    </div>
    <div class="originalArticle">
      <p>
As described earlier with the <code class="methodname">mDot</code> factory method, tablet devices see the
'normal' site. A second constructor argument is available for specifying that tablet devices are
redirected to the 'mobile' site:
</p>

    </div>  

      

<pre class="programlisting">
<span class="hl-tag">&lt;interceptors&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, resolve the device that originated the web request --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.DeviceResolverHandlerInterceptor"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, redirects mobile users to "myapp.mobi" (declare after DeviceResolverHandlerInterceptor) --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor"</span> 
      <span class="hl-attribute">factory-method</span>=<span class="hl-value">"dotMobi"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.String"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"myapp.com"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.Boolean"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/interceptors&gt;</span>
                </pre><p>
Java-based configuration is also available:
</p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> DeviceResolverHandlerInterceptor deviceResolverHandlerInterceptor() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DeviceResolverHandlerInterceptor();
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> SiteSwitcherHandlerInterceptor siteSwitcherHandlerInterceptor() {
    <span class="hl-keyword">return</span> SiteSwitcherHandlerInterceptor.dotMobi(<span class="hl-string">"myapp.com"</span>, true);
}

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(deviceResolverHandlerInterceptor());
    registry.addInterceptor(siteSwitcherHandlerInterceptor());
}
                </pre><p>
</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="site-switcher-handler-interceptor-standard" href="#site-switcher-handler-interceptor-standard"></a>2.5.3&nbsp;Standard SiteSwitcher</h3></div></div></div>


    <div class="translateArticle">
      <p>  <code class="literal">mDot</code> 이나 <code class="literal">dotMobi</code>전략을 위한 더 많은 커스터마이징 설정을 위해서  <code class="methodname">standard</code> 팩터리 메서드가 사용가능합니다. 모바일, 태블릿 사용자들을 특별한 스키마로 이동시키는 사이트스위처를 생성해보세요. </p>

    </div>
    <div class="originalArticle">
      <p>For a more customized configuration of the <code class="literal">mDot</code> or <code class="literal">dotMobi</code>
strategies, the <code class="methodname">standard</code> factory method is available. Construct a SiteSwitcher
that redirects mobile and tablet users to a specified schema:
</p>

    </div>  

      


<pre class="programlisting">
<span class="hl-tag">&lt;interceptors&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, resolve the device that originated the web request --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.DeviceResolverHandlerInterceptor"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, redirects mobile users to "m.myapp.com" (declare after DeviceResolverHandlerInterceptor) --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor"</span> 
      <span class="hl-attribute">factory-method</span>=<span class="hl-value">"standard"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"app.com"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"mobile.app.com"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tablet.app.com"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">value</span>=<span class="hl-value">".app.com"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/interceptors&gt;</span>
                </pre><p>
Java-based configuration is also available:
</p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> DeviceResolverHandlerInterceptor deviceResolverHandlerInterceptor() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DeviceResolverHandlerInterceptor();
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> SiteSwitcherHandlerInterceptor siteSwitcherHandlerInterceptor() {
    <span class="hl-keyword">return</span> SiteSwitcherHandlerInterceptor.standard(<span class="hl-string">"app.com"</span>, 
        <span class="hl-string">"mobile.app.com"</span>, <span class="hl-string">"tablet.app.com"</span>, <span class="hl-string">".app.com"</span>);
}

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(deviceResolverHandlerInterceptor());
    registry.addInterceptor(siteSwitcherHandlerInterceptor());
}
                </pre><p>
</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="site-switcher-handler-interceptor-urlpath" href="#site-switcher-handler-interceptor-urlpath"></a>2.5.4&nbsp;urlPath SiteSwitcher</h3></div></div></div>

    <div class="translateArticle">
      <p><code class="methodname">urlPath</code> 팩터리 메서드를 사용해서 사이트 스위처를 생성하여, 모바일유저를 어플리케이션 내의 다른 경로로 리다이렉트 시키세요. 
        <code class="methodname">mDot</code> 나 <code class="methodname">dotMobi</code>와는 달리 이 사이트스위처는 모바일 사이트를 위한 다른 DNS엔트리를 설정할 필요가 없습니다. 
      </p>

    </div>
    <div class="originalArticle">
      <p>Use the <code class="methodname">urlPath</code> factory method to construct a SiteSwitcher that redirects
mobile users to a different path within the application. Unlike <code class="methodname">mDot</code> and
<code class="methodname">dotMobi</code>, this SiteSwitcher does not require setting up a different DNS entry for
a mobile site.</p>

    </div>  

      

<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e241" href="#d5e241"></a>Mobile Path</h4></div></div></div>


    <div class="translateArticle">
      <p> <code class="methodname">urlPath</code> 팩토리 메소드를 사용하여 사이트스위처를 생성하여, 모바일 유저가 ${serverName}/${mobilePath}로 이동하게 하세요. 예를 들면  <code class="literal">myapp.com/m/</code>와 같은 경로가 됩니다. </p>

    </div>
    <div class="originalArticle">
      <p>Use the <code class="methodname">urlPath</code> factory method to construct a SiteSwitcher that
redirects mobile users to ${serverName}/${mobilePath}; for example, <code class="literal">myapp.com/m/</code>:
</p>

    </div>  

      

<pre class="programlisting">
<span class="hl-tag">&lt;interceptors&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, resolve the device that originated the web request --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.DeviceResolverHandlerInterceptor"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, redirects mobile users to "myapp.com/m" (declare after DeviceResolverHandlerInterceptor) --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor"</span> 
      <span class="hl-attribute">factory-method</span>=<span class="hl-value">"urlPath"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.String"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/m"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/interceptors&gt;</span>
                    </pre>

                    <p>
Java-based configuration is also available:
</p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> DeviceResolverHandlerInterceptor deviceResolverHandlerInterceptor() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DeviceResolverHandlerInterceptor();
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> SiteSwitcherHandlerInterceptor siteSwitcherHandlerInterceptor() {
    <span class="hl-keyword">return</span> SiteSwitcherHandlerInterceptor.urlPath(<span class="hl-string">"/m"</span>);
}

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(deviceResolverHandlerInterceptor());
    registry.addInterceptor(siteSwitcherHandlerInterceptor());
}
                    </pre><p>
</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e248" href="#d5e248"></a>Mobile Path and Root Path</h4></div></div></div>

    <div class="translateArticle">
      <p>
        당신은 또한 <code class="methodname">urlPath</code>에서 어플리케이션의 root path를 명시할 수도 있습니다.  다음의 샘플은 사이트스위처를 생성하여, 모바일 유저를 ${serverName}/${rootPath}/${mobilePath};로 이동하게 해줍니다. 예를 들자면 <code class="literal">myapp.com/showcase/m/</code>가 되는 것입니다.
      </p>

    </div>
    <div class="originalArticle">
      <p>You can also specify the root path of the application in the <code class="methodname">urlPath</code>
factory method. The following sample constructs a SiteSwitcher that redirects mobile users to
${serverName}/${rootPath}/${mobilePath}; for example, <code class="literal">myapp.com/showcase/m/</code>:
</p>

    </div>  

      

<pre class="programlisting">
<span class="hl-tag">&lt;interceptors&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, resolve the device that originated the web request --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.DeviceResolverHandlerInterceptor"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, redirects mobile users to "myapp.com/showcase/m" (declare after DeviceResolverHandlerInterceptor) --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor"</span> 
      <span class="hl-attribute">factory-method</span>=<span class="hl-value">"urlPath"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.String"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/m"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.String"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/showcase"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/interceptors&gt;</span>
                    </pre><p>
Java-based configuration is also available:
</p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> DeviceResolverHandlerInterceptor deviceResolverHandlerInterceptor() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DeviceResolverHandlerInterceptor();
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> SiteSwitcherHandlerInterceptor siteSwitcherHandlerInterceptor() {
    <span class="hl-keyword">return</span> SiteSwitcherHandlerInterceptor.urlPath(<span class="hl-string">"/m"</span>, <span class="hl-string">"/showcase"</span>);
}

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(deviceResolverHandlerInterceptor());
    registry.addInterceptor(siteSwitcherHandlerInterceptor());
}
                    </pre><p>
</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e255" href="#d5e255"></a>Mobile Path, Tablet Path, and Root Path</h4></div></div></div>

    <div class="translateArticle">
      <p> 마지막으로, <code class="methodname">urlPath</code> 팩터리 메소드는 태블릿 사이트를 위한 경로를 설정하는 것을 지원합니다. 다음의 예즈는 사이트 스위처를 생성하여 모바일 유저를 ${serverName}/${rootPath}/${mobilePath}로 이동하게 해주고, 태블릿 사용자는 ${serverName}/${rootPath}/${tabletPath} 로 이동하게 해줍니다..</p>

    </div>
    <div class="originalArticle">
      <p>Lastly, the <code class="methodname">urlPath</code> factory method supports configuring a path for a
tablet site. The following sample constructs a SiteSwitcher that redirects mobile users to
${serverName}/${rootPath}/${mobilePath} for mobile sites, and ${serverName}/${rootPath}/${tabletPath}
for tablet sites.</p>

    </div>  

      

    <div class="translateArticle">
      <p>다음의 설정 예제에서, 모바일 사이트는  <code class="literal">myapp.com/showcase/m/</code>에 위치하게 되며, 태블릿 사이트는 이와 비슷하게 <code class="literal">myapp.com/showcase/t/</code>가 됩니다. </p>

    </div>
    <div class="originalArticle">
      <p>In the following configuration example, the mobile site would be located at <code class="literal">myapp.com/showcase/m/</code>, while the tablet site would be similarly located at <code class="literal">myapp.com/showcase/t/</code>:
</p>

    </div>  

      

<pre class="programlisting">
<span class="hl-tag">&lt;interceptors&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, resolve the device that originated the web request --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.DeviceResolverHandlerInterceptor"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-comment">&lt;!-- On pre-handle, redirects mobile users to "myapp/showcase/m" (declare after DeviceResolverHandlerInterceptor) --&gt;</span>
  <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.switcher.SiteSwitcherHandlerInterceptor"</span> 
      <span class="hl-attribute">factory-method</span>=<span class="hl-value">"urlPath"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"0"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.String"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/m"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.String"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/t"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;constructor-arg</span> <span class="hl-attribute">index</span>=<span class="hl-value">"2"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"java.lang.String"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/showcase"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/interceptors&gt;</span>
                    </pre><p>
Java-based configuration is also available:
</p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> DeviceResolverHandlerInterceptor deviceResolverHandlerInterceptor() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DeviceResolverHandlerInterceptor();
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> SiteSwitcherHandlerInterceptor siteSwitcherHandlerInterceptor() {
    <span class="hl-keyword">return</span> SiteSwitcherHandlerInterceptor.urlPath(<span class="hl-string">"/m"</span>, <span class="hl-string">"/t"</span>, <span class="hl-string">"/showcase"</span>);
}

<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(deviceResolverHandlerInterceptor());
    registry.addInterceptor(siteSwitcherHandlerInterceptor());
}
                    </pre><p>
</p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e264" href="#d5e264"></a>Additional Configuration</h4></div></div></div>

    <div class="translateArticle">
      <p>
        <code class="methodname">urlPath</code> 사이트 스위처가 잘 동작하게 하기 위해서 당신은 모바일과 태블릿 사이트 경로를 위한, 그에 상응하는 url 패턴을 web.xml 에 추가하여야 합니다.         

      </p>

    </div>
    <div class="originalArticle">
      <p>Please note that in order for the <code class="methodname">urlPath</code> SiteSwitcher to work
properly, you will need to add a corresponding url pattern to your web.xml for the mobile and tablet
site paths.</p>

    </div>  

      

<pre class="programlisting">
<span class="hl-tag">&lt;servlet-mapping&gt;</span>
  <span class="hl-tag">&lt;servlet-name&gt;</span>appServlet<span class="hl-tag">&lt;/servlet-name&gt;</span>
  <span class="hl-tag">&lt;url-pattern&gt;</span>/<span class="hl-tag">&lt;/url-pattern&gt;</span>
  <span class="hl-tag">&lt;url-pattern&gt;</span>/m/*<span class="hl-tag">&lt;/url-pattern&gt;</span>
  <span class="hl-tag">&lt;url-pattern&gt;</span>/t/*<span class="hl-tag">&lt;/url-pattern&gt;</span>
<span class="hl-tag">&lt;/servlet-mapping&gt;</span>
                </pre>
</div>
</div>


    <div class="translateArticle">
      <p>  더 많은 조정을 위해서는 <code class="classname">SiteSwitcherHandlerInterceptor</code> 자바문서를 보세요.  실행가능한 사이트 스위처 예제를 위해서는 <a class="ulink" href="https://github.com/spring-projects/spring-mobile-samples" target="_top">
<em class="citetitle">samples</em></a>예제를 보세요. 
    </p>

    </div>
    <div class="originalArticle">
      <p>See the JavaDoc of <code class="classname">SiteSwitcherHandlerInterceptor</code> for additional options when you
need more control. See the spring-mobile <a class="ulink" href="https://github.com/spring-projects/spring-mobile-samples" target="_top">
<em class="citetitle">samples</em></a> repository for runnable SiteSwitcher examples.</p>

    </div>  

      

</div>
<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="device-aware-view-management" href="#device-aware-view-management"></a>2.6&nbsp;Device aware view management</h2></div></div></div>


    <div class="translateArticle">
      <p> 디바이스 감지를 사용하면서, 당신의 컨트롤러들에 조건적인 로직을 넣어서, 디바이스 타입에 맞는 구체적인 뷰들을 리턴하는 것이 가능합니다. 
          그러나 많은 뷰들을 다룰 때, 이러한 작업은 힘든 일이 될 수 있습니다. 다행스럽게도 스프링 모바일은 다른 디바이스 타입에 따른 뷰들을 관리하는 대안메소드를 제공합니다. 
      </p>

    </div>
    <div class="originalArticle">
      <p>Using device detection, it is possible to add conditional logic within your controllers to return
specific views based on device type. But this process can be laborious if you are dealing with a large
number of views. Fortunately, Spring Mobile offers an alternative method for managing views for different
device types.</p>

    </div>  

      

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="device-delegating-view-resolver" href="#device-delegating-view-resolver"></a>2.6.1&nbsp;Device aware view resolving</h3></div></div></div>


    <div class="translateArticle">
      <p> 스프링 모바일은 <code class="classname">AbstractDeviceDelegatingViewResolver</code> 와 다른 뷰 리졸버 구현체를 위임하는 추상화 <code class="classname">ViewResolver</code>  랩퍼 를 포함하여서, 각각의 뷰를 위해 정의된 매핑을 필요로 하는 대신에 디바이스 구체적인 뷰네임의 해석을 허용합니다.  경량화 구현체가 제공되어서 뷰네임이 기본인지, 모바일인지 태블릿 기반인지 조정하는 것을 지원합니다. </p>
 
    </div>
    <div class="originalArticle">
      <p>Spring Mobile includes <code class="classname">AbstractDeviceDelegatingViewResolver</code>, an abstract
<code class="classname">ViewResolver</code> wrapper that delegates to another view resolver implementation,
allowing for resolution of device specific view names without the need for a dedicated mapping to be
defined for each view. A lightweight implementation is provided, which supports adjusting view names
based on whether the calling device is normal, mobile, or tablet based.</p>

    </div>  

      

    <div class="translateArticle">
      <p> 당신의 어플리케이션 내에서, 당신은 기본, 모바일, 태블릿 디바이스를 위한 대안적인 뷰들과 적절하게 주어진 설정을 생성할 수 있습니다. 스프링 모바일은 뷰네임을 조절하여 적절한 뷰네임을 찾을 것입니다. 
        이것은 내부적으로 일어나며 컨트롤러에서 조건적인 로직이 필요가 없습니다. 다음의 테이블은  "home" 뷰에 대한 요청을 받았을 때 <code class="classname">LiteDeviceDelegatingViewResolver</code> 의 행위를 설명하고, 그 요청이 prefix를 사용하도록 조절합니다. 이것은 예를 들자면 당신이 서브디렉터리에 모바일뷰를 저장할 수 있게 해줍니다. </p>
    </div>
    <div class="originalArticle">
      <p>Within your application, you can then create alternate views for normal, mobile or tablet devices,
and given the proper configuration, Spring Mobile will adjust the view name to resolve to the correct one.
This happens internally, without the need to add conditional logic through your controllers. The following
table illustrates the behavior of the <code class="classname">LiteDeviceDelegatingViewResolver</code> when
receiving a request for the "home" view and adjusting it to use a prefix. This allows you to store
"mobile" views in a subdirectory, for example.</p>
    </div>  

      



<div class="table"><a name="d5e283" href="#d5e283"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;Prefixes</b></p><div class="table-contents">
<table summary="Prefixes" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Resolved Device</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Method</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Prefix</th><th style="border-bottom: 0.5pt solid ; ">Adjusted View</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Normal</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">setNormalPrefix()</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">"normal/"</td><td style="border-bottom: 0.5pt solid ; ">"normal/home"</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Mobile</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">setMobilePrefix()</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">"mobile/"</td><td style="border-bottom: 0.5pt solid ; ">"mobile/home"</td></tr><tr><td style="border-right: 0.5pt solid ; ">Tablet</td><td style="border-right: 0.5pt solid ; "><code class="methodname">setTabletPrefix()</code></td><td style="border-right: 0.5pt solid ; ">"tablet/"</td><td style="">"tablet/home"</td></tr></tbody></table>
</div></div><br class="table-break">

    <div class="translateArticle">
      <p>대안적으로,  <code class="classname">LiteDeviceDelegatingViewResolver</code> 또한 접미사와 함께 뷰들을 조정하는 것을 지원합니다. 다음 테이블은 home 뷰에 들어온 요청을 받았을 때에 대한 결과들을 보여줍니다. 예를 들어서 이것은 당신이 모든 뷰들을 같은 폴더에 넣지만, 그것들은 접미사를 사용하여 구별하는 것을 보여줍니다. </p>

    </div>
    <div class="originalArticle">
      <p>Alternatively, the <code class="classname">LiteDeviceDelegatingViewResolver</code> also supports adjusting
views with suffixes. The following table shows the results of receiving a request for the "home" view.
For example, this allows you to store all your views in the same folder, and distinguish between them by
using different suffixes.</p>

    </div>  

      

<div class="table"><a name="d5e313" href="#d5e313"></a><p class="title"><b>Table&nbsp;2.2.&nbsp;Suffixes</b></p><div class="table-contents">
<table summary="Suffixes" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Resolved Device</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Method</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Suffix</th><th style="border-bottom: 0.5pt solid ; ">Adjusted View</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Normal</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">setNormalSuffix()</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">".nor"</td><td style="border-bottom: 0.5pt solid ; ">"home.nor"</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Mobile</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="methodname">setMobileSuffix()</code></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">".mob"</td><td style="border-bottom: 0.5pt solid ; ">"home.mob"</td></tr><tr><td style="border-right: 0.5pt solid ; ">Tablet</td><td style="border-right: 0.5pt solid ; "><code class="methodname">setTabletSuffix()</code></td><td style="border-right: 0.5pt solid ; ">".tab"</td><td style="">"home.tab"</td></tr></tbody></table>
</div></div><br class="table-break">
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e341" href="#d5e341"></a>2.6.2&nbsp;Enabling device aware views</h3></div></div></div>

    <div class="translateArticle">
      <p> 다음의 예제는 <code class="classname">InternalResourceViewResolver</code>를 위임하기 위해 어떻게 사이트를 설정하는 지 보여줍니다. 이것은 요청된 디바이스가 모바일이나 태블릿으로 결정될 때, 추가적인 <code class="literal">mobile/</code> or <code class="literal">tablet/</code> 접두사를 뷰 네임에 추가시킴으로써 뷰 네임을 조정합니다. </p>

    </div>
    <div class="originalArticle">
      <p>The following example illustrates how to configure a site that delegates to an
<code class="classname">InternalResourceViewResolver</code>. It is configurated to adjust the view name by adding
a <code class="literal">mobile/</code> or <code class="literal">tablet/</code> prefix if the requesting device is determined
to be mobile or tablet respectively.</p>

    </div>  

      

<p>XML configuration:
</p><pre class="programlisting">
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.view.LiteDeviceDelegatingViewResolver"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;constructor-arg&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span><span class="hl-tag">&gt;</span>
      <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"prefix"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/WEB-INF/views/"</span><span class="hl-tag"> /&gt;</span>
      <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"suffix"</span> <span class="hl-attribute">value</span>=<span class="hl-value">".jsp"</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
  <span class="hl-tag">&lt;/constructor-arg&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"mobilePrefix"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"mobile/"</span><span class="hl-tag"> /&gt;</span>
  <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"tabletPrefix"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tablet/"</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>
                </pre><p>
</p>
<p>Java-based configuration:
</p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> LiteDeviceDelegatingViewResolver liteDeviceAwareViewResolver() {
    InternalResourceViewResolver delegate = <span class="hl-keyword">new</span> InternalResourceViewResolver();
    delegate.setPrefix(<span class="hl-string">"/WEB-INF/views/"</span>);
    delegate.setSuffix(<span class="hl-string">".jsp"</span>);
    LiteDeviceDelegatingViewResolver resolver = <span class="hl-keyword">new</span> LiteDeviceDelegatingViewResolver(delegate);
    resolver.setMobilePrefix(<span class="hl-string">"mobile/"</span>);
    resolver.setTabletPrefix(<span class="hl-string">"tablet/"</span>);
    <span class="hl-keyword">return</span> resolver;
}
                </pre><p>
</p>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e351" href="#d5e351"></a>2.6.3&nbsp;Fallback resolution</h3></div></div></div>


    <div class="translateArticle">
      <p>
        <code class="interfacename">ViewResolver</code>를 사용하는 것은 뷰네임 전략을 당신의 사이트 전체에 적용하는데, 몇몇 뷰는 다른 디바이스 타입이나 다른 디바이스 버젼이 필요없이 분리된 구현체들이 필요없는 경우가 있는 경우가 있을 것입니다. 이러한 경우 당신은 fallback 지원을 활성화 할 수 있습니다.  fallback 지원을 활성화한다는 것은 조정된 뷰네임이 해석되지 않으면, <code class="interfacename">ViewResolver</code>가 원래 뷰 요청 해석을 시도한다는 것을 의미합니다. 이 특징은 위임한 <code class="interfacename">ViewResolver</code> 가 <code class="methodname">resolveViewName</code>에 대한 요청에서 존재하지 않는 뷰에 대한 해석을 시도하여서, <code class="literal">null</code>을 반환할 때만 지원됩니다. 
      </p>

    </div>
    <div class="originalArticle">
      <p>Because using a <code class="interfacename">ViewResolver</code> will apply the view name strategy to
your entire site, there may be times when some of your views do not have separate implementations for
different device types or you do not need different versions. In this case, you can enable fallback
support. Enabling fallback support means if an adjusted view name cannot be resolved, the
<code class="interfacename">ViewResolver</code> will attempt to resolve the original view request. This
feature is only supported if the delegate <code class="interfacename">ViewResolver</code> returns
<code class="literal">null</code> from a call to <code class="methodname">resolveViewName</code> when attempting to
resolve a view that does not exist.</p>

    </div>  

      



    <div class="translateArticle">
      <p>fallback 지원을 활성화하는 것은 <code class="literal">enableFallback</code> 속성을 설정하여서 가능합니다. </p>
    </div>
    <div class="originalArticle">
      <p>Enable fallback support by setting the <code class="literal">enableFallback</code> property.</p>
    </div>  

      
<p>XML configuration:
</p><pre class="programlisting">
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.mobile.device.view.LiteDeviceDelegatingViewResolver"</span><span class="hl-tag">&gt;</span>
    ...
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"enableFallback"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span><span class="hl-tag"> /&gt;</span>
    ...
<span class="hl-tag">&lt;/bean&gt;</span>
                </pre><p>
</p>
<p>Java-based configuration:
</p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span class="hl-keyword">public</span> LiteDeviceDelegatingViewResolver liteDeviceAwareViewResolver() {
    ...
    resolver.setEnableFallback(true);
    ...
    <span class="hl-keyword">return</span> resolver;
}
                </pre><p>
</p>
</div>
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="overview.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;</td></tr><tr><td width="40%" align="left" valign="top">1.&nbsp;Spring Mobile Overview&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;</td></tr></table></div> 

</body>
</html>