
<!DOCTYPE html>
<html lang="kr">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<meta name="author" content="번역자 아라한사 fb.com/me.adunhansa. 원문 : Oliver Gierke, Thomas Darimont, Christoph Strobl">
<title>Spring Data JPA - 레퍼런스 문서 번역</title>
<link rel="stylesheet" href="./spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<!-- My Custom Configuration -->
<script src="js/jquery-1.11.1.min.js"></script>
<script src="js/translate.js"></script>
<link rel="stylesheet" href="css/mystyle.css">
<!-- //My Custom Configuration -->
<!-- SEO -->
<meta content="summary" name="twitter:card"/>
<meta content="@arahansa" name="twitter:site"/>
<meta name="twitter:title" content="스프링 데이터 JPA 레퍼런스 번역 문서입니다."/>
<meta name="twitter:description" content="어플리케이션의 데이터 접근 레이어를 구현하는 것은 꽤 성가신 일이었습니다. 간단한 쿼리와, 페이징, auditing를 위해 너무 많은 보일러플레이트 코드가 쓰여져야했습니다.  스프링데이터JPA는 실제 필요한 부분에 대해서 많은 양의 노력을 줄이게 함으로써, 데이터 접근 레이어의 향상에 목표를 두고 있습니다. 개발자가 커스텀 찾기 메소드를 포함해 리파지토리 인터페이스를 작성하기만 하면, 스프링은 구현체를 자동적으로 제공할 것입니다. "/>
<meta name="twitter:creator" content="@arahansa"/>
<meta name="twitter:image:src" content="images/jpa.jpg"/>

<meta property="og:title" content="스프링 데이터 JPA 레퍼런스 번역 문서입니다."/>
<meta property="og:image" content="images/jpa.jpg"/>
<meta property="og:description" content="어플리케이션의 데이터 접근 레이어를 구현하는 것은 꽤 성가신 일이었습니다. 간단한 쿼리와, 페이징, auditing를 위해 너무 많은 보일러플레이트 코드가 쓰여져야했습니다.  스프링데이터JPA는 실제 필요한 부분에 대해서 많은 양의 노력을 줄이게 함으로써, 데이터 접근 레이어의 향상에 목표를 두고 있습니다. 개발자가 커스텀 찾기 메소드를 포함해 리파지토리 인터페이스를 작성하기만 하면, 스프링은 구현체를 자동적으로 제공할 것입니다.  "/>

<meta content="article" property="og:type"/>
<!-- //SEO -->
</head>
<body class="book">
<div id="header">
<h1>스프링 데이터 JPA 레퍼런스 번역</h1>
<div class="details">
<span id="author" class="author">Oliver Gierke</span><br>
<span id="author2" class="author">Thomas Darimont</span><br>
<span id="author3" class="author">Christoph Strobl</span><br>
<span id="revnumber">version 1.8.1.RELEASE,</span>
<span id="revdate">    <div class="translateArticle">
      2015-06-30. 번역일 7월 24일 경 해당 문구 위로 마우스를 올리시면 - 번역 버튼이 나옵니다. 문맥에 안 맞는 번역이 나올 시에는 버튼을 클릭하셔서 원문을 확인해주시면 되겠습니다^^; (역자 아라한사 올림. 수정요구사항 fb.com/me.adunhansa). 제 블로그 말고 깃헙에다가 올려두겠습니다. 한 타임 기모아서 마음먹고 쭈욱 번역하면서, 정독을 하는 번역이 아닌지라..^^; 오역이 있을 수 있습니다. 안 좋은 번역이 있다면 풀리퀘 주시면 감사하겠습니다 :)
    </div>
    <div class="originalArticle">
      2015-06-30. 
    </div>  

      </span>
<span> <br>

      아참 이번에 김영한님이 집필하신 JPA 책이 나옵니다. spring data jpa 도 JPA 기반의 기술이니 꼭 보시면 많은 도움이 되실 것 입니다~~ (그림 클릭) <br><br>

      <a href="http://bit.ly/holyeye_jpabook" target="_blank"><img src="images/book_jpa.jpg"></a></span>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>&#169; 2008-2015 The original authors.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
    <div class="translateArticle">
      이 문서의 복사본은 당신 자신을 위해서나, 다른 사람들에게 배포를 위해 만들어질 수 있습니다. 복사에 대해 어떤 비용을 청구하지 않아야 하며, 프린트되거나 전자적으로 배포될 때에도 Copyright 문구를 포함해야 합니다.
    </div>
    <div class="originalArticle">
      Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.
    </div>  

      
</td>
</tr>
</table>
</div>
<div id="toc" class="toc">
<div id="toctitle" class="title">목차</div>
<ul class="sectlevel0">
<li><a href="#preface">서문 </a>
<ul class="sectlevel1">
<li><a href="#project">1. 프로젝트 메타데이터 </a></li>
<li><a href="#dependencies">2. 의존성들 </a>
<ul class="sectlevel2">
<li><a href="#dependencies.spring-boot">2.1. 스프링부트와 함께 의존성 관리</a></li>
<li><a href="#dependencies.spring-framework">2.2. 스프링 프레임워크 </a></li>
</ul>
</li>
<li><a href="#repositories">3. 스프링 데이터 리파지토리들과 함꼐 작업하기 </a>
<ul class="sectlevel2">
<li><a href="#repositories.core-concepts">3.1. 핵심 개념</a></li>
<li><a href="#repositories.query-methods">3.2. 쿼리 메소드들</a></li>
<li><a href="#repositories.definition">3.3. 리파지토리 인터페이스들 정의하기</a>
<ul class="sectlevel3">
<li><a href="#repositories.definition-tuning">3.3.1. 리파지토리 정의 세밀조정하기</a></li>
</ul>
</li>
<li><a href="#repositories.query-methods.details">3.4. 쿼리 메소드 정의하기</a>
<ul class="sectlevel3">
<li><a href="#repositories.query-methods.query-lookup-strategies">3.4.1. 쿼리 검색(lookup) 전략</a></li>
<li><a href="#repositories.query-methods.query-creation">3.4.2. 쿼리생성</a></li>
<li><a href="#repositories.query-methods.query-property-expressions">3.4.3. 프로퍼티 표현</a></li>
<li><a href="#repositories.special-parameters">3.4.4. 특별한 파라미터 핸들링</a></li>
<li><a href="#repositories.limit-query-result">3.4.5. 쿼리 결과 limit하기</a></li>
<li><a href="#repositories.query-streaming">3.4.6. 쿼리 결과 스트리밍 하기</a></li>
</ul>
</li>
<li><a href="#repositories.create-instances">3.5. 레파지토리 인스턴스 생성</a>
<ul class="sectlevel3">
<li><a href="#repositories.create-instances.spring">3.5.1. XML설정</a></li>
<li><a href="#repositories.create-instances.java-config">3.5.2. 자바설정</a></li>
<li><a href="#repositories.create-instances.standalone">3.5.3. 독립적사용(Standalone usage)</a></li>
</ul>
</li>
<li><a href="#repositories.custom-implementations">3.6. 스프링 데이터 레파지토리를 위한 커스텀 구현</a>
<ul class="sectlevel3">
<li><a href="#repositories.single-repository-behaviour">3.6.1. 단일 레파지토리에 대해 커스텀 행동 추가 </a></li>
<li><a href="#repositories.custom-behaviour-for-all-repositories">3.6.2. 모든 레파지토리에 대해 커스텀 행동 추가</a></li>
</ul>
</li>
<li><a href="#core.extensions">3.7. 스프링데이터 확장</a>
<ul class="sectlevel3">
<li><a href="#core.web">3.7.1. 웹 서포트</a></li>
<li><a href="#core.repository-populators">3.7.2. 레파지토리 populators</a></li>
<li><a href="#web.legacy">3.7.3. 레거시 웹 서포트</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">레페런스 문서 </a>
<ul class="sectlevel1">
<li><a href="#jpa.repositories">4. JPA 리파지토리들</a>
<ul class="sectlevel2">
<li><a href="#jpa.introduction">4.1. 소개</a>
<ul class="sectlevel3">
<li><a href="#jpa.namespace">4.1.1. Spring 네임스페이스</a></li>
<li><a href="#jpa.java-config">4.1.2. 어노테이션 기반 설정 </a></li>
</ul>
</li>
<li><a href="#jpa.entity-persistence">4.2. Persisting 엔티티들</a>
<ul class="sectlevel3">
<li><a href="#jpa.entity-persistence.saving-entites">4.2.1. 엔티티들 저장</a></li>
</ul>
</li>
<li><a href="#jpa.query-methods">4.3. 쿼리 메소드들</a>
<ul class="sectlevel3">
<li><a href="#jpa.sample-app.finders.strategies">4.3.1. 쿼리 룩업 전략</a></li>
<li><a href="#jpa.query-methods.query-creation">4.3.2. 쿼리 생성</a></li>
<li><a href="#jpa.query-methods.named-queries">4.3.3. JPA NamedQuery 사용하기 </a></li>
<li><a href="#jpa.query-methods.at-query">4.3.4. @Query 사용 </a></li>
<li><a href="#jpa.named-parameters">4.3.5. 이름지어진 파라미터 사용 </a></li>
<li><a href="#jpa.query.spel-expressions">4.3.6. Spel 표현 사용 </a></li>
<li><a href="#jpa.modifying-queries">4.3.7. 쿼리 수정하기 </a></li>
<li><a href="#jpa.query-hints">4.3.8. 쿼리 힌트 적용</a></li>
<li><a href="#jpa.entity-graph">4.3.9. Fetch-와 LoadGraphs 설정 </a></li>
</ul>
</li>
<li><a href="#jpa.stored-procedures">4.4. 스토어 프로시져 </a></li>
<li><a href="#specifications">4.5. Specifications(이건 원문 그대로 ) </a></li>
<li><a href="#transactions">4.6. Transactionality (트랜잭션) </a>
<ul class="sectlevel3">
<li><a href="#transactional-query-methods">4.6.1. 트랜잭션 쿼리 메소드 </a></li>
</ul>
</li>
<li><a href="#locking">4.7. 락킹</a></li>
<li><a href="#auditing">4.8. Auditing (이것도 원문 그대로 ) </a>
<ul class="sectlevel3">
<li><a href="#auditing.basics">4.8.1. 기본들</a></li>
</ul>
</li>
<li><a href="#jpa.auditing">4.9. JPA Auditing</a>
<ul class="sectlevel3">
<li><a href="#jpa.auditing.configuration">4.9.1. 일반적 auditing 설정</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jpa.misc">5. 오해들 </a>
<ul class="sectlevel2">
<li><a href="#jpa.misc.merging-persistence-units">5.1. 병합된(Merging) 영속 유닛들 </a>
<ul class="sectlevel3">
<li><a href="#jpa.misc.entity-scanning">5.1.1. JPA 매핑파일과 @Entity클래스들을 스캐닝하는 클래스패스</a></li>
</ul>
</li>
<li><a href="#jpd.misc.cdi-integration">5.2. CDI 통합</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendix">부록</a>
<ul class="sectlevel1">
<li><a href="#repositories.namespace-reference">부록 A: 네임 스페이스 레퍼런스</a>
<ul class="sectlevel2">
<li><a href="#populator.namespace-dao-config">The &lt;repositories /&gt; 요소</a></li>
</ul>
</li>
<li><a href="#populator.namespace-reference">부록 B: Populators 네임스페이스 레퍼런스</a>
<ul class="sectlevel2">
<li><a href="#namespace-dao-config">The &lt;populator /&gt; 요소</a></li>
</ul>
</li>
<li><a href="#repository-query-keywords">부록 C: 리파지토리 쿼리 메소드들</a>
<ul class="sectlevel2">
<li><a href="#_supported_query_keywords">지원되는 쿼리 메소드들</a></li>
</ul>
</li>
<li><a href="#repository-query-return-types">부록 D: 리파지토리 쿼리 리턴 타입</a>
<ul class="sectlevel2">
<li><a href="#_supported_query_return_types">지원되는 쿼리 리턴 타입</a></li>
</ul>
</li>
<li><a href="#faq">부록 E: 자주묻는 질문 </a>
<ul class="sectlevel2">
<li><a href="#_common">흔한</a></li>
<li><a href="#_infrastructure">인프라스트럭쳐</a></li>
<li><a href="#_auditing">Auditing</a></li>
</ul>
</li>
<li><a href="#glossary">부록 F: 용어집</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<h1 id="preface" class="sect0"><a class="anchor" href="#preface"></a>서문</h1>
<div class="sect1">
<h2 id="project"><a class="anchor" href="#project"></a>1.프로젝트 메타데이터</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Version control - <a href="http://github.com/spring-projects/spring-data-jpa" class="bare">http://github.com/spring-projects/spring-data-jpa</a></p>
</li>
<li>
<p>Bugtracker - <a href="https://jira.spring.io/browse/DATAJPA" class="bare">https://jira.spring.io/browse/DATAJPA</a></p>
</li>
<li>
<p>Release repository - <a href="https://repo.spring.io/libs-release" class="bare">https://repo.spring.io/libs-release</a></p>
</li>
<li>
<p>Milestone repository - <a href="https://repo.spring.io/libs-milestone" class="bare">https://repo.spring.io/libs-milestone</a></p>
</li>
<li>
<p>Snapshot repository - <a href="https://repo.spring.io/libs-snapshot" class="bare">https://repo.spring.io/libs-snapshot</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dependencies"><a class="anchor" href="#dependencies"></a>2. 의존성들</h2>
<div class="sectionbody">
<div class="paragraph">
    <div class="translateArticle">
      <p>스프링 데이터 모듈들의 각자 다른 시작으로 인하여, 모듈들의 대부분은 각자 다른 메이저, 마이너 버젼 넘버를 가지고 있습니다. 가장 쉬운 호환성이 맞는 것을 찾는 방법은 Spring Data Release Train BOM에서 저희가 정의한 호환성 버젼을 찾는 것입니다. 메이븐 프로젝트에서 당신은 이 의존성 <code>&lt;dependencyManagement /&gt;</code>섹션을 당신의 폼 부분에 선언할 수 있습니다. </p>
    </div>
    <div class="originalArticle">
      <p>Due to different inception dates of individual Spring Data modules, most of them carry different major and minor version numbers. The easiest way to find compatible ones is by relying on the Spring Data Release Train BOM we ship with the compatible versions defined. In a Maven project you&#8217;d declare this dependency in the <code>&lt;dependencyManagement /&gt;</code> section of your POM:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">예제 1. Spring Data release train BOM 사용하기</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
      &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt;
      &lt;version&gt;${release-train}&lt;/version&gt;
      &lt;scope&gt;import&lt;/scope&gt;
      &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>현재 릴리즈 트레인 버젼은 Fowler-BUILD-SNAPSHOT입니다. 트레인 이름은 알파벳 오름차순이며 현재 가능한 버젼은 <a href="https://github.com/spring-projects/spring-data-commons/wiki/Release-planning">여기</a>에 나와있습니다. 버젼이름은 다음 패턴을 따르고-<code>${name}-${release}</code> 릴리즈는 다음의 하나를 따르게 됩니다:</p>
    </div>
    <div class="originalArticle">
      <p>The current release train version is Fowler-BUILD-SNAPSHOT. The train names are ascending alphabetically and currently available ones are listed <a href="https://github.com/spring-projects/spring-data-commons/wiki/Release-planning">here</a>. The version name follows the following pattern: <code>${name}-${release}</code> where release can be one of the following:</p>
    </div>  

      
</div>
<div class="ulist">
<ul>
<li>
    <div class="translateArticle">
      <p><code>BUILD-SNAPSHOT</code> - 현재 스냅샷 </p>
    </div>
    <div class="originalArticle">
      <p><code>BUILD-SNAPSHOT</code> - current snapshots</p>
    </div>  

      
</li>
<li>
    <div class="translateArticle">
      <p><code>M1</code>, <code>M2</code> etc. - 마일스톤 </p>
    </div>
    <div class="originalArticle">
      <p><code>M1</code>, <code>M2</code> etc. - milestones</p>
    </div>  

      
</li>
<li>
    <div class="translateArticle">
      <p><code>RC1</code>, <code>RC2</code> etc. - 릴리즈 후보</p>
    </div>
    <div class="originalArticle">
      <p><code>RC1</code>, <code>RC2</code> etc. - release candidates</p>
    </div>  

      
</li>
<li>
    <div class="translateArticle">
      <p><code>RELEASE</code> - GA 릴리즈</p>
    </div>
    <div class="originalArticle">
      <p><code>RELEASE</code> - GA release</p>
    </div>  

      
</li>
<li>
    <div class="translateArticle">
      <p><code>SR1</code>, <code>SR2</code> etc. - 서비스 릴리즈 </p>
    </div>
    <div class="originalArticle">
      <p><code>SR1</code>, <code>SR2</code> etc. - service releases</p>
    </div>  

      
</li>
</ul>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p><a href="https://github.com/spring-projects/spring-data-examples/tree/master/bom">Spring Data examples repository</a>에서 BOM을 사용하는 작업 예제를 발견할 수가 있습니다. .</p>
    </div>
    <div class="originalArticle">
      <p>A working example of using the BOMs can be found in our <a href="https://github.com/spring-projects/spring-data-examples/tree/master/bom">Spring Data examples repository</a>.</p>
    </div>  

      
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> 저 자리의  <code>&lt;dependencies /&gt;</code>블록에 버젼을 사용하지 않고 스프링 데이터 모듈을 선언했습니다. (번역하면서 애매했던 부분임. )    </p>
    </div>
    <div class="originalArticle">
      <p>If that&#8217;s in place declare the Spring Data modules you&#8217;d like to use without a version in the <code>&lt;dependencies /&gt;</code> block.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 2. 스프링 데이터 모듈 의존성 선언
    </div>
    <div class="originalArticle">
      Example 2. Declaring a dependency to a Spring Data module
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
    &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;
  &lt;/dependency&gt;
&lt;dependencies&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dependencies.spring-boot"><a class="anchor" href="#dependencies.spring-boot"></a>    <div class="translateArticle">
      2.1. 스프링 부트에서의 의존성 관리
    </div>
    <div class="originalArticle">
      2.1. Dependency management with Spring Boot
    </div>  

      </h3>
<div class="paragraph">
    <div class="translateArticle">
      <p>스프링 부트는 이미 매우 최근의 스프링 데이터 모듈을 선택했습니다. 그럼에도 불구하고 새로운 버젼을 사용하고 싶은 경우를 위하여 간단히  <code>spring-data-releasetrain.version</code> 프로퍼티를, trainname 과 당신이 사용하고자 하는 iteration에 설정해주세요. </p>
    </div>
    <div class="originalArticle">
      <p>Spring Boot already selects a very recent version of Spring Data modules for you. In case you want to upgrade to a newer version nonetheless, simply configure the property <code>spring-data-releasetrain.version</code> to the train name and iteration you&#8217;d like to use.</p>
    </div>  

      
</div>
</div>
<div class="sect2">
<h3 id="dependencies.spring-framework"><a class="anchor" href="#dependencies.spring-framework"></a>    <div class="translateArticle">
      2.2. 스프링 프레임 워크 
    </div>
    <div class="originalArticle">
      2.2. Spring Framework
    </div>  

      </h3>
<div class="paragraph">
    <div class="translateArticle">
      <p>현재 스프링 데이터 모듈의 버젼은 스프링 프레임워크 4.0.9 릴리즈 이상을 필요로 합니다. 저 마이너 버젼보다 좀 더 오래된 버그픽스 버젼과 함께 작업될 수 있을 것이지만, 최근의 버젼을 사용하는 것을 강력히 추천드립니다. </p>
    </div>
    <div class="originalArticle">
      <p>The current version of Spring Data modules require Spring Framework in version 4.0.9.RELEASE or better. The modules might also work with an older bugfix version of that minor version. However, using the most recent version within that generation is highly recommended.</p>
    </div>  

      
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="repositories"><a class="anchor" href="#repositories"></a>    <div class="translateArticle">
      3. 스프링 데이터 리파지토리들과 작업하기
    </div>
    <div class="originalArticle">
      3. Working with Spring Data Repositories
    </div>  

      </h2>
<div class="sectionbody">
<div class="paragraph">
    <div class="translateArticle">
      <p>스프링 데이터 레파지토리 추상화의 목표는,  다양한 영속화 저장소를 위한 데이터 액세스 레이어를 구현하는 데 있어 필요한, 상당한양의 보일러 플레이한 코드들을 줄이는 데 있습니다 </p>
    </div>
    <div class="originalArticle">
      <p>The goal of Spring Data repository abstraction is to significantly reduce the amount of boilerplate code required to implement data access layers for various persistence stores.</p>
    </div>  

      
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
 <div class="translateArticle">
      <p><em>스프링 데이터 리파지토리 문서와 당신의 모듈</em></p>

    </div>
    <div class="originalArticle">
      <p><em>Spring Data repository documentation and your module</em></p>

    </div>  
</div>
<div class="paragraph">
<div class="translateArticle">
      <p> 이 챕터는 스프링 데이터 리파지토리들의 인터페이스와 핵심개념을 설명합니다. 이 챕터의 정보는 스프링데이터 공통모듈에서 나왔으며,  JPA모듈을 위한 설정과 코드 샘플을 사용해봅니다. 

        XML 네임스페이스 선언과 당신이 사용할 특별한 모듈들같은 확장되는 타입들에 적응해봅시다. (의역)
        <a href="#repositories.namespace-reference">Namespace reference</a> 는 repository API를 지원하는 모든 스프링데이터모듈쪽에서 XML 설정을 다루며,  <a href="#repository-query-keywords">Repository query keywords</a>는 일반적으로 레파지토리추상화에 의해 지원되는 쿼리 메소드 키워드들을 다룹니다. 당신 모듈의 특별한 특징에 관한 정보를 찾는다면, 이 문서에서 그 모듈에 대한 챕터를 살펴보세요. 

       </p>
    </div>
    <div class="originalArticle">
      <p>This chapter explains the core concepts and interfaces of Spring Data repositories. The information in this chapter is pulled from the Spring Data Commons module. It uses the configuration and code samples for the Java Persistence API (JPA) module. Adapt the XML namespace declaration and the types to be extended to the equivalents of the particular module that you are using. <a href="#repositories.namespace-reference">Namespace reference</a> covers XML configuration which is supported across all Spring Data modules supporting the repository API, <a href="#repository-query-keywords">Repository query keywords</a> covers the query method keywords supported by the repository abstraction in general. For detailed information on the specific features of your module, consult the chapter on that module of this document.</p>
    </div>  
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="repositories.core-concepts"><a class="anchor" href="#repositories.core-concepts"></a>    <div class="translateArticle">
      3.1. 핵심 개념
    </div>
    <div class="originalArticle">
      3.1. Core concepts
    </div>  

      </h3>
<div class="paragraph">
 <div class="translateArticle">
      <p> 스프링 데이터 리파지토리 추상화에서 중심적인 인터페이스는 <code>Repository</code>(아마 놀라시않으실테지만)입니다.이것은 도메인클래스와 도메인의 id 타입을 타입아규먼트로 받습니다. 이 인터페이스는 주로 마커 인터페이스로 동작하며, 작업할 타입을 가지고 있으면서, 당신이 이것을 확장할 인터페이스를 발견하게 해줍니다. <code>CrudRepository</code> 는 관리되는 엔티티클래스에서 복잡한 CRUD기능을 제공해줍니다. 
      </p>
    </div>
    <div class="originalArticle">
      <p>The central interface in Spring Data repository abstraction is <code>Repository</code> (probably not that much of a surprise). It takes the domain class to manage as well as the id type of the domain class as type arguments. This interface acts primarily as a marker interface to capture the types to work with and to help you to discover interfaces that extend this one. The <code>CrudRepository</code> provides sophisticated CRUD functionality for the entity class that is being managed.</p>
    </div>  
</div>
<div id="repositories.repository" class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 3. CrudRepository interface 
    </div>
    <div class="originalArticle">
      Example 3. CrudRepository interface
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface CrudRepository&lt;T, ID extends Serializable&gt;
    extends Repository&lt;T, ID&gt; {

    &lt;S extends T&gt; S save(S entity); <i class="conum" data-value="1"></i><b>(1)</b>

    T findOne(ID primaryKey);       <i class="conum" data-value="2"></i><b>(2)</b>

    Iterable&lt;T&gt; findAll();          <i class="conum" data-value="3"></i><b>(3)</b>

    Long count();                   <i class="conum" data-value="4"></i><b>(4)</b>

    void delete(T entity);          <i class="conum" data-value="5"></i><b>(5)</b>

    boolean exists(ID primaryKey);  <i class="conum" data-value="6"></i><b>(6)</b>

    // … more functionality omitted.
}</code></pre>
</div>
</div>
<div class="colist arabic">
    <div class="translateArticle">
      <table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>주어진 엔티티를 저장합니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>주어진 아이디로 식별된 엔티티를 반환합니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>모든 엔티티를 반환합니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>엔티티의 숫자를 반환합니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>주어진 엔티티를 삭제합니다.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>주어진 아이디로 엔티티가 존재하는지를 반환합니다.</td>
</tr>
</table>
    </div>
    <div class="originalArticle">
      <table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Saves the given entity.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Returns the entity identified by the given id.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Returns all entities.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Returns the number of entities.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Deletes the given entity.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Indicates whether an entity with the given id exists.</td>
</tr>
</table>
    </div>  

      
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="translateArticle">

      우리는 또한 <code>JpaRepository</code> 나 <code>MongoRepository</code>같은 기술특징적인 추상화를 제공합니다. 이러한 인터페이스는 <code>CrudRepository</code> 를 확장하여 일반적인 기능에 좀 더 해당기술에 해당하는 기술을 사용할 수 있게 해줍니다(의역. 중요한 부분이 아니니 시간소비없이..=3=3)

    </div>
    <div class="originalArticle">
      We also provide persistence technology-specific abstractions like e.g. <code>JpaRepository</code> or <code>MongoRepository</code>. Those interfaces extend <code>CrudRepository</code> and expose the capabilities of the underlying persistence technology in addition to the rather generic persistence technology-agnostic interfaces like e.g. CrudRepository.
    </div>  
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p><code>CrudRepository</code>를 확장한 것 중에 <code>PagingAndSortingRepository</code> 는 
      쉽게 엔티티들에 대해 페이징을 할수있는 메소드를 제공합니다. </p>
    </div>
    <div class="originalArticle">
      <p>On top of the <code>CrudRepository</code> there is a <code>PagingAndSortingRepository</code> abstraction that adds additional methods to ease paginated access to entities:</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 4. PagingAndSortingRepository
    </div>
    <div class="originalArticle">
      Example 4. PagingAndSortingRepository
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt;
  extends CrudRepository&lt;T, ID&gt; {

  Iterable&lt;T&gt; findAll(Sort sort);

  Page&lt;T&gt; findAll(Pageable pageable);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
        <p><code>User</code>의 페이지사이즈를 20으로 잡고 두번째 페이지에 접근하는 것은간단하게 이렇게 해볼수 있습니다.:</p>
      </div>
      <div class="originalArticle">
        <p>Accessing the second page of <code>User</code> by a page size of 20 you could simply do something like this:</p>
      </div> 
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a bean
Page&lt;User&gt; users = repository.findAll(new PageRequest(1, 20));</code></pre>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>쿼리메소드들을 더 말해보자면, 쿼리 카운트나 삭제 만들기가 가능합니다. </p>
    </div>
    <div class="originalArticle">
      <p>In addition to query methods, query derivation for both count and delete queries, is available.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 5. 카운트 쿼리
    </div>
    <div class="originalArticle">
      Example 5. Derived Count Query
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface UserRepository extends CrudRepository&lt;User, Long&gt; {

  Long countByLastname(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 6. 삭제 쿼리 
    </div>
    <div class="originalArticle">
      Example 6. Derived Delete Query
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface UserRepository extends CrudRepository&lt;User, Long&gt; {

  Long deleteByLastname(String lastname);

  List&lt;User&gt; removeByLastname(String lastname);

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.query-methods"><a class="anchor" href="#repositories.query-methods"></a>    <div class="translateArticle">
      3.2. Query 메소드들
    </div>
    <div class="originalArticle">
      3.2. Query methods
    </div>  

      </h3>
<div class="paragraph">
    <div class="translateArticle">
      <p>표준 CRUD기능들을 가진 리파지토들은 데이터소스에 대한 쿼리들을 가지고 있습니다. 스프링데이터와 함께 이러한 쿼리들을 4단계로 만들어봅시다. </p>
    </div>
    <div class="originalArticle">
      <p>Standard CRUD functionality repositories usually have queries on the underlying datastore. With Spring Data, declaring those queries becomes a four-step process:</p>
    </div>  

      
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<div class="translateArticle">

      <p>Repository나 그 하위 인터페이스를 상속하는 인터페이스를 상속하여, 도메인클래스와 ID 타입을 적어줍시다. </p>
    </div>
    <div class="originalArticle">
      <p>Declare an interface extending Repository or one of its subinterfaces and type it to the domain class and ID type that it will handle.</p>
    </div>  
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;User, Long&gt; { … }</code></pre>
</div>
</div>
</li>
<li>
<div class="translateArticle">
      그 인터페이스에 대해서 쿼리메소드를 선언합니다. 
    </div>
    <div class="originalArticle">
      Declare query methods on the interface.
    </div>  
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;User, Long&gt; {
  List&lt;Person&gt; findByLastname(String lastname);
}</code></pre>
</div>
</div>
</li>
<li>
<div class="translateArticle">
      <p>스프링을 설정하여 이러한 인터페이스들을 위한 프록시 인스턴스를 생성하게 해줍니다. 

        Set up Spring to create proxy instances for those interfaces. Either via <a href="#repositories.create-instances.java-config">자바 설정 </a>:</p>이나, XML을 통해 가능합니다. 
    </div>
    <div class="originalArticle">
      <p>Set up Spring to create proxy instances for those interfaces. Either via <a href="#repositories.create-instances.java-config">JavaConfig</a>:</p>
    </div>  

<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@EnableJpaRepositories
class Config {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or via <a href="#repositories.create-instances">XML configuration</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:jpa="http://www.springframework.org/schema/data/jpa"
   xsi:schemaLocation="http://www.springframework.org/schema/beans
     http://www.springframework.org/schema/beans/spring-beans.xsd
     http://www.springframework.org/schema/data/jpa
     http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

   &lt;jpa:repositories base-package="com.acme.repositories"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p> JPA 네임스페이스는 이 예제에서 사용되었습니다. 만약 당신이 다른 데이터 저장소를 위한 추상화 리파지토리를 사용한다면, 이것을 위해 적적한 네임스페이스 선언으로 바꿔줘야할 것입니다. 예를 들자면 몽고디비나 JPA같이 말이죠 (생략의역)
    </div>
    <div class="originalArticle">
      <p>The JPA namespace is used in this example. If you are using the repository abstraction for any other store, you need to change this to the appropriate namespace declaration of your store module which should be exchanging <code>jpa</code> in favor of, for example, <code>mongodb</code>.</p>
    </div>  
</div>
</li>
</ol>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p> 또한, 자바설정 방법은 기본적으로 사용되는 어노테이션된 클래스를 깔끔하게 설정을 해주지않으므로 패키지를 스캔하기 위하여 다음과 같은 설정을 적어주게 됩니다. <code>basePackage…</code>, <code>@Enable…</code>-어노테이션.</p>
    </div>
    <div class="originalArticle">
      <p>Also, note that the JavaConfig variant doesn&#8217;t configure a package explictly as the package of the annotated class is used by default. To customize the package to scan use one of the <code>basePackage…</code> attribute of the data-store specific repository <code>@Enable…</code>-annotation.</p>
    </div>  
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
    <div class="translateArticle">
      <p>리파지토리 인스턴스를 주입시키고 사용하세요</p>
    </div>
    <div class="originalArticle">
      <p>Get the repository instance injected and use it.</p>
    </div>  

      
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class SomeClient {

  @Autowired
  private PersonRepository repository;

  public void doSomething() {
    List&lt;Person&gt; persons = repository.findByLastname("Matthews");
  }
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
 <div class="translateArticle">
      다음의 섹션이 각각의 단계를 세부적으로 설명할 것입니다. 
    </div>
    <div class="originalArticle">
      The sections that follow explain each step in detail.
    </div>  

</div>
</div>
<div class="sect2">
<h3 id="repositories.definition"><a class="anchor" href="#repositories.definition"></a><div class="translateArticle">
      3.3. 리파지토리 인터페이스 정의하기
    </div>
    <div class="originalArticle">
      3.3. Defining repository interfaces
    </div>  </h3>
<div class="paragraph">
<div class="translateArticle">
      <p>첫번째 단계로, 당신은 도메인특정 리파지토리 인터페이스를 정의해야 합니다. 이 인터페이스는 반드시 Repository 를 상속해야 하며, 도메인 클래스와 아이디 타입을 적어줘야 합니다. 만약 당신이 CRUD메소드를 사용하기 원한다면, <code>Repository</code>대신에 <code>CrudRepository</code> 를 사용해줍니다. </p>    
    </div>
    <div class="originalArticle">
      <p>As a first step you define a domain class-specific repository interface. The interface must extend Repository and be typed to the domain class and an ID type. If you want to expose CRUD methods for that domain type, extend <code>CrudRepository</code> instead of <code>Repository</code>.</p>
    </div>  
</div>
<div class="sect3">
<h4 id="repositories.definition-tuning"><a class="anchor" href="#repositories.definition-tuning"></a> <div class="translateArticle">
      3.3.1. 좀 더 세밀한 리파지토리 정의 조정
    </div>
    <div class="originalArticle">
      3.3.1. Fine-tuning repository definition
    </div>  

      </h4>
<div class="paragraph">
    <div class="translateArticle">
      <p> 일반적으로, 당신의 리파지토리 인터페이스는 <code>Repository</code>, <code>CrudRepository</code> or <code>PagingAndSortingRepository</code>같은 것을 상속할 것입니다. 또 다르게는, 만약 당신이 스프링 데이터 인터페이스를 상속하기를 원하지 않는다면 당신은 당신의 리파지토리에 <code>@RepositoryDefinition</code>를 붙일 수 있습니다(역주: 예제에서의 @NoRepositoryBean를 말하는 것인듯하다.). <code>CrudRepository</code>를 상속하는 것은 당신의 엔티티를 다루는 메소드들의 집합을 노출시킵니다. 만약 당신이 노출되는 메소드들에 관해서 선택적으로 하고 싶다면, 단순히 <code>CrudRepository</code>에서 당신이 노출시키는 부분을 복사하여 당신의 도메인 리파지토리에 붙여보셔요(^^)

       
    </div>
    <div class="originalArticle">
      <p>Typically, your repository interface will extend <code>Repository</code>, <code>CrudRepository</code> or <code>PagingAndSortingRepository</code>. Alternatively, if you do not want to extend Spring Data interfaces, you can also annotate your repository interface with <code>@RepositoryDefinition</code>. Extending <code>CrudRepository</code> exposes a complete set of methods to manipulate your entities. If you prefer to be selective about the methods being exposed, simply copy the ones you want to expose from <code>CrudRepository</code> into your domain repository.</p>
    </div>  

      
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
 <div class="translateArticle">
        
이것은 제공된 스프링데이터 리파지토리에서, 당신 자신의 추상화를 정의할 수 있게 합니다. 

      </div>
      <div class="originalArticle">
        
This allows you to define your own abstractions on top of the provided Spring Data Repositories functionality.

      </div>  
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 7. 선택적으로 CRUD 메소드 노출시키기
    </div>
    <div class="originalArticle">
      Example 7. Selectively exposing CRUD methods
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@NoRepositoryBean
interface MyBaseRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; {

  T findOne(ID id);

  T save(T entity);
}

interface UserRepository extends MyBaseRepository&lt;User, Long&gt; {
  User findByEmailAddress(EmailAddress emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p> 이 첫번째 단계에서 당신은 모든 도메인 리파지토리들을 위한 기본 작업 인터페이스를 정의하였고, <code>findOne(…)</code>과  <code>save(…)</code>를 노출시켰습니다. 이러한 메소드들은 리파지토리 구현 구현체에 위치하게 될 것입니다.  당신이 스프링데이터에서 선택한 저장소. 예를 들자면 JPA이면 <code>SimpleJpaRepository</code>같은 것에 위치할 것입니다. 왜냐하면 이것들(역주:구현체?)은 <code>CrudRepository</code>의 메소드 시그니처를 매칭시키기 때문입니다. 그러므로 <code>UserRepository</code>는 사용자들을 저장하고 id로 단일유저를 찾을 수 있고, 뿐만 아니라 그들의 이메일 주소로 <code>Users</code>들을 찾는 쿼리를 동작시킬 것입니다. 

       </p>
    </div>
    <div class="originalArticle">
      <p>In this first step you defined a common base interface for all your domain repositories and exposed <code>findOne(…)</code> as well as <code>save(…)</code>.These methods will be routed into the base repository implementation of the store of your choice provided by Spring Data ,e.g. in the case if JPA <code>SimpleJpaRepository</code>, because they are matching the method signatures in <code>CrudRepository</code>. So the <code>UserRepository</code> will now be able to save users, and find single ones by id, as well as triggering a query to find <code>Users</code> by their email address.</p>
    </div>  
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="translateArticle">
      <code>@NoRepositoryBean</code> 중간 레파지토리 인터페이스를 한번 보세요. 당신이 저 어노테이션을 붙인 모든 리파지토리는 런타임에서 인스턴스를 생성하지 않습니다. 
    </div>
    <div class="originalArticle">
      Note, that the intermediate repository interface is annotated with <code>@NoRepositoryBean</code>. Make sure you add that annotation to all repository interfaces that Spring Data should not create instances for at runtime.
    </div>  
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.query-methods.details"><a class="anchor" href="#repositories.query-methods.details"></a>3.4.  쿼리 메소드 정의하기</h3>
<div class="paragraph">
<div class="translateArticle">
      <p> 리파지토리 프록시는 메소드 이름으로 저장소에 맞는 쿼리를 만들어내는 두가지 방법이 있습니다. 하나는 메소드이름으로 직접적으로 쿼리를 만들어내는 것이고, 아니면 수동적으로 정의된 쿼리를 사용하는 것입니다. 저장소에 따라서 옵션이 더 있을 수도 있습니다. 실제 쿼리를 생성하는 것을 결정할 전략이 있을 수 있습니다. 사용가능한 옵션을 살펴볼까요?</p>
    </div>
    <div class="originalArticle">
      <p>The repository proxy has two ways to derive a store-specific query from the method name. It can derive the query from the method name directly, or by using a manually defined query. Available options depend on the actual store. However, there&#8217;s got to be a strategy that decides what actual query is created. Let&#8217;s have a look at the available options.</p>
    </div>  
</div>
<div class="sect3">
<h4 id="repositories.query-methods.query-lookup-strategies"><a class="anchor" href="#repositories.query-methods.query-lookup-strategies"></a>3.4.1. 쿼리 탐색(lookup) 전략</h4>
<div class="paragraph">
    <div class="translateArticle">
     <p>
  다음 전략에서 리파지토리 인프라스트럭쳐가 쿼리를 해석하는 것이 가능합니다. XML 설정의 네임스페이스에서 <code>query-lookup-strategy</code>속성을 통하거나, 자바설정에서 Enable${store}Repositories어노테이션이 있는 곳에서 <code>queryLookupStrategy</code>속성을 통해 전략을 설정할 수 있습니다. 몇몇 전략은 특정 데이터베이스에서 지원되지 않습니다 .
</p>
    </div>
    <div class="originalArticle">
      <p>The following strategies are available for the repository infrastructure to resolve the query. You can configure the strategy at the namespace through the <code>query-lookup-strategy</code> attribute in case of XML configuration or via the <code>queryLookupStrategy</code> attribute of the Enable${store}Repositories annotation in case of Java config. Some strategies may not be supported for particular datastores.</p>
    </div>  

      
</div>
<div class="ulist">
<ul>
<li>
<p>    <div class="translateArticle">
      <code>CREATE</code> 는 저장소에 맞는 쿼리를 쿼리메소드이름으로 부터 만들어내는 것을 시도합니다. 
      일반적인 접근은 메소드이름으로부터 잘 알려진 접두어를 제거하고 나머지 부분을 파싱하는 것입니다. 쿼리생성에서 이 부분에서 좀 더 읽어보세요.<a href="#repositories.query-methods.query-creation">Query creation</a> 
     
    </div>
    <div class="originalArticle">
      <code>CREATE</code> attempts to construct a store-specific query from the query method name. The general approach is to remove a given set of well-known prefixes from the method name and parse the rest of the method. Read more about query construction in <a href="#repositories.query-methods.query-creation">Query creation</a>.
    </div>  

      </p>
</li>
<li>
    <div class="translateArticle">
      <p><code>USE_DECLARED_QUERY</code> 는 선언된 쿼리를 찾는 것을 시도하고, 찾을 수 없을 때는 예외를 날립니다. 
      쿼리는 어노테이션이나 다른 방법으로 선언된 방식에 의해 정의될 수 있습니다. 특정 데이터 저장소의 문서를 참고하셔서 그 저장소에서 사용가능한 옵션들을 찾아보세요. 만약 리파지토리 인프라스트럭처가 부트스트랩 시간에 그 메소드를 위해 정의된 쿼리를 찾을 수 없으면 이것은 실패합니다. 
       </p>
    </div>
    <div class="originalArticle">
      <p><code>USE_DECLARED_QUERY</code> tries to find a declared query and will throw an exception in case it can&#8217;t find one. The query can be defined by an annotation somewhere or declared by other means. Consult the documentation of the specific store to find available options for that store. If the repository infrastructure does not find a declared query for the method at bootstrap time, it fails.</p>
    </div>  

      
</li>
<li>
    <div class="translateArticle">
      <p><code>CREATE_IF_NOT_FOUND</code> (default) <code>CREATE</code> 와 <code>USE_DECLARED_QUERY</code>를 조합합니다. 이것은 처음에 정의된 쿼리를 찾아보고 발견되지 않으면, 커스텀 메소드네임 기반의 쿼리를 생성합니다. 이것은 기본 탐색전략이고, 당신이 아무것도 명시적으로 설정하지 않으면 기본 설정이 될 것입니다. 이것은 메소드이름으로 빠른 쿼리 정의를 가능케 하며, 필요에 따라 선언된 쿼리를 소개하면서 이러한 쿼리들의 커스텀 튜닝또한 가능하게 합니다. </p>
    </div>
    <div class="originalArticle">
      <p><code>CREATE_IF_NOT_FOUND</code> (default) combines <code>CREATE</code> and <code>USE_DECLARED_QUERY</code>. It looks up a declared query first, and if no declared query is found, it creates a custom method name-based query. This is the default lookup strategy and thus will be used if you do not configure anything explicitly. It allows quick query definition by method names but also custom-tuning of these queries by introducing declared queries as needed.</p>
    </div>  

      
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-methods.query-creation"><a class="anchor" href="#repositories.query-methods.query-creation"></a>    <div class="translateArticle">
      3.4.2. 쿼리 생성
    </div>
    <div class="originalArticle">
      3.4.2. Query creation
    </div>  

      </h4>
<div class="paragraph">
<div class="translateArticle">
      <p>쿼리 빌더 메커니즘은 스프링 데이터 리파지토리 인프라스트럭쳐로 짜여져, 리파지토리의 엔티티들에 맞는 쿼리들을 만들어내는 데 유용합니다. 이 메커니즘은  <code>find…By</code>, <code>read…By</code>, <code>query…By</code>, <code>count…By</code>, 와 <code>get…By</code>같은 접두어들을 메소드에서 떼어내고 나머지부분을 파싱하기 시작합니다. 
        
        다음 소개하는 절은 <code>Distinct</code>(쿼리가 생성될지 결정하는 flag를 설정)같은 더 깊은 표현을 포함하고 있습니다. 그러나 처음의  <code>By</code>는 실제 크리테리아의 시작을 가리키는 구별자로 동작합니다. 기본레벨에서 당신은 엔티티의 속성을 결정할 조건을 정의할 수 있으며, 그것들을 <code>And</code> 와 <code>Or</code>로 연결할 수 있습니다. 
       </p>

    </div>
    <div class="originalArticle">
      <p>The query builder mechanism built into Spring Data repository infrastructure is useful for building constraining queries over entities of the repository. The mechanism strips the prefixes <code>find…By</code>, <code>read…By</code>, <code>query…By</code>, <code>count…By</code>, and <code>get…By</code> from the method and starts parsing the rest of it. The introducing clause can contain further expressions such as a <code>Distinct</code> to set a distinct flag on the query to be created. However, the first <code>By</code> acts as delimiter to indicate the start of the actual criteria. At a very basic level you can define conditions on entity properties and concatenate them with <code>And</code> and <code>Or</code>.</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 8.메소드네임으로 쿼리 생성하기
    </div>
    <div class="originalArticle">
      Example 8. Query creation from method names
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface PersonRepository extends Repository&lt;User, Long&gt; {

  List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);

  // Enables the distinct flag for the query
  List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
  List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);

  // Enabling ignoring case for an individual property
  List&lt;Person&gt; findByLastnameIgnoreCase(String lastname);
  // Enabling ignoring case for all suitable properties
  List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);

  // Enabling static ORDER BY for a query
  List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);
  List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>메소드에 파싱된 실제 결과는 쿼리를 생성하는 데이터베이스에 따라 다르지만, 생각해볼만한 일반적인 것들이 있습니다.  </p>
    </div>
    <div class="originalArticle">
      <p>The actual result of parsing the method depends on the persistence store for which you create the query. However, there are some general things to notice.</p>
    </div>  
</div>
<div class="ulist">
<ul>
<li>
 <div class="translateArticle">
      이 표현은 보통 속성을 순회하며(영어 오타인듯?) 연결될 수 있는 연산자와 함께 조합됩니다. <code>AND</code> 나 <code>OR</code>같은 표현과 함께 속성을 조합할 수 있습니다. 당신은 또한 <code>Between</code>, <code>LessThan</code>, <code>GreaterThan</code>, <code>Like</code>같은 연산자의 지원을 받을 수 있습니다. 
      이러한 지원되는 연산자는 데이터스토어에 따라 다를 수 있으니, 해당 레퍼런스 문서에 적절한 부분을 참고해보세요.

    </div>
    <div class="originalArticle">
      <p>The expressions are usually property traversals combined with operators that can be concatenated. You can combine property expressions with <code>AND</code> and <code>OR</code>. You also get support for operators such as <code>Between</code>, <code>LessThan</code>, <code>GreaterThan</code>, <code>Like</code> for the property expressions. The supported operators can vary by datastore, so consult the appropriate part of your reference documentation.</p>
    </div>  
</li>
<li>
 <div class="translateArticle">
      <p>메소드파서는 code>IgnoreCase</code>에 대한 독립적인 flag 속성설정을 지원하며 예를 들자면 <code>findByLastnameIgnoreCase(…)</code>같은 것이 되거나  <code>findByLastnameAndFirstnameAllIgnoreCase(…)</code>같이 모든 <code>String</code>인스턴스에서도 지원을 할 수 있습니다. 이 부분도 저장소에 따라 다를 수 있으니 해당 저장소 레퍼런스 문서를 참조하세요 </p>
    </div>
    <div class="originalArticle">
      <p>The method parser supports setting an <code>IgnoreCase</code> flag for individual properties (for example, <code>findByLastnameIgnoreCase(…)</code>) or for all properties of a type that support ignoring case (usually <code>String</code> instances, for example, <code>findByLastnameAndFirstnameAllIgnoreCase(…)</code>). Whether ignoring cases is supported may vary by store, so consult the relevant sections in the reference documentation for the store-specific query method.</p>
    </div>  
</li>
<li>
<div class="translateArticle">
      <p>당신은 정적 순서를 <code>OrderBy</code>절을 추가하여 쿼리메소드의 정렬 방향을 정할 수 있습니다. <code>Asc</code> 나 <code>Desc</code> 로 말이죠.. 동적 정렬을 지원하는 쿼리를 만들기 위해 <a href="#repositories.special-parameters">특별 파라미터 핸들링</a>를 보시기 바랍니다. </p>

      
    </div>
    <div class="originalArticle">
      <p>You can apply static ordering by appending an <code>OrderBy</code> clause to the query method that references a property and by providing a sorting direction (<code>Asc</code> or <code>Desc</code>). To create a query method that supports dynamic sorting, see <a href="#repositories.special-parameters">Special parameter handling</a>.</p>
    </div>  
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-methods.query-property-expressions"><a class="anchor" href="#repositories.query-methods.query-property-expressions"></a>3.4.3. 속성 표현</h4>
<div class="paragraph">
 <div class="translateArticle">
      <p>속성표현은 이전 예제에서 나타난대로, 관리되는 엔티티의 직접적인 속성을 참조할 수 있습니다. 쿼리 생성 시간에 당신은 이미 파싱된 속성이 관리되는 도메인 클래스의 일부라는 것을 확실하게 하고 가야 합니다. 그러나 당신은 중첩속성에 대한 제약을 정의할 수 있습니다. <code>Person</code>이 <code>ZipCode</code>와 함께 있는 <code>Address</code>를 가지고 있다고 생각해봅시다. 이러한 경우 메소드 네임은  </p>

   
    </div>
    <div class="originalArticle">
      <p>Property expressions can refer only to a direct property of the managed entity, as shown in the preceding example. At query creation time you already make sure that the parsed property is a property of the managed domain class. However, you can also define constraints by traversing nested properties. Assume a <code>Person</code> has an <code>Address</code> with a <code>ZipCode</code>. In that case a method name of</p>
    </div>  
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List&lt;Person&gt; findByAddressZipCode(ZipCode zipCode);</code></pre>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p> 이렇게 되며, <code>x.address.zipCode</code> 이라는 속성에 접근하게 됩니다.   이렇게 해석하는 알고리즘은 전체 부분(<code>AddressZipCode</code>)을 속성으로 인터프리팅하면서 시작되어 속성에 맞는 도메인 클래스를 검사합니다. 만약 알고리즘이 성공하면, 이것은 저 속성을 사용할 것이고. 그렇지 않다면 알고리즘은 저 부분을 Camel case 부분의 오른쪽부터 왼쪽으로 그리고 꼬리부분으로 나눠보며, 맞는 속성을 찾으려 할 것입니다. 우리의 예제에서는 <code>AddressZip</code> 와 <code>Code</code>일 것입니다. 만약 알고리즘이 앞에서 맞는 속성을 찾아내면, 거기서부터 뒷부분을 가지고서 트리다운을 만들기 시작합니다. (역주: 그 뒷부부분으로 변수를 만든다는 뜻인듯^^;) 이전에 설명한 방법대로 뒷부분을 잘라보면서 말입니다. 만약 처음 나누기가 매칭이 되지 않으면 알고리즘은 나누는 지점을 왼쪽으로 이동해보게 됩니다.  (<code>Address</code>, <code>ZipCode</code>) 그리고 다시 시작합니다. </p>

        
    </div>
    <div class="originalArticle">
      <p>creates the property traversal <code>x.address.zipCode</code>. The resolution algorithm starts with interpreting the entire part (<code>AddressZipCode</code>) as the property and checks the domain class for a property with that name (uncapitalized). If the algorithm succeeds it uses that property. If not, the algorithm splits up the source at the camel case parts from the right side into a head and a tail and tries to find the corresponding property, in our example, <code>AddressZip</code> and <code>Code</code>. If the algorithm finds a property with that head it takes the tail and continue building the tree down from there, splitting the tail up in the way just described. If the first split does not match, the algorithm move the split point to the left (<code>Address</code>, <code>ZipCode</code>) and continues.</p>
    </div>  
</div>
<div class="paragraph">
<div class="translateArticle">
  <p>비록 이러한 작업이 대부분의 경우 잘 동작하지만, 잘못 동작할 경우가 있습니다.  <code>Person</code> 가 <code>addressZip</code>이라는 속성도 가지고 있다고 생각해봅시다. 이러한 알고리즘은 처음 나누면서 본질적으로 잘못된 뒷부분을 <code>addressZip</code>가지게 되어 아무런 속성도 아닌(<code>code</code>)것을 고르게 됩니다.   </p>

    
    </div>
    <div class="originalArticle">
      <p>Although this should work for most cases, it is possible for the algorithm to select the wrong property. Suppose the <code>Person</code> class has an <code>addressZip</code> property as well. The algorithm would match in the first split round already and essentially choose the wrong property and finally fail (as the type of <code>addressZip</code> probably has no <code>code</code> property).</p>
    </div>  
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>
        이러한 모호한 점을 해결하기 위해 당신은 <code>_</code> 를 당신의 메소드 이름 내에 사용하여 수동적으로 횡단지점(tracersal이라고 나와있는데 나누는 지점이라 해야 맞을듯)을 정의할 수 있습니다. 그래서 메소드 이름은 다음과 같이 끝나게 됩니다. </p>
    </div>
    <div class="originalArticle">
      <p>To resolve this ambiguity you can use <code>_</code> inside your method name to manually define traversal points. So our method name would end up like so:</p>
    </div>  

</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List&lt;Person&gt; findByAddress_ZipCode(ZipCode zipCode);</code></pre>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>우리가 _를 예약된 문자어로 썼기 때문에, 우리는 강력하게 표준 자바 작명 관습을 따르기를 권합니다 .
            (i.e. <strong>카멜케이스CamelCase</strong> 쓰세요^^)</p>

      
    </div>
    <div class="originalArticle">
      <p>As we treat underscore as a reserved character we stongly advise to follow standard Java naming conventions (i.e. <strong>not</strong> using underscores in property names but camel case instead).</p>
    </div>  
</div>
</div>
<div class="sect3">
<h4 id="repositories.special-parameters"><a class="anchor" href="#repositories.special-parameters"></a>    <div class="translateArticle">
      3.4.4. 특별 파라미터 핸들링
    </div>
    <div class="originalArticle">
      3.4.4. Special parameter handling
    </div>  

      </h4>
<div class="paragraph">
<div class="translateArticle">
      <p>당신의 쿼리에서 파라미터를 다루기 위해, 당신은 간단히 메소드파라미터를 예전에 봤던 예제에서 처럼 정의할 수 있습니다. 게다가 인프라스트럭쳐가 <code>Pageable</code>, <code>Sort</code>같은 특정 타입을 인식하여 당신의 쿼리에서 페이징과 정렬을 동적으로 하게 해줄 것입니다.  </p>
    </div>
    <div class="originalArticle">
      <p>To handle parameters in your query you simply define method parameters as already seen in the examples above. Besides that the infrastructure will recognize certain specific types like <code>Pageable</code> and <code>Sort</code> to apply pagination and sorting to your queries dynamically.</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 9. 쿼리메소드에서 Pageable, Slice와 Sort를 사용하기
    </div>
    <div class="originalArticle">
      Example 9. Using Pageable, Slice and Sort in query methods
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);

Slice&lt;User&gt; findByLastname(String lastname, Pageable pageable);

List&lt;User&gt; findByLastname(String lastname, Sort sort);

List&lt;User&gt; findByLastname(String lastname, Pageable pageable);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
        <p>첫번째 메소드는 <code>org.springframework.data.domain.Pageable</code>인스턴스를 쿼리메소드에 전달하여 정적으로 정의된 쿼리에 동적으로 페이징을 추가하게 해줍니다. <code>Page</code>는 전체적인 요소의 숫자와 가능한 페이지의 개수를 알 수 있습니다. 하부구조에서 숫자조회 쿼리를 발동하여 전체적인 숫자를 계산함으로써 그것이 가능해집니다. 이것은 사용하는 저장소에 따라서 비싼 작업이 될 수도 있습니다. <code>Slice</code>가 반환형으로 대신 리턴될 수도 있습니다.  <code>Slice</code>는 오직 다음 <code>Slice</code> 가 가능한지만을 알고 있으며 많은 결과 셋을 가지고 작업할 때 쓰기 충분할 것입니다.  </p>

     
    </div>
    <div class="originalArticle">
      <p>The first method allows you to pass an <code>org.springframework.data.domain.Pageable</code> instance to the query method to dynamically add paging to your statically defined query. A <code>Page</code> knows about the total number of elements and pages available. It does so by the infrastructure triggering a count query to calculate the overall number. As this might be expensive depending on the store used, <code>Slice</code> can be used as return instead. A <code>Slice</code> only knows about whether there&#8217;s a next <code>Slice</code> available which might be just sufficient when walking thought a larger result set.</p>
    </div>  

      
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>정렬 옵션은 <code>Pageable</code> 인스턴스를 통해서도 다뤄지기도 합니다. 오직 정렬만을 필요로 한다면 <code>org.springframework.data.domain.Sort</code> 를 당신의 메소드에 파라미터로 전달해보세요. 당신이 보듯이, 단순히 <code>List</code>를 리턴하는 것이 가능할 것입니다. 이러한 경우 실제 <code>Page</code>인스턴스를 만들어내는 데 필요한 추가적인 메타데이터 생성되지 않을 것입니다 ( 여기서는 필요할지도 모르는 추가적인 카운트 쿼리가 발생되지 않는다는 것을 의미합니다 ) 대신에 단순히 쿼리를 오직 주어진 범위의 엔티티에서만으로 제한하는 것입니다. </p>


      
    </div>
    <div class="originalArticle">
      <p>Sorting options are handled through the <code>Pageable</code> instance too. If you only need sorting, simply add an <code>org.springframework.data.domain.Sort</code> parameter to your method. As you also can see, simply returning a <code>List</code> is possible as well. In this case the additional metadata required to build the actual <code>Page</code> instance will not be created (which in turn means that the additional count query that would have been necessary not being issued) but rather simply restricts the query to look up only the given range of entities.</p>
    </div>  

      
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="translateArticle">
      당신이 쿼리에서 얼마나 많은 페이지를 얻을 수 있는지 알아보기 위해,  당신은 추가적인 count 쿼리를 동작시켜야 합니다. 기본적으로 이 쿼리는 당신이 실제적으로 동작하는 쿼리로부터 만들어집니다. 
      (역주 : 말이 이상한 것같은데;; 그냥 페이징 하면서 카운트 쿼리가 같이 날아간다 그런 말인 듯하다.)
    </div>
    <div class="originalArticle">
      To find out how many pages you get for a query entirely you have to trigger an additional count query. By default this query will be derived from the query you actually trigger.
    </div>  
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.limit-query-result"><a class="anchor" href="#repositories.limit-query-result"></a>    <div class="translateArticle">
       3.4.5. 쿼리 결과 Limit 하기
    </div>
    <div class="originalArticle">
      3.4.5. Limiting query results
    </div>  

      </h4>
<div class="paragraph">
 <div class="translateArticle">
      <p>쿼리메소드의 결과는 <code>first</code>나 <code>top</code>를 통해서 제한될 수 있으며 바꿔 쓸수 있습니다. 선택적인 숫자값이 top/first 로 추가되어 반환될 최대 결과 크기를 명시할 수 있습니다. 만약 숫자가 무시하면 1로 가정합니다. </p>
    </div>
    <div class="originalArticle">
      <p>The results of query methods can be limited via the keywords <code>first</code> or <code>top</code>, which can be used interchangeably. An optional numeric value can be appended to top/first to specify the maximum result size to be returned. If the number is left out, a result size of 1 is assumed.</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 10. <code>Top</code> 과 <code>First</code>로 결과 크기를 한계짓기 :</code>
    </div>
    <div class="originalArticle">
      Example 10. Limiting the result size of a query with <code>Top</code> and <code>First</code>
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">User findFirstByOrderByLastnameAsc();

User findTopByOrderByAgeDesc();

Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable);

Slice&lt;User&gt; findTop3ByLastname(String lastname, Pageable pageable);

List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort);

List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p> Limiting 표현은 또한 <code>Distinct</code>키워드를 지원합니다. 또한 결과 셋이 하나의 인스턴스로 제한된 쿼리들을 위해 결과를 <code>Optional</code>로 포장(wrapping)하는 것도 지원됩니다 .
      </p>
    </div>
    <div class="originalArticle">
      <p>The limiting expressions also support the <code>Distinct</code> keyword. Also, for the queries limiting the result set to one instance, wrapping the result into an <code>Optional</code> is supported.</p>
    </div>  
</div>
<div class="paragraph">
 <div class="translateArticle">
      <p>만약 페이지네이션이나 슬라이싱이 제한된 쿼리 페이지네이션에 적용이 되면, (사용가능한 페이지숫자들에 적용이 되면) 이것은 제한된 결과내에서 적용됩니다. </p>

     
    </div>
    <div class="originalArticle">
      <p>If pagination or slicing is applied to a limiting query pagination (and the calculation of the number of pages available) then it is applied within the limited result.</p>
    </div>  
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="translateArticle">
      <code>Sort</code>파라미터를 통한 동적 정렬과 결과값을 limiting 하는 것의 조합은 쿼리메소드를 나타내게 하는 것을 허용하게 해줍니다. ( 뒷부분에 나온 for문인데 잘 이해가 안된다.  for the 'K' smallest as well as for the 'K' biggest elements.)
    </div>
    <div class="originalArticle">
      Note that limiting the results in combination with dynamic sorting via a <code>Sort</code> parameter allows to express query methods for the 'K' smallest as well as for the 'K' biggest elements.
    </div>  
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-streaming"><a class="anchor" href="#repositories.query-streaming"></a>    <div class="translateArticle">
     3.4.6. 쿼리 결과 Streaming 하기
    </div>
    <div class="originalArticle">
      3.4.6. Streaming query results
    </div>  

      </h4>
<div class="paragraph">
<div class="translateArticle">
     <p> 쿼리 메소드의 결과값은 Java8의 <code>Stream&lt;T&gt;</code>를 이용하여 점차적으로 처리될 수 있습니다. 단순히 쿼리의 결과를 <code>Stream</code> 으로 포장( wrapping )하여, 데이터 스토어 특정 메소드들은 스트리밍을 하는데 사용됩니다. </p>


     
    </div>
    <div class="originalArticle">
      <p>The results of query methods can be processed incrementally by using a Java 8 <code>Stream&lt;T&gt;</code> as return type. Instead of simply wrapping the query results in a <code>Stream</code> data store specific methods are used to perform the streaming.</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 11.  자바8 <code>Stream&lt;T&gt;</code>로 쿼리 결과 Stream하기 :
    </div>
    <div class="originalArticle">
      Example 11. Stream the result of a query with Java 8 <code>Stream&lt;T&gt;</code>
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Query("select u from User u")
Stream&lt;User&gt; findAllByCustomQueryAndStream();

Stream&lt;User&gt; readAllByFirstnameNotNull();

@Query("select u from User u")
Stream&lt;User&gt; streamAllPaged(Pageable pageable);</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="translateArticle">
      <code>Stream</code>은 잠재적으로 데이터스토어특정자원을 포장(wrap)하고 사용뒤에 반드시 닫혀져야 합니다. 당신은 직접 <code>Stream</code> 를 <code>close()</code>를 사용하여 닫아주거나 Java7의 try-with-resources블록을 사용할 수도 있습니다 .
    </div>
    <div class="originalArticle">
      A <code>Stream</code> potentially wraps underlying data store specific resources and must therefore be closed after usage. You can either manually close the <code>Stream</code> using the <code>close()</code> method or by using a Java 7 try-with-resources block.
    </div>  
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 12. <code>Stream&lt;T&gt;</code> 와 try-with-resources 블록으로 작업해보기
    </div>
    <div class="originalArticle">
      Example 12. Working with a <code>Stream&lt;T&gt;</code> result in a try-with-resources block
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">try (Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) {
  stream.forEach(…);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
 <div class="translateArticle">
      모든 스프링 데이터 모듈이 현재 <code>Stream&lt;T&gt;</code>를 반환타입으로 제공하는 것은 아닙니다 .
    </div>
    <div class="originalArticle">
      Not all Spring Data modules currently support <code>Stream&lt;T&gt;</code> as a return type.
    </div>  
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.create-instances"><a class="anchor" href="#repositories.create-instances"></a>    <div class="translateArticle">
    3.5. 리파지토리 인스턴스 생성하기
    </div>
    <div class="originalArticle">
      3.5. Creating repository instances
    </div>  

      </h3>
<div class="paragraph"> 
  <div class="translateArticle">
      <p>이 섹션에서는 당신은 리파지토리 인터페이스 정의를 위한 인스턴스들을 생성해보고 빈도 정의해봅니다.. 이것을 하는 한가지 방법은 스프링데이터모듈에 있는 Spring 네임 스페이스를 사용하는 것입니다. 비록 우리가 일반적으로 자바설정 스타일의 설정을 추천하지만, 스프링 데이터 모듈은 리파지토리 메커니즘을 지원합니다. </p>

    </div>
    <div class="originalArticle">
      <p>In this section you create instances and bean definitions for the repository interfaces defined. One way to do so is using the Spring namespace that is shipped with each Spring Data module that supports the repository mechanism although we generally recommend to use the Java-Config style configuration.</p>
    </div>  
</div>
<div class="sect3">
<h4 id="repositories.create-instances.spring"><a class="anchor" href="#repositories.create-instances.spring"></a>3.5.1. XML configuration</h4>
<div class="paragraph">
<div class="translateArticle">
     <p> 각각의 스프링 데이터 모듈은 repository 요소들을 포함하며 이 요소들은 단순하게 스프링이 스캔하는 base Package를 정의하게 해줍니다. </p>
     
    </div>
    <div class="originalArticle">
      <p>Each Spring Data module includes a repositories element that allows you to simply define a base package that Spring scans for you.</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 13.  XML을 통한 SPring data Repository 활성화
    </div>
    <div class="originalArticle">
      Example 13. Enabling Spring Data repositories via XML
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns:beans="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://www.springframework.org/schema/data/jpa"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/jpa
    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

  &lt;repositories base-package="com.acme.repositories" /&gt;

&lt;/beans:beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>예전의 예제에서, 스프링은 <code>Repository</code>나 그 하위 인터페이스를 상속한 인터페이스들을 위해서 <code>com.acme.repositories</code>를 스캔을 하기로 되어있으며, 여기서의 모든 하위패키지들들을 스캔하기로 되어있습니다. 각각의 인터페이스가 발견되면 인프라스트럭쳐는 특정기술-영속 <code>FactoryBean</code>에 등록을 하여 적절한 프록시를 만들어 쿼리 메소드의 실행을 다루게 됩니다. 각각의 빈은 인터페이스로 추론된 빈 네임 아래 등록됩니다. 그래서 <code>UserRepository</code> 의 인터페이스는 <code>userRepository</code>로 등록이 될 것입니다. <code>base-package</code>속성은 와일드카드를 허용하여 당신은 스캔될 패키지로 패턴을 사용할 수도 있습니다 .</p>
    </div>
    <div class="originalArticle">
      <p>In the preceding example, Spring is instructed to scan <code>com.acme.repositories</code> and all its sub-packages for interfaces extending <code>Repository</code> or one of its sub-interfaces. For each interface found, the infrastructure registers the persistence technology-specific <code>FactoryBean</code> to create the appropriate proxies that handle invocations of the query methods. Each bean is registered under a bean name that is derived from the interface name, so an interface of <code>UserRepository</code> would be registered under <code>userRepository</code>. The <code>base-package</code> attribute allows wildcards, so that you can define a pattern of scanned packages.</p>
    </div>  
</div>
<div class="sect4">
<h5 id="_using_filters"><a class="anchor" href="#_using_filters"></a>Using filters</h5>
<div class="paragraph">
<div class="translateArticle">
      <p>기본적으로 인프라스트럭쳐는 설정된 base package 밑의 각각의 특정영속기술 <code>Repository</code>하위 인터페이스를 골라서, 그것을 위한 빈 인스턴스를 생성합니다. 그러나 당신은 좀더 상세한 설정을 원할 수도 있습니다. 이를 위해서 당신은 <code>&lt;include-filter /&gt;</code> 나 <code>&lt;exclude-filter /&gt;</code>를 요소를 <code>&lt;repositories /&gt;</code> 내부에 사용할 수도 있습니다. 이러한 문법은 스프링의 콘텍스트 네임스페이스와 정확히 동일합니다. 세부적인 사항은  <a href="{spring-framework-docs}/beans.html#beans-scanning-filters">스프링 레퍼런스 문서</a>를 보시길 바랍니다. (역주: 번역문서라 스프링 공홈 변수 설정이 안됨ㅠ)   </p>

      
    </div>
    <div class="originalArticle">
      <p>By default the infrastructure picks up every interface extending the persistence technology-specific <code>Repository</code> sub-interface located under the configured base package and creates a bean instance for it. However, you might want more fine-grained control over which interfaces bean instances get created for. To do this you use <code>&lt;include-filter /&gt;</code> and <code>&lt;exclude-filter /&gt;</code> elements inside <code>&lt;repositories /&gt;</code>. The semantics are exactly equivalent to the elements in Spring&#8217;s context namespace. For details, see <a href="{spring-framework-docs}/beans.html#beans-scanning-filters">Spring reference documentation</a> on these elements.</p>
    </div>  
</div>
<div class="paragraph">
 <div class="translateArticle">
      <p>예를 들자면, 리파지토리에서 인스턴스화되는 특정 인터페이스를 제외하기 위해서 당신은 다음의 설정을 할 수도 있습니다 :  </p>
    </div>
    <div class="originalArticle">
      <p>For example, to exclude certain interfaces from instantiation as repository, you could use the following configuration:</p>
    </div>  

</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 14. exclude-filter 요소 사용해보기
    </div>
    <div class="originalArticle">
      Example 14. Using exclude-filter element
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;repositories base-package="com.acme.repositories"&gt;
  &lt;context:exclude-filter type="regex" expression=".*SomeRepository" /&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>이 예제는 <code>SomeRepository</code> 로 끝나는 모든 요소들이 인스턴스화되지 않게 합니다. </p>
    </div>
    <div class="originalArticle">
      <p>This example excludes all interfaces ending in <code>SomeRepository</code> from being instantiated.</p>
    </div>  
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.create-instances.java-config"><a class="anchor" href="#repositories.create-instances.java-config"></a>3.5.2. JavaConfig</h4>
<div class="paragraph">
 <div class="translateArticle">
      <p>리파지토리 인프라스트럭쳐는 자바설정에서 특정 저장소 <code>@Enable${store}Repositories</code> 어노테이션을 사용하여 동작합니다. 스프링콘테이너에서 자바 기반의 설정에 대한 소개를 보기 위해 , 레퍼런스 문서를 보세요.<span class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</span></p>
    </div>
    <div class="originalArticle">
      <p>The repository infrastructure can also be triggered using a store-specific <code>@Enable${store}Repositories</code> annotation on a JavaConfig class. For an introduction into Java-based configuration of the Spring container, see the reference documentation.<span class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</span></p>
    </div>  
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>스프링 데이터 리파지토리를 활성화시키는 간단한 설정입니다.</p>
    </div>
    <div class="originalArticle">
      <p>A sample configuration to enable Spring Data repositories looks something like this.</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 15. 간단한 어노테이션 기반의 리파지토리 설정
    </div>
    <div class="originalArticle">
      Example 15. Sample annotation based repository configuration
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJpaRepositories("com.acme.repositories")
class ApplicationConfiguration {

  @Bean
  public EntityManagerFactory entityManagerFactory() {
    // …
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
 <div class="translateArticle">
    예제에서는 JPA기반의 어노테이션을 사용하였지만 당신이 실제로 사용하는 저장소모듈에 따라 바꿔줄 수 있습니다. <code>EntityManagerFactory</code>빈의 정의에 똑같이 적용이 됩니다. 특정저장소 설정에 대해 다루는 섹션을 참조하세요 
    </div>
    <div class="originalArticle">
      The sample uses the JPA-specific annotation, which you would change according to the store module you actually use. The same applies to the definition of the <code>EntityManagerFactory</code> bean. Consult the sections covering the store-specific configuration.
    </div>  
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.create-instances.standalone"><a class="anchor" href="#repositories.create-instances.standalone"></a>3.5.3. Standalone usage</h4>
<div class="paragraph">
<div class="translateArticle">
      <p>당신은 또한 스프링 컨테이너의 바깥에서 repository infrastructure를 사용할 수 있습니다. 예를 들자면 CDI환경도 있습니다. 당신은 여전히 클래스 패스에 스프링 라이브러리가 필요할 것이지만, 일반적으로 계획에 따라서 리파지토리들을 설정할 수 있습니다. 리파지토리 지원을 제공하는 스프링 데이터 모듈은 당신이 사용할 수 있는 특정기술영속저장소 RepositoryFactory를 가지고 있을 수 있습니다 .</p>

    </div>
    <div class="originalArticle">
      <p>You can also use the repository infrastructure outside of a Spring container, e.g. in CDI environments. You still need some Spring libraries in your classpath, but generally you can set up repositories programmatically as well. The Spring Data modules that provide repository support ship a persistence technology-specific RepositoryFactory that you can use as follows.</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 16.  리파지토리 팩토리의 독립적인 사용. Standalone usage of repository factory
    </div>
    <div class="originalArticle">
      Example 16. Standalone usage of repository factory
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">RepositoryFactorySupport factory = … // Instantiate factory here
UserRepository repository = factory.getRepository(UserRepository.class);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.custom-implementations"><a class="anchor" href="#repositories.custom-implementations"></a><div class="translateArticle">
      3.6. 스프링 데이터 리파지토리의 커스텀 구현
    </div>
    <div class="originalArticle">
      3.6. Custom implementations for Spring Data repositories
    </div>  </h3>
<div class="paragraph">
<div class="translateArticle">
      <p>종종 적은 리파지토리 메소드를 위해 커스텀 구현을 제공해야할 필요가 있습니다. 스프링 데이터 리파지토리는 쉽게 커스텀 리파지토리 코드를 제공하고 , 이것을 일반적인 CRUD추상화와 쿼리 메소드 기능에 통합시키게 해줍니다. </p>
    </div>
    <div class="originalArticle">
      <p>Often it is necessary to provide a custom implementation for a few repository methods. Spring Data repositories easily allow you to provide custom repository code and integrate it with generic CRUD abstraction and query method functionality.</p>
    </div>  
</div>
<div class="sect3">
<h4 id="repositories.single-repository-behaviour"><a class="anchor" href="#repositories.single-repository-behaviour"></a><div class="translateArticle">
      3.6.1. 단일 리파지토리에 커스텀 행동 추가해보기
    </div>
    <div class="originalArticle">
      3.6.1. Adding custom behavior to single repositories
    </div>  </h4>


<div class="paragraph">
 <div class="translateArticle">
      <p>
        리파지토리에 커스텀 기능을 좀 더 넣기 위해, 당신은 먼저 인터페이스를 정의하고, 그 커스텀 기능을 위한 구현체를 정의해야 합니다. repository 인터페이스를 사용하여 커스텀 인터페이스를 확장하세요. 

        </p>
    </div>
    <div class="originalArticle">
      <p>To enrich a repository with custom functionality you first define an interface and an implementation for the custom functionality. Use the repository interface you provided to extend the custom interface.</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 17.  커스텀 리파지토리 기능을 위한 인터페이스
    </div>
    <div class="originalArticle">
      Example 17. Interface for custom repository functionality
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">interface UserRepositoryCustom {
  public void someCustomMethod(User user);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 18. 커스텀 리파지토리 기능 구현
    </div>
    <div class="originalArticle">
      Example 18. Implementation of custom repository functionality
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">class UserRepositoryImpl implements UserRepositoryCustom {

  public void someCustomMethod(User user) {
    // Your custom implementation
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
 <div class="translateArticle">
      다른 핵심리파지토리 인터페이스와 비교해봤을 때, 클래스에서 가장 중요하게 발견되는 부분은 이름의 <code>Impl</code> 접미어입니다. (하단 참조 )

    </div>
    <div class="originalArticle">
      The most important bit for the class to be found is the <code>Impl</code> postfix of the name on it compared to the core repository interface (see below).
    </div>  
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>그 스스로의 구현은 스프링데이터에 의존하지 않으며, 정식 스프링빈이 될 수 있습니다. 그러므로 당신은 JDBCTemplate 같은 다른 빈처럼, 표준 의존성주입행동을 주입레퍼런스로써 사용할 수 있습니다. 
            aspects에 참여시키는 것같은 일을 할 수가 있습니다. 
            </p>
    </div>
    <div class="originalArticle">
      <p>The implementation itself does not depend on Spring Data and can be a regular Spring bean. So you can use standard dependency injection behavior to inject references to other beans like a JdbTemplate, take part in aspects, and so on.</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 19. 당신의 기본적인 리파지토리 인터페이스 변경 Changes to the your basic repository interface
    </div>
    <div class="originalArticle">
      Example 19. Changes to the your basic repository interface
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, Long&gt;, UserRepositoryCustom {

  // Declare query methods here
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>이제 당신의 표준 리파지토리 인터페이스를 커스텀버젼으로 확장해봅시다. CRUD와 커스텀 기능을 조합하여 클라이언트에게 사용가능하게 해봅시다. </p>
    </div>
    <div class="originalArticle">
      <p>Let your standard repository interface extend the custom one. Doing so combines the CRUD and custom functionality and makes it available to clients.</p>
    </div>  

</div>
<div class="sect4">
<h5 id="_configuration"><a class="anchor" href="#_configuration"></a>설정</h5>
<div class="paragraph">
<div class="translateArticle">
      <p>만약 당신이 네임스페이스 설정을 사용한다면 리파지토리 인프라스트럭쳐는 자동으로 리파지토리를 발견한 곳에 있는 패키지에서 클래스를 스캔하여 커스텀 구현체를 찾을 것입니다. 이러한 클래스들은 네임스페이스 요소 속성 <code>repository-impl-postfix</code>을 따를 필요가 있습니다. 이러한 접미어는 기본적으로 <code>Impl</code>입니다. </p>
    </div>
    <div class="originalArticle">
      <p>If you use namespace configuration, the repository infrastructure tries to autodetect custom implementations by scanning for classes below the package we found a repository in. These classes need to follow the naming convention of appending the namespace element&#8217;s attribute <code>repository-impl-postfix</code> to the found repository interface name. This postfix defaults to <code>Impl</code>.</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      설정 20. 설정 예제Configuration example
    </div>
    <div class="originalArticle">
      Example 20. Configuration example
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;repositories base-package="com.acme.repository" /&gt;

&lt;repositories base-package="com.acme.repository" repository-impl-postfix="FooBar" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>첫번째 설정 예제에서는 <code>com.acme.repository.UserRepositoryImpl</code> 라는 클래스를 찾아 커스텀 리파지토리 구현체로 작동하게 할 것입니다. 반면에 두번째 예제 줄에서는 <code>com.acme.repository.UserRepositoryFooBar</code>를 찾을 것입니다. </p>
    </div>
    <div class="originalArticle">
      <p>The first configuration example will try to look up a class <code>com.acme.repository.UserRepositoryImpl</code> to act as custom repository implementation, whereas the second example will try to lookup <code>com.acme.repository.UserRepositoryFooBar</code>.</p>
    </div>  
</div>
<div class="sect5">
<h6 id="_manual_wiring"><a class="anchor" href="#_manual_wiring"></a>수동 와이어링 Manual wiring</h6>
<div class="paragraph">
<div class="translateArticle">
      <p>만약 당신의 커스텀 구현체가 어노테이션 기반의 설정을 사용한다면 이러한 접근은 잘 동작할 것이며, 커스텀 구현체는 다른 스프링 빈으로 잘 다뤄질 것입니다. 만약 커스텀 구현체가 특별한 와이어링을 원한다면 당신은 단순히 빈을 선언하고 앞서 선언한 컨벤션에 따라 이름지으면 됩니다. 인프라스트럭쳐는 수동으로, 새로 빈을 만드는 대신에 이름으로 정의된 빈정의를 참조할 것입니다. 
    </p>
    </div>
    <div class="originalArticle">
      <p>The approach just shown works well if your custom implementation uses annotation-based configuration and autowiring only, as it will be treated as any other Spring bean. If your custom implementation bean needs special wiring, you simply declare the bean and name it after the conventions just described. The infrastructure will then refer to the manually defined bean definition by name instead of creating one itself.</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 21. 커스텀 구현체의 수동 와이어링 Manual wiring of custom implementations
    </div>
    <div class="originalArticle">
      Example 21. Manual wiring of custom implementations
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;repositories base-package="com.acme.repository" /&gt;

&lt;beans:bean id="userRepositoryImpl" class="…"&gt;
  &lt;!-- further configuration --&gt;
&lt;/beans:bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.custom-behaviour-for-all-repositories"><a class="anchor" href="#repositories.custom-behaviour-for-all-repositories"></a>    <div class="translateArticle">
      3.6.2. 모든 리파지토리들에 커스텀 행동 추가하기 
    </div>
    <div class="originalArticle">
      3.6.2. Adding custom behavior to all repositories
    </div>  

      </h4>
<div class="paragraph">
 <div class="translateArticle">
      <p>만약 당신이 모든 리파지토리 인터페이스에 하나의 메소드를 추가하고 싶을 때 이전의 접근들은 실현가능하지가 않았습니다.  </p>
    </div>
    <div class="originalArticle">
      <p>The preceding approach is not feasible when you want to add a single method to all your repository interfaces.  </p>
    </div>  
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<div class="translateArticle">
        모든 리파지토리에서 커스텀 행동을 추가하기 위해, 먼저 공유행동으로 선언할 중계인터페이스를 추가합니다. 
    </div>
    <div class="originalArticle">
      To add custom behavior to all repositories, you first add an intermediate interface to declare the shared behavior
    </div> 
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 22. 커스텀 공유 행동 선언하는 인터페이스
    </div>
    <div class="originalArticle">
      Example 22. An interface declaring custom shared behavior
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@NoRepositoryBean
public interface MyRepository&lt;T, ID extends Serializable&gt;
  extends PagingAndSortingRepository&lt;T, ID&gt; {

  void sharedCustomMethod(ID id);
}</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<div class="translateArticle">
      이제 당신의 독립적인 리파지토리 인터페이스는 <code>Repository</code>대신에 이 중계인터페이스를 상속하고, 선언된 기능을 포함할 것입니다. 

     
    </div>
    <div class="originalArticle">
      Now your individual repository interfaces will extend this intermediate interface instead of the <code>Repository</code> interface to include the functionality declared.
    </div>  
</li>
<li>
 <div class="translateArticle">
      다음으로, 영속기술특징 리파지토리 빈 클래스를 상속하는 중계인터페이스의 구현체를 생성합니다. 
      이 클래스는 리파지토리 프록시를 위한 커스텀 base 클래스로 동작할 것입니다 .
    </div>
    <div class="originalArticle">
      Next, create an implementation of the intermediate interface that extends the persistence technology-specific repository base class. This class will then act as a custom base class for the repository proxies.
    </div>  
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 23. 커스텀 리파지토리 베이스 클래스 Custom repository base class
    </div>
    <div class="originalArticle">
      Example 23. Custom repository base class
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class MyRepositoryImpl&lt;T, ID extends Serializable&gt;
  extends SimpleJpaRepository&lt;T, ID&gt; implements MyRepository&lt;T, ID&gt; {

  private final EntityManager entityManager;

  public MyRepositoryImpl(Class&lt;T&gt; domainClass, EntityManager entityManager) {
    super(domainClass, entityManager);

    // Keep the EntityManager around to used from the newly introduced methods.
    this.entityManager = entityManager;
  }

  public void sharedCustomMethod(ID id) {
    // implementation goes here
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      spring의 <code>&lt;repositories /&gt;</code> 네임스페이스의 기본행동은 <code>base-package</code>아래에 있는 모든 인터페이스들에 대한 구현체를 제공하는 것입니다. 이것은 현재 상태로 남아있다면 구현체는 <code>MyRepository</code>의 인스턴스가 스프링에 의해 생성된다는 것을 의미합니다. 물론 이것은 <code>Repository</code>와 실제 엔티티를 위해 정의한 리파지토리 인터페이스간에서 중계자로 행동하기를 바라고 있는 와중에 의도한 것이 아닙니다. <code>Repository</code>를 상속하는 인터페이스를 제외시키기 위해 당신은 그것을 <code>@NoRepositoryBean</code>로 어노테이션하거나, <code>base-package</code>바깥으로 제외시켜줘야할 것입니다. 
    </div>
    <div class="originalArticle">
      The default behavior of the Spring <code>&lt;repositories /&gt;</code> namespace is to provide an implementation for all interfaces that fall under the <code>base-package</code>. This means that if left in its current state, an implementation instance of <code>MyRepository</code> will be created by Spring. This is of course not desired as it is just supposed to act as an intermediary between <code>Repository</code> and the actual repository interfaces you want to define for each entity. To exclude an interface that extends <code>Repository</code> from being instantiated as a repository instance, you can either annotate it with <code>@NoRepositoryBean</code> (as seen above) or move it outside of the configured <code>base-package</code>.
    </div>  
</div>
</li>
<li>
<div class="translateArticle">
      <p>그러고 난 후에 커스텀 리파지토리 팩토리를 만들어 기본 <code>RepositoryFactoryBean</code>를 대체하여 커스텀 <code>RepositoryFactory</code>을 만들어봅시다. 그러면 새로운 리파지토리 팩토리는 당신에게 <code>Repository</code>인터페이스를 상속하는 어떤 인터페이스의 구현체로써 <code>MyRepositoryImpl</code>를 제공할 것이고, 이것은 <code>SimpleJpaRepository</code> 구현체를 대체할 것입니다. 
      </p>

    </div>
    <div class="originalArticle">
      <p>Then create a custom repository factory to replace the default <code>RepositoryFactoryBean</code> that will in turn produce a custom <code>RepositoryFactory</code>. The new repository factory will then provide your <code>MyRepositoryImpl</code> as the implementation of any interfaces that extend the <code>Repository</code> interface, replacing the <code>SimpleJpaRepository</code> implementation you just extended.</p>
    </div> 
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 24. 커스텀 리파지토리 팩토리 빈 Custom repository factory bean
    </div>
    <div class="originalArticle">
      Example 24. Custom repository factory bean
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class MyRepositoryFactoryBean&lt;R extends JpaRepository&lt;T, I&gt;, T,
  I extends Serializable&gt; extends JpaRepositoryFactoryBean&lt;R, T, I&gt; {

  protected RepositoryFactorySupport createRepositoryFactory(EntityManager em) {
    return new MyRepositoryFactory(em);
  }

  private static class MyRepositoryFactory&lt;T, I extends Serializable&gt;
    extends JpaRepositoryFactory {

    private final EntityManager em;

    public MyRepositoryFactory(EntityManager em) {

      super(em);
      this.em = em;
    }

    protected Object getTargetRepository(RepositoryMetadata metadata) {
      return new MyRepositoryImpl&lt;T, I&gt;((Class&lt;T&gt;) metadata.getDomainClass(), em);
    }

    protected Class&lt;?&gt; getRepositoryBaseClass(RepositoryMetadata metadata) {
      return MyRepositoryImpl.class;
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<div class="translateArticle">
      마침내, 커스텀 팩토리를 직접적으로 선언을 하거나, 스프링 네임스페이스의 <code>factory-class</code> 속성을 사용하거나 <code>@Enable…</code>어노테이션으로 repository 인프라스트럭쳐를 설정하여서, (마침내) 당신의 커스텀 팩토리 구현체를 사용하게 됩니다. 

     
    </div>
    <div class="originalArticle">
      Finally, either declare beans of the custom factory directly or use the <code>factory-class</code> attribute of the Spring namespace or <code>@Enable…</code> annotation to instruct the repository infrastructure to use your custom factory implementation.
    </div>  
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 25. 커스텀 팩토리와 네임스페이스 사용하기 Using the custom factory with the namespace
    </div>
    <div class="originalArticle">
      Example 25. Using the custom factory with the namespace
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;repositories base-package="com.acme.repository"
  factory-class="com.acme.MyRepositoryFactoryBean" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 26. <code>@Enable…</code> 어노테이션과 함께 커스텀 팩토리 사용하기
    </div>
    <div class="originalArticle">
      Example 26. Using the custom factory with the <code>@Enable…</code> annotation
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@EnableJpaRepositories(factoryClass = "com.acme.MyRepositoryFactoryBean")
class Config {}</code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="core.extensions"><a class="anchor" href="#core.extensions"></a> <div class="translateArticle">
      3.7. 스프링 데이터 익스텐션
    </div>
    <div class="originalArticle">
      3.7. Spring Data extensions
    </div>  </h3>


<div class="paragraph">
<p>    <div class="translateArticle">
      이 섹션문서는 스프링 데이터 익스텐션(확장)문서의 모음으로 스프링 데이터 익스텐션은 스프링 데이터의 사용을 다양한 context로써, 가능케 해줍니다. 현재는 대부분의 통합이 SpringMVC를 대상으로합니다. 
    </div>
    <div class="originalArticle">
      This section documents a set of Spring Data extensions that enable Spring Data usage in a variety of contexts. Currently most of the integration is targeted towards Spring MVC.
    </div>  

      </p>
</div>
<div class="sect3">
<h4 id="core.web"><a class="anchor" href="#core.web"></a>3.7.1. Web support</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
    <div class="translateArticle">
      이 섹션은 스프링 데이터 웹서포트를 위한 문서를 포함하며 스프링 데이터 웹서포트는 1.6 범위에서 스프링데이터 Commons로 구현되었습니다. 새롭게 소개된 지원이 꽤 많은 것들을 변화시켜서, 이전의 행동에 관한 문서를 우리는  <a href="#web.legacy">레거시 웹 지원</a>에 가지고 있습니다.  
    </div>
    <div class="originalArticle">
      This section contains the documentation for the Spring Data web support as it is implemented as of Spring Data Commons in the 1.6 range. As it the newly introduced support changes quite a lot of things we kept the documentation of the former behavior in <a href="#web.legacy">Legacy web support</a>.
    </div>  

      
</td>
</tr>
</table>


</div>
<div class="paragraph">
 <div class="translateArticle">
      <p>스프링 데이터 모듈은, 리파지토리 프로그래밍 모델을 지원하는 모듈이라면 다양한 방식의 웹지원을 가지고 있습니다. 
        웹관련 작업은 classpath의 SpringMVC JARs를 필요로 하며, 그들의 일부는 심지어 Spring Hateoas<span class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote.">2</a>]</span>를 제공하기도 합니다.  일반적으로 통합 지원은 자바설정클래스에서 <code>@EnableSpringDataWebSupport</code> 어노테이션을 사용함으로써 활성화됩니다. 
       </p>
     
    </div>
    <div class="originalArticle">
      <p>Spring Data modules ships with a variety of web support if the module supports the repository programming model. The web related stuff requires Spring MVC JARs on the classpath, some of them even provide integration with Spring HATEOAS <span class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote.">2</a>]</span>. In general, the integration support is enabled by using the <code>@EnableSpringDataWebSupport</code> annotation in your JavaConfig configuration class.</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 27. 스프링 데이터 웹지원 활성화 Enabling Spring Data web support
    </div>
    <div class="originalArticle">
      Example 27. Enabling Spring Data web support
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
@EnableSpringDataWebSupport
class WebConfiguration { }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p><code>@EnableSpringDataWebSupport</code> 어노테이션은 우리가 뒤에 나올 새로운 컴포넌트를 등록시킵니다. 
    이것은 클래스패스의 Spring HATEOAS를 감지하여서, hateoas가 있다면 통합 컴포넌트로써 등록을 시킵니다. </p>
    </div>
    <div class="originalArticle">
      <p>The <code>@EnableSpringDataWebSupport</code> annotation registers a few components we will discuss in a bit. It will also detect Spring HATEOAS on the classpath and register integration components for it as well if present.</p>
    </div>  

      
</div>
<div class="paragraph">
<p>    <div class="translateArticle">
  아니면 만약 당신이 XML설정을 쓴다면, <code>SpringDataWebSupport</code>나  <code>HateoasAwareSpringDataWebSupport</code>를 스프링 빈으로 등록합니다. 
    </div>
    <div class="originalArticle">
      Alternatively, if you are using XML configuration, register either <code>SpringDataWebSupport</code> or <code>HateoasAwareSpringDataWebSupport</code> as Spring beans:
    </div>  

      </p>
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 28. XML에서의 스프링 데이터 웹서포트 활성화 Enabling Spring Data web support in XML
    </div>
    <div class="originalArticle">
      Example 28. Enabling Spring Data web support in XML
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.data.web.config.SpringDataWebConfiguration" /&gt;

&lt;!-- If you're using Spring HATEOAS as well register this one *instead* of the former --&gt;
&lt;bean class="org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="core.web.basic"><a class="anchor" href="#core.web.basic"></a>기본 웹 지원</h5>
<div class="paragraph">
 <div class="translateArticle">
      위에 보이는 설정 셋업은 몇가지 기초 컴포넌트들을 등록할 것입니다
    </div>
    <div class="originalArticle">
      The configuration setup shown above will register a few basic components:
    </div>  
</div>
<div class="ulist">
<ul>
<li>
<p>    <div class="translateArticle">
      <code>DomainClassConverter</code> 는 SpringMVC 를 활성화시켜서 요청파라미터나 경로변수로부터 리파지토리 managed도메인클래스를 resolve합니다. 
    </div>
    <div class="originalArticle">
      A <code>DomainClassConverter</code> to enable Spring MVC to resolve instances of repository managed domain classes from request parameters or path variables.
    </div>  

      </p>
</li>
<li>
<p>    <div class="translateArticle">
      <code>HandlerMethodArgumentResolver</code> 는 스프링 MVC로 하여금 요청파라미터로부터 Pageable 과 Sort 인스턴스를 resolve하게 해줍니다. 
    </div>
    <div class="originalArticle">
      <code>HandlerMethodArgumentResolver</code> implementations to let Spring MVC resolve Pageable and Sort instances from request parameters.
    </div>  

      </p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="core.web.basic.domain-class-converter"><a class="anchor" href="#core.web.basic.domain-class-converter"></a>도메인 클래스 콘버터 : DomainClassConverter</h6>
<div class="paragraph">
 <div class="translateArticle">
      <code>DomainClassConverter</code>는 SpringMVC 컨트롤러 시그니처에서 직접적으로 도메인 타입을 사용하게 해줍니다. 그래서 당신은 수동적으로 리파지토리를 통해 인스턴스를 찾을 필요가 없습니다. 
    </div>
    <div class="originalArticle">
      The <code>DomainClassConverter</code> allows you to use domain types in your Spring MVC controller method signatures directly, so that you don&#8217;t have to manually lookup the instances via the repository:
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 29. 메소드 시그니처에서 도메인 타입을 사용하는 스프링 MVC 컨트롤러
    </div>
    <div class="originalArticle">
      Example 29. A Spring MVC controller using domain types in method signatures
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/users")
public class UserController {

  @RequestMapping("/{id}")
  public String showUserForm(@PathVariable("id") User user, Model model) {

    model.addAttribute("user", user);
    return "userForm";
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
   <div class="translateArticle">
      당신이 볼 수 있듯, 메소드가 유저 인스턴스를 직접적으로 받고 더 이상의 검색은 필요하지가 않습니다. 저 인스턴스는 SpringMVC가 경로변수를 도메인 클래스의 id타입으로 전환하게 하여, 결국 도메인 타입에 등록된 리파지토리에서 <code>findOne(…)</code>을 호출하게 합니다. 

      
    </div>
    <div class="originalArticle">
      As you can see the method receives a User instance directly and no further lookup is necessary. The instance can be resolved by letting Spring MVC convert the path variable into the id type of the domain class first and eventually access the instance through calling <code>findOne(…)</code> on the repository instance registered for the domain type.
    </div>  
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="translateArticle">
      현재 저 리파지토리는 <code>CrudRepository</code> 를 구현을 하여서 전환을 위한 자격을 얻어야 합니다 .
    </div>
    <div class="originalArticle">
      Currently the repository has to implement <code>CrudRepository</code> to be eligible to be discovered for conversion.
    </div>  
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="core.web.basic.paging-and-sorting"><a class="anchor" href="#core.web.basic.paging-and-sorting"></a><div class="translateArticle">
      페이지화와 정렬을 위한 HandlerMethodArgumentResolvers
    </div>
    <div class="originalArticle">
      HandlerMethodArgumentResolvers for Pageable and Sort
    </div>  </h6>
<div class="paragraph">
<div class="translateArticle">
      <p>위의 소스설정 일부는 또한 <code>PageableHandlerMethodArgumentResolver</code>를 등록하고 <code>SortHandlerMethodArgumentResolver</code>의 인스턴스를 등록합니다. 이 등록은 <code>Pageable</code> 과 <code>Sort</code>가 유효한 컨틀롤러 메소드 아규먼트가 되게 해줍니다 .</p>


    </div>
    <div class="originalArticle">
      <p>The configuration snippet above also registers a <code>PageableHandlerMethodArgumentResolver</code> as well as an instance of <code>SortHandlerMethodArgumentResolver</code>. The registration enables <code>Pageable</code> and <code>Sort</code> being valid controller method arguments</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
     예제 30. Pageable을 컨트롤러 메소드 아규먼트로 사용하기. Using Pageable as controller method argument
    </div>
    <div class="originalArticle">
      Example 30. Using Pageable as controller method argument
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/users")
public class UserController {

  @Autowired UserRepository repository;

  @RequestMapping
  public String showUsers(Model model, Pageable pageable) {

    model.addAttribute("users", repository.findAll(pageable));
    return "users";
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
     이 메소드 시그니처는 다음의 설정을 사용하여  스프링 MVC가 요청 파라미터로부터 Pageable 인스턴스를 만들어내게 시도합니다. 
    </div>
    <div class="originalArticle">
      This method signature will cause Spring MVC try to derive a Pageable instance from the request parameters using the following default configuration:
    </div>  

</div>
<table class="tableblock frame-all grid-all">
<caption class="title">표 1. Pageable 인스턴스를 위해 평가된 요청파라미터 Request parameters evaluated for Pageable instances</caption>
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>page</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">얻기 원하는 페이지, 0 indexed and 기본은 0.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">얻기 원하는 페이지 크기, 기본 20.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sort</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">다음의 형식으로 정렬될 형식 <code>property,property(,ASC|DESC)</code>. 기본 정렬 방향은 오름차순(asc). 만약 방향을 바꾸고 싶은 여러개의<code>sort</code> 파라미터가 있다면 다음과 같이.., e.g. <code>?sort=firstname&amp;sort=lastname,asc</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<div class="translateArticle">
      <p>
        이러한 행동을 커스터마이징 하고 싶다면   <code>@Enable</code>-어노테이션을 사용하는 대신에<code> SpringDataWebConfiguration</code>를 상속하거나 HATEOAS-활성화 같은 것을 하거나, <code>pageableResolver()</code>나<code>sortResolver()</code>메소드를 오버라이드하고 당신의 커스터마이징된 설정파일을 임포트하세요.

      </p>
    </div>
    <div class="originalArticle">
      <p>To customize this behavior extend either <code>SpringDataWebConfiguration</code> or the HATEOAS-enabled equivalent and override the <code>pageableResolver()</code> or <code>sortResolver()</code> methods and import your customized configuration file instead of using the <code>@Enable</code>-annotation.</p>
    </div>  

</div>
<div class="paragraph">
<div class="translateArticle">
      <p> 이러한 경우 당신은 여러개의 테이블을 위해서, 요청으로부터 여러개의 <code>Pageable</code> 나 <code>Sort</code> 인스턴스가 resolved되기를 필요로 할지도 모릅니다.  예를 들자면 당신은 스프링의  <code>@Qualifier</code>어노테이션을 사용하여 다른 것들끼리 구별을 할 수도 있습니다. 요청파라미터는 그러면 <code>${qualifier}_</code>로 prefixed됩니다. 그래서 메소드 시그니처가 다음과 같이 됩니다 : 
</p>
    </div>
    <div class="originalArticle">
      <p>In case you need multiple <code>Pageable</code> or <code>Sort</code> instances to be resolved from the request (for multiple tables, for example) you can use Spring&#8217;s <code>@Qualifier</code> annotation to distinguish one from another. The request parameters then have to be prefixed with <code>${qualifier}_</code>. So for a method signature like this:</p>
    </div>  
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public String showUsers(Model model,
      @Qualifier("foo") Pageable first,
      @Qualifier("bar") Pageable second) { … }</code></pre>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      당신은 <code>foo_page</code> 나 <code>bar_page</code>같은 것을 만들어낼 것입니다 .
    </div>
    <div class="originalArticle">
      you have to populate <code>foo_page</code> and <code>bar_page</code> etc.
    </div> 
</div>
<div class="paragraph">
<div class="translateArticle">
      메소드에 전해진 기본 <code>Pageable</code>  는  <code>new PageRequest(0, 20)</code>와 같습니다만, <code>Pageable</code>  파라미터에서 <code>@PageableDefaults</code> 어노테이션을 통해서 커스터마이징 될 수 있습니다. 
    </div>
    <div class="originalArticle">
      The default <code>Pageable</code> handed into the method is equivalent to a <code>new PageRequest(0, 20)</code> but can be customized using the <code>@PageableDefaults</code> annotation on the <code>Pageable</code> parameter.
    </div>  
</div>
</div>
</div>
<div class="sect4">
<h5 id="core.web.pageables"><a class="anchor" href="#core.web.pageables"></a>Hypermedia support for Pageables</h5>
<div class="paragraph">
<div class="translateArticle">
        Spring HATEOAS는 표현 모델 클래스 <code>PagedResources</code>를 가지고 있어서 <code>Page</code>인스턴스를, 필요한 <code>Page</code>메타데이터로 풍부하게 해줄 수 있을 뿐만 아니라, 링크가 클라이언트가 쉽게 페이지를 네비게이트하게 해줍니다. Page에서 <code>PagedResources</code>으로의 전환은 Spring HATEOAS  <code>ResourceAssembler</code> 인터페이스, <code>PagedResourcesAssembler</code>를 구현함으로써 이뤄집니다.

        </code>.
      </div>
      <div class="originalArticle">
        Spring HATEOAS ships with a representation model class <code>PagedResources</code> that allows enrichting the content of a <code>Page</code> instance with the necessary <code>Page</code> metadata as well as links to let the clients easily navigate the pages. The conversion of a Page to a <code>PagedResources</code> is done by an implementation of the Spring HATEOAS <code>ResourceAssembler</code> interface, the <code>PagedResourcesAssembler</code>.
      </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 31.PagedResourcesAssembler를 컨트롤러 메소드 아규먼트로 사용하기. Using a PagedResourcesAssembler as controller method argument
    </div>
    <div class="originalArticle">
      Example 31. Using a PagedResourcesAssembler as controller method argument
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Controller
class PersonController {

  @Autowired PersonRepository repository;

  @RequestMapping(value = "/persons", method = RequestMethod.GET)
  HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(Pageable pageable,
    PagedResourcesAssembler assembler) {

    Page&lt;Person&gt; persons = repository.findAll(pageable);
    return new ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK);
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>위 처럼  설정을 활성화하는 것은 <code>PagedResourcesAssembler</code>가 컨트롤러 메소드 아규먼트로 사용되게 해줍니다. 여기서 <code>toResources(…)</code> 를 호출하는 것은 다음과 같은 것을 발생하게 해줍니다 :  </p>
    </div>
    <div class="originalArticle">
      <p>Enabling the configuration as shown above allows the <code>PagedResourcesAssembler</code> to be used as controller method argument. Calling <code>toResources(…)</code> on it will cause the following:</p>
    </div>  
</div>
<div class="ulist">
<ul>
<li>
<div class="translateArticle">
      <code>Page</code>의 내용이  <code>PagedResources</code>인스턴스의 내용(content)이 되게 해줍니다 
    </div>
    <div class="originalArticle">
      The content of the <code>Page</code> will become the content of the <code>PagedResources</code> instance.
    </div> 
</li>
<div class="translateArticle">
      <li>

        <p><code>PagedResources</code>는, 동봉되어 채워진 정보와  함께 <code>PageMetadata</code> 인스턴스를 얻어서  <code>Page</code>와 기본 <code>PageRequest</code>를 형성합니다. </p>
</li>
<li>
<code>PagedResources</code>는 같이 있는 페이지의 상태에 따라 <code>prev</code>와 <code>next</code> 연결을 얻습니다.. 이 링크는 메소드실행이 연결된 URI를 가리키며, 그 메소드에 추가된 페이지네이션 파라미터는 <code>PageableHandlerMethodArgumentResolver</code>의 설정과 매칭이 되어 링크가 나중에 resolved되게 해줍니다. 



</li>

    </div>
    <div class="originalArticle">
      <li>
<p>The <code>PagedResources</code> will get a <code>PageMetadata</code> instance attached populated with information form the <code>Page</code> and the underlying <code>PageRequest</code>.</p>
</li>
<li>
<p>The <code>PagedResources</code> gets <code>prev</code> and <code>next</code> links attached depending on the page&#8217;s state. The links will point to the URI the method invoked is mapped to. The pagination parameters added to the method will match the setup of the <code>PageableHandlerMethodArgumentResolver</code> to make sure the links can be resolved later on.</p>
</li>

    </div>
</ul>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>우리가 30명의 인원 인스턴스를 데이터베이스에 가지고 있다고 해봅시다. 당신은 이제 <code>GET <a href="http://localhost:8080/persons" class="bare">http://localhost:8080/persons</a></code>요청을 해볼 것이고, 이러한 결과를 보게 될 것입니다 </p>
    </div>
    <div class="originalArticle">
      <p>Assume we have 30 Person instances in the database. You can now trigger a request <code>GET <a href="http://localhost:8080/persons" class="bare">http://localhost:8080/persons</a></code> and you&#8217;ll see something similar to this:</p>
    </div>  
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">{ "links" : [ { "rel" : "next",
                "href" : "http://localhost:8080/persons?page=1&amp;size=20 }
  ],
  "content" : [
     … // 20 Person instances rendered here
  ],
  "pageMetadata" : {
    "size" : 20,
    "totalElements" : 30,
    "totalPages" : 2,
    "number" : 0
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>
        당신은 정확한 URI를 만들어내고서, 기본 설정이 앞으로 들어오는 요청에 대해 파라미터를  <code>Pageable</code>로 resolve하는 것을 볼 수가 있습니다. 이것이 의미하는 바는 만약 당신이 저 설정을 바꾼다면 이 연결은 자동적으로 바뀔 것입니다. (역주 : 파라미터값이 바뀌면 page metadata도 바뀐다 이말인듯?) 기본적으로 assembler는 실행될 컨트롤러 메소드를 가리킵니다. 하지만 커스텀 <code>Link</code>를 제시하여 커스터마이징할 수 있고, <code>PagedResourcesAssembler.toResource(…)</code>의 메소드를 오버라이딩하여 페이지네이션 링크를 만드는 데 기반이 될 수 있습니다 .
      </p>
    </div>
    <div class="originalArticle">
      <p>You see that the assembler produced the correct URI and also picks up the default configuration present to resolve the parameters into a <code>Pageable</code> for an upcoming request. This means, if you change that configuration, the links will automatically adhere to the change. By default the assembler points to the controller method it was invoked in but that can be customized by handing in a custom <code>Link</code> to be used as base to build the pagination links to overloads of the <code>PagedResourcesAssembler.toResource(…)</code> method.</p>
    </div>  
</div>
</div>
</div>
<div class="sect3">
<h4 id="core.repository-populators"><a class="anchor" href="#core.repository-populators"></a>
      <div class="translateArticle">
        3.7.2. 레파지토리 생성자(popluators)
      </div>
      <div class="originalArticle">
        3.7.2. Repository populators
      </div>  
  </h4>
<div class="paragraph">

        <div class="translateArticle">
      <p>만약 당신이 Spring JDBC 모듈과 함께 작업한다면 당신은 아마 SQL 스크립트를 이용하는 <code>DataSource</code>를 생성하는데 익숙할 것입니다. 비슷한 추상화가 리파지토리 레벨에서 가능한데요. 비록 DDL로써 sql을 사용하지는 않습니다. 왜냐하면 sql은 저장소 의존적이기 때문이죠 . 그렇기 때문에 populator는 XML(스프링의 OXM추상화를 통해)과 JSON(Jackson을 통해)으로  repository에 생성할 데이터를 정의합니다. </p> 

        </div>
        <div class="originalArticle">
          <p>If you work with the Spring JDBC module, you probably are familiar with the support to populate a <code>DataSource</code> using SQL scripts. A similar abstraction is available on the repositories level, although it does not use SQL as the data definition language because it must be store-independent. Thus the populators support XML (through Spring&#8217;s OXM abstraction) and JSON (through Jackson) to define data with which to populate the repositories.</p>
        </div> 
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>당신이 <code>data.json</code> 파일을 다음과 같이 가지고 있다고 가정해봅시다 :</p>
    </div>
    <div class="originalArticle">
      <p>Assume you have a file <code>data.json</code> with the following content:</p>
    </div>  
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 32. JSON으로 정의된 데이터
    </div>
    <div class="originalArticle">
      Example 32. Data defined in JSON
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">[ { "_class" : "com.acme.Person",
 "firstname" : "Dave",
  "lastname" : "Matthews" },
  { "_class" : "com.acme.Person",
 "firstname" : "Carter",
  "lastname" : "Beauford" } ]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>
      당신은 Spring Data Commons 에서 제공하는 리파지토리 네임스페이스의 populator 요소를 사용하여서 당신의 리파지토리를 쉽게 populate할 수 있습니다. 이전의 data를 당신의 리파지토리에 populate하기 위해 다음과 같이 해보세요 : 
    </p>
    </div>
    <div class="originalArticle">
      <p>You can easily populate your repositories by using the populator elements of the repository namespace provided in Spring Data Commons. To populate the preceding data to your PersonRepository , do the following:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 33. Jackson Repository populator선언하기 Declaring a Jackson repository populator
    </div>
    <div class="originalArticle">
      Example 33. Declaring a Jackson repository populator
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:repository="http://www.springframework.org/schema/data/repository"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/repository
    http://www.springframework.org/schema/data/repository/spring-repository.xsd"&gt;

  &lt;repository:jackson-populator locations="classpath:data.json" /&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
        이 선언은 <code>data.json</code>이 읽혀져서 Jackson <code>ObjectMapper</code>를 통해 역직렬화 되게 해줍니다 .
    </div>
    <div class="originalArticle">
       This declaration causes the <code>data.json</code> file to
      be read and deserialized via a Jackson <code>ObjectMapper</code>.
    </div> 
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>JSON객체가 언마샬될 타입은 JSON문서의 <code>_class</code> 속성을 검사하면서 결정됩니다.  인프라스트럭쳐가 결국 적절한 리파지토리를 선택해서 막 역직렬화된 객체를 다룰 것입니다.  </p>
    </div>
    <div class="originalArticle">
      <p>The type to which the JSON object will be unmarshalled to will be determined by inspecting the <code>_class</code> attribute of the JSON document. The infrastructure will eventually select the appropriate repository to handle the object just deserialized.</p>
    </div>  
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>XML을 사용하여  리파지토리들을 채울 데이터를 정의하고 싶다면, 당신은 <code>unmarshaller-populator</code>요소를 사용할 수 있습니다. 당신은 SPRING OXM 공급자가 제공하는 XML marshaller 옵션 중의 하나를 사용하여서 설정을 할 수가 있습니다. <a href="{spring-framework-docs}/oxm.html">스프링 레퍼런스 가이드 문서를 </a>살펴보세요 (역주 : 번역문서라 링크가 깨짐.. { }뭐 이런 변수가 되있다보니;; ㅎㅎ )</p>


    </div>
    <div class="originalArticle">
      <p>To rather use XML to define the data the repositories shall be populated with, you can use the <code>unmarshaller-populator</code> element. You configure it to use one of the XML marshaller options Spring OXM provides you with. See the <a href="{spring-framework-docs}/oxm.html">Spring reference documentation</a> for details.</p>
    </div> 
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 34. 언마샬링 repository populator(JAXB를 사용한)을 선언하기
    </div>
    <div class="originalArticle">
      Example 34. Declaring an unmarshalling repository populator (using JAXB)
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:repository="http://www.springframework.org/schema/data/repository"
  xmlns:oxm="http://www.springframework.org/schema/oxm"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/repository
    http://www.springframework.org/schema/data/repository/spring-repository.xsd
    http://www.springframework.org/schema/oxm
    http://www.springframework.org/schema/oxm/spring-oxm.xsd"&gt;

  &lt;repository:unmarshaller-populator locations="classpath:data.json"
    unmarshaller-ref="unmarshaller" /&gt;

  &lt;oxm:jaxb2-marshaller contextPath="com.acme" /&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="web.legacy"><a class="anchor" href="#web.legacy"></a>    <div class="translateArticle">
      3.7.3. 레거시 웹 지원
    </div>
    <div class="originalArticle">
      3.7.3. Legacy web support
    </div>  

      </h4>
<div class="sect4">
<h5 id="web-domain-class-binding"><a class="anchor" href="#web-domain-class-binding"></a>
    <div class="translateArticle">
      스프링 MVC를 위한 도메인 클래스 웹 바인딩
    </div>
    <div class="originalArticle">
      Domain class web binding for Spring MVC
    </div>  

      
</h5>
<div class="paragraph">
<p>  <div class="translateArticle">
       당신이 SPRING MVC웹 어플리케이션으로 개발중이고 일반적으로 URL에서 도메인 클래스 id를 URL에서 resolve해야할 것입니다. 기본적으로 할일은 그 리퀘스트 파라미터나 URL의 부분을 도메인 클래스로 전달하여 하위 레이어로 전달하고 엔티티들에 대한 직접적인 비즈니스 로직을 수행해야 할 것입니다. 이것은 다음과 같이 보일 것입니다 : 
    </div>
    <div class="originalArticle">
      Given you are developing a Spring MVC web application you typically have to resolve domain class ids from URLs. By default your task is to transform that request parameter or URL part into the domain class to hand it to layers below then or execute business logic on the entities directly. This would look something like this:
    </div>  

      </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/users")
public class UserController {

  private final UserRepository userRepository;

  @Autowired
  public UserController(UserRepository userRepository) {
    Assert.notNull(repository, "Repository must not be null!");
    this.userRepository = userRepository;
  }

  @RequestMapping("/{id}")
  public String showUserForm(@PathVariable("id") Long id, Model model) {

    // Do null check for id
    User user = userRepository.findOne(id);
    // Do null check for user

    model.addAttribute("user", user);
    return "user";
  }
}</code></pre>
</div>
</div>

<div class="paragraph">
    <div class="translateArticle">
      <p>먼저 당신은 각각의 컨트롤러에 대한 각각의 의존선을 선언하여 컨트롤러나 repository에서 각자 엔티티들을 찾아야 합니다. 엔티티를 찾는 것은 또한 보일러플레이트한 작업이 될 수가 있으면 이것은 언제나 <code>findOne(…)</code> 을 호출합니다. 다행스럽게도 스프링은 <code>String</code>값을 무작위의 값으로 전환시킬수 있는 커스텀 컴포넌트를 등록하게 해주는 방법을 제공합니다. </p>
    </div>
    <div class="originalArticle">
      <p>First you declare a repository dependency for each controller to look up the entity managed by the controller or repository respectively. Looking up the entity is boilerplate as well, as it&#8217;s always a <code>findOne(…)</code> call. Fortunately Spring provides means to register custom components that allow conversion between a <code>String</code> value to an arbitrary type.</p>
    </div>  

      

</div>
<div class="sect5">
<h6 id="web.legacy.property-editors"><a class="anchor" href="#web.legacy.property-editors"></a>PropertyEditors</h6>
<div class="paragraph">
    <div class="translateArticle">
      <p>스프링 버젼 3.0 이전의 간단한 자바 <code>PropertyEditors</code> 가 사용되어졌었습니다. 이것과 통합하기 위해, 스프링 데이터는 <code>DomainClassPropertyEditorRegistrar</code>를 제공하며 이것은 <code>ApplicationContext</code> 에 등록된 모든 스프링 데이터 리파지토리들을 찾고, 관리되는 도메인 클래스들을 위해서  커스텀 <code>PropertyEditor</code>를 등록시킵니다. </p>
    </div>
    <div class="originalArticle">
      <p>For Spring versions before 3.0 simple Java <code>PropertyEditors</code> had to be used. To integrate with that, Spring Data offers a <code>DomainClassPropertyEditorRegistrar</code>, which looks up all Spring Data repositories registered in the <code>ApplicationContext</code> and registers a custom <code>PropertyEditor</code> for the managed domain class.</p>
    </div>  

      
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;bean class="….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt;
  &lt;property name="webBindingInitializer"&gt;
    &lt;bean class="….web.bind.support.ConfigurableWebBindingInitializer"&gt;
      &lt;property name="propertyEditorRegistrars"&gt;
        &lt;bean class="org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar" /&gt;
      &lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<div class="translateArticle">
      <p>만약 당신이 이전의 예제에서 SPRING MVC를 설정했다면, 당신은 당신의 컨트롤러를 다음과 같이 설정할 수 있으며, 많은 어수선한 부분과 보일러플레이트한 부분을 줄일 수가 있을 것입니다.  </p>
    </div>
    <div class="originalArticle">
     <p> If you have configured Spring MVC as in the preceding example, you can configure your controller as follows, which reduces a lot of the clutter and boilerplate.</p>
    </div> 
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/users")
public class UserController {

  @RequestMapping("/{id}")
  public String showUserForm(@PathVariable("id") User user, Model model) {

    model.addAttribute("user", user);
    return "userForm";
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="reference" class="sect0"><a class="anchor" href="#reference"></a>    <div class="translateArticle">
      레퍼런스 문서
    </div>
    <div class="originalArticle">
      Reference Documentation
    </div>  

      </h1>
<div class="sect1">
<h2 id="jpa.repositories"><a class="anchor" href="#jpa.repositories"></a>    <div class="translateArticle">
      4. JPA 리파지토리들
    </div>
    <div class="originalArticle">
      4. JPA Repositories
    </div>  

      </h2>
<div class="sectionbody">
<div class="paragraph">
    <div class="translateArticle">
      <p>이 챕터는 JPA 리파지토리지원에 대한 특별한 점들을 얘기해볼까합니다. 이것은 <a href="#repositories">Working with Spring Data Repositories</a>에서 설명했던 핵심 책임에서 시작합니다(빌드를 의역). 그러니, 저기서 설명한 기본 개념을 충분히 이해하시고 시작하겠습니다. </p>
    </div>
    <div class="originalArticle">
      <p>This chapter will point out the specialties for repository support for JPA. This builds on the core repository support explained in <a href="#repositories">Working with Spring Data Repositories</a>. So make sure you&#8217;ve got a sound understanding of the basic concepts explained there.</p>
    </div>  

      
</div>
<div class="sect2">
<h3 id="jpa.introduction"><a class="anchor" href="#jpa.introduction"></a>    <div class="translateArticle">
      4.1. 소개
    </div>
    <div class="originalArticle">
      4.1. Introduction
    </div>  

      </h3>
<div class="sect3">
<h4 id="jpa.namespace"><a class="anchor" href="#jpa.namespace"></a>    <div class="translateArticle">
      4.1.1. 스프링 네임스페이스
    </div>
    <div class="originalArticle">
      4.1.1. Spring namespace
    </div>  

      </h4>
<div class="paragraph">
    <div class="translateArticle">
      <p>스프링 데이터의 JPA모듈은 커스텀 네임스페이스를 가지고 있어서 리파지토리 빈을 정의하는 것을 허용합니다.이것은 또한 JPA에 좀 더 특별화되어있는 어떤 특징과, 요소 속성들을 포함하고 있습니다. 일반적으로 JPA리파지토리는  <code>repositories</code> 요소를 사용하여 설정가능합니다 :  </p>
    </div>
    <div class="originalArticle">
      <p>The JPA module of Spring Data contains a custom namespace that allows defining repository beans. It also contains certain features and element attributes that are special to JPA. Generally the JPA repositories can be set up using the <code>repositories</code> element:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 35. 네임스페이스를 사용하여 JPA 리파지토리들 설정하기
    </div>
    <div class="originalArticle">
      Example 35. Setting up JPA repositories using the namespace
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:jpa="http://www.springframework.org/schema/data/jpa"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/jpa
    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

  &lt;jpa:repositories base-package="com.acme.repositories" /&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>이 요소를 사용하여서, <a href="#repositories.create-instances">리파지토리 인스턴스 생성하기</a>에서 설명된 스프링 데이터 리파지토리들을 찾습니다. 그 뒤에서는(Beyond That) <code>@Repository</code>가 붙은 모든 빈에서는 영속 예외 전환이 활성화되어서 JPA 영속화 provider에 의해 던져지는 예외들은 스프링의 <code>DataAccessException</code> hierarchy로 전환되게 됩니다. </p>
    </div>
    <div class="originalArticle">
      <p>Using this element looks up Spring Data repositories as described in <a href="#repositories.create-instances">Creating repository instances</a>. Beyond that it activates persistence exception translation for all beans annotated with <code>@Repository</code> to let exceptions being thrown by the JPA persistence providers be converted into Spring&#8217;s <code>DataAccessException</code> hierarchy.</p>
    </div>  

      
</div>
<div class="sect4">
<h5 id="_custom_namespace_attributes"><a class="anchor" href="#_custom_namespace_attributes"></a>    <div class="translateArticle">
      커스텀 네임스페이스 속성
    </div>
    <div class="originalArticle">
      Custom namespace attributes
    </div>  

      </h5>
<div class="paragraph">
    <div class="translateArticle">
      <p><code>repositories</code> 요소 다음에  , JPA 네임스페이스는 repositories의 준비를 하며 세부적인 control 을 얻는 추가적인 속성을 제공합니다. :</p>
    </div>
    <div class="originalArticle">
      <p>Beyond the default attributes of the <code>repositories</code> element the JPA namespace offers additional attributes to gain more detailed control over the setup of the repositories:</p>
    </div>  

      
</div>
<table class="tableblock frame-all grid-all">
<caption class="title">    
    <div class="translateArticle">
      표2. 리파지토리 요소의 커스텀  JPA-특정 속성 
    </div>
    <div class="originalArticle">
      Table 2. Custom JPA-specific attributes of the repositories element
    </div>  
</caption>
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>entity-manager-factory-ref</code></p></td>
<td class="tableblock halign-left valign-top">   <div class="translateArticle">
  <p class="tableblock"> 
      명시적으로 <code>EntityManagerFactory</code>를 wire하면서, <code>repositories</code>요소에 의해 감지되는 리포지들과 함께 사용될 수 있습니다. 만약 여러개의 <code>EntityManagerFactory</code>빈이 어플리케이션이 사용될 때 보통 사용됩니다. 이것이 설정되어있지 않다면, 우리는 자동적으로 <code>EntityManagerFactory</code> 를 <code>ApplicationContext</code>에서 <code>entityManagerFactory</code>의 이름으로 찾습니다. </p>
    </p>
    </div>
    <div class="originalArticle">
       <p class="tableblock"> 
      Explicitly wire the <code>EntityManagerFactory</code> to be used with the repositories being detected by the <code>repositories</code> element. Usually used if multiple <code>EntityManagerFactory</code> beans are used within the application. If not configured we will automatically lookup the <code>EntityManagerFactory</code> bean with the name <code>entityManagerFactory</code> in the <code>ApplicationContext</code>.</p>

    </div>  

      </td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transaction-manager-ref</code></p></td>
<td class="tableblock halign-left valign-top">

     <div class="translateArticle">
      <p class="tableblock">
        <code>repositories</code>요소에 의해 감지되는 리파지도리들과 함께 사용되는  <code>PlatformTransactionManager</code>를 wire 합니다. 보통 여러개의 트랜잭션 매니저 와/아니면(and/or) <code>EntityManagerFactory</code>q빈이 설정되었을 때 필요로 합니다. 기본값은 현재 <code>ApplicationContext</code> 안에 정의된 단일  <code>PlatformTransactionManager</code>입니다. 
        </p>
     </div>
     <div class="originalArticle">
       <p class="tableblock">
        Explicitly wire the <code>PlatformTransactionManager</code> to be used with the repositories being detected by the <code>repositories</code> element. Usually only necessary if multiple transaction managers and/or <code>EntityManagerFactory</code> beans have been configured. Default to a single defined <code>PlatformTransactionManager</code> inside the current <code>ApplicationContext</code>.</p>
     </div>  
 
       

</td>
</tr>
</tbody>
</table>
<div class="paragraph">
    <div class="translateArticle">
      <p>  만약 어떠한 명시적 <code>transaction-manager-ref</code>가 정의되지 않았다면,  <code>transactionManager</code> 로 이름지어진 <code>PlatformTransactionManager</code>빈이 있어야한다는 것을 알아둡시다. 
      </p>
    </div>
    <div class="originalArticle">
      <p>Note that we require a <code>PlatformTransactionManager</code> bean named <code>transactionManager</code> to be present if no explicit <code>transaction-manager-ref</code> is defined.</p>
    </div>  

      
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.java-config"><a class="anchor" href="#jpa.java-config"></a>    <div class="translateArticle">
      4.1.2. 어노테이션 기반 설정
    </div>
    <div class="originalArticle">
      4.1.2. Annotation based configuration
    </div>  

      </h4>
<div class="paragraph">
    <div class="translateArticle">
      <p>스프링 데이터 리파지토리는 XML네임스페이스뿐만이 아니라 어노테이션 기반의 자바설정을 통해서도 설정을 지원합니다. </p>
    </div>
    <div class="originalArticle">
      <p>The Spring Data JPA repositories support cannot only be activated through an XML namespace but also using an annotation through JavaConfig.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 36. 자바설정을 이용한 스프링 데이터 JPA리자피토리 설정
    </div>
    <div class="originalArticle">
      Example 36. Spring Data JPA repositories using JavaConfig
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJpaRepositories
@EnableTransactionManagement
class ApplicationConfig {

  @Bean
  public DataSource dataSource() {

    EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();
    return builder.setType(EmbeddedDatabaseType.HSQL).build();
  }

  @Bean
  public EntityManagerFactory entityManagerFactory() {

    HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
    vendorAdapter.setGenerateDdl(true);

    LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();
    factory.setJpaVendorAdapter(vendorAdapter);
    factory.setPackagesToScan("com.acme.domain");
    factory.setDataSource(dataSource());
    factory.afterPropertiesSet();

    return factory.getObject();
  }

  @Bean
  public PlatformTransactionManager transactionManager() {

    JpaTransactionManager txManager = new JpaTransactionManager();
    txManager.setEntityManagerFactory(entityManagerFactory());
    return txManager;
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>방금 보여드린 설정 클래스는 spring-jdbc 의 <code>EmbeddedDatabaseBuilder</code> API 를 사용하여 내장 HSQL 데이터베이스를 설정합니다. 우리는 그 후에 <code>EntityManagerFactory</code>를 설정하고 Hinbernate 를 샘플 영속 provider로 사용합니다.  마지막 인프라스트럭쳐 컴포넌트는 여기서 <code>JpaTransactionManager</code>로 선언되었습니다. 
      우리는 마침내 Spring data jpa 리파지토리들을, XML 네임스페이스가 필수적으로 가지고 있는 속성과 같은 <code>@EnableJpaRepositories</code> 어노테이션을 사용하여 활성화시켰습니다. 
      </p>
    </div>
    <div class="originalArticle">
      <p>The just shown configuration class sets up an embedded HSQL database using the <code>EmbeddedDatabaseBuilder</code> API of spring-jdbc. We then set up a <code>EntityManagerFactory</code> and use Hibernate as sample persistence provider. The last infrastructure component declared here is the <code>JpaTransactionManager</code>. We finally activate Spring Data JPA repositories using the <code>@EnableJpaRepositories</code> annotation which essentially carries the same attributes as the XML namespace does. If no base package is configured it will use the one the configuration class resides in.</p>
    </div>  

      
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.entity-persistence"><a class="anchor" href="#jpa.entity-persistence"></a>    <div class="translateArticle">
      4.2. 엔티티들 영속화하기(Persisting)
    </div>
    <div class="originalArticle">
      4.2. Persisting entities
    </div>  

      </h3>
<div class="sect3">
<h4 id="jpa.entity-persistence.saving-entites"><a class="anchor" href="#jpa.entity-persistence.saving-entites"></a>    <div class="translateArticle">
      4.2.1. 엔티티들 저장하기(Saving)
    </div>
    <div class="originalArticle">
      4.2.1. Saving entities
    </div>  

      </h4>
<div class="paragraph">
    <div class="translateArticle">
      <p>엔티티를 저장하는 것은 <code>CrudRepository.save(…)</code>-메소드를 통해서 이뤄질 수 있습니다. 이것은  JPA <code>EntityManager</code>를 사용하여 주어진 엔티티를 persist하거나 merge할 것입니다. 만약에 엔티티가 아직 persisted되지 않았다면, 스프링 데이터 JPA는 <code>entityManager.persist(…)</code>메소드에 대한 호출을 통해, 엔티티를 저장할 것입니다. 그렇지 않으면 <code>entityManager.merge(…)</code>메소드가 호출될 것입니다. </p>
    </div>
    <div class="originalArticle">
      <p>Saving an entity can be performed via the <code>CrudRepository.save(…)</code>-Method. It will persist or merge the given entity using the underlying JPA <code>EntityManager</code>. If the entity has not been persisted yet Spring Data JPA will save the entity via a call to the <code>entityManager.persist(…)</code> method, otherwise the <code>entityManager.merge(…)</code> method will be called.</p>
    </div>  

      
</div>
<div class="sect4">
<h5 id="_entity_state_detection_strategies"><a class="anchor" href="#_entity_state_detection_strategies"></a>    <div class="translateArticle">
      엔티티 상태 감지 전략
    </div>
    <div class="originalArticle">
      Entity state detection strategies
    </div>  

      </h5>
<div class="paragraph">
    <div class="translateArticle">
        <p>스프링 데이터 JPA는 다음 전략을 사용하여서 엔티티가 새로운 것인지 아닌지 감지합니다 :</p>
    </div>
    <div class="originalArticle">
      <p>Spring Data JPA offers the following strategies to detect whether an entity is new or not:</p>
    </div>  

      
</div>
<table class="tableblock frame-all grid-all">
<caption class="title">    <div class="translateArticle">
      표3. 스프링 데이터 JPA 에서 엔티티가 새로운 것인지 아닌지 감지하는 것을 위한 옵션들
    </div>
    <div class="originalArticle">
      Table 3. Options for detection whether an entity is new in Spring Data JPA
    </div>  

      </caption>
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Id-Property inspection (<strong>default</strong>)</p></td>
<td class="tableblock halign-left valign-top">    <div class="translateArticle">
      <p class="tableblock">기본적으로 스프링 데이터 JPA에서는 주어진 엔티티의 식별자 속성을 검사를 합니다.(역주 : ID겠지..?) 만약 식별자 속성이 <code>null</code>이라면, 엔티티는 new 라고 가정될 것이고 그렇지 않으면 new가 아닙니다 . </p>
    </div>
    <div class="originalArticle">
      <p class="tableblock">By default Spring Data JPA inspects the identifier property of the given entity. If the identifier property is <code>null</code>, then the entity will be assumed as new, otherwise as not new.</p>
    </div>  

      </td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Implementing <code>Persistable</code></p></td>
<td class="tableblock halign-left valign-top">    <div class="translateArticle">
      <p class="tableblock">만약 엔티티가 <code>Persistable</code>을 구현한다면, Spring Data JPA 는 엔티티의  <code>isNew(…)</code>메소드에게 새로운 감지를 위임할 것입니다.세부사항은 <a href="http://docs.spring.io/spring-data/data-commons/docs/current/api/index.html?org/springframework/data/domain/Persistable.html">JavaDoc</a>을 보시길 바랍니다..</p>
    </div>
    <div class="originalArticle">
      <p class="tableblock">If an entity implements <code>Persistable</code>, Spring Data JPA will delegate the new detection to the <code>isNew(…)</code> method of the entity. See the <a href="http://docs.spring.io/spring-data/data-commons/docs/current/api/index.html?org/springframework/data/domain/Persistable.html">JavaDoc</a> for details.</p>
    </div>  

      </td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Implementing <code>EntityInformation</code></p></td>
<td class="tableblock halign-left valign-top">    <div class="translateArticle">
      <p class="tableblock">당신은  <code>JpaRepositoryFactory</code>의 하위클래스를 생성하고 <code>getEntityInformation(…)</code>메소드를 오버라이딩함으로써, <code>SimpleJpaRepository</code>구현체에서 쓰이는 <code>EntityInformation</code> 추상화를 커스터마이징 할 수가 있습니다. 

        그리고 당신은 <code>JpaRepositoryFactory</code>의 커스텀 구현체를 스프링 빈으로 등록해야 합니다. 이것은 거의 필요로 하지 않는 다는 것을 알아둡시다. 더 많은 정보가 필요로 하면 <a href="http://docs.spring.io/spring-data/data-jpa/docs/current/api/index.html?org/springframework/data/jpa/repository/support/JpaRepositoryFactory.html">JavaDoc</a>을 봅시다. 
      </p>

        
    </div>
    <div class="originalArticle">
      <p class="tableblock">You can customize the <code>EntityInformation</code> abstraction used in the <code>SimpleJpaRepository</code> implementation by creating a subclass of <code>JpaRepositoryFactory</code> and overriding the <code>getEntityInformation(…)</code> method accordingly. You then have to register the custom implementation of <code>JpaRepositoryFactory</code> as a Spring bean. Note that this should be rarely necessary. See the <a href="http://docs.spring.io/spring-data/data-jpa/docs/current/api/index.html?org/springframework/data/jpa/repository/support/JpaRepositoryFactory.html">JavaDoc</a> for details.</p>
    </div>  

      </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.query-methods"><a class="anchor" href="#jpa.query-methods"></a>    <div class="translateArticle">
      4.3. 쿼리 메소드들
    </div>
    <div class="originalArticle">
      4.3. Query methods
    </div>  

      </h3>
<div class="sect3">
<h4 id="jpa.sample-app.finders.strategies"><a class="anchor" href="#jpa.sample-app.finders.strategies"></a>    <div class="translateArticle">
      4.3.1. 쿼리 탐색 전략
    </div>
    <div class="originalArticle">
      4.3.1. Query lookup strategies
    </div>  

      </h4>
<div class="paragraph">
    <div class="translateArticle">
      <p>JPA 모듈은 쿼리를 수동으로 문자열이나, 메소드네임에서 유추하는 방식으로 정의하는 것을 지원합니다. </p>
    </div>
    <div class="originalArticle">
      <p>The JPA module supports defining a query manually as String or have it being derived from the method name.</p>
    </div>  

      
</div>
<div class="sect4">
<h5 id="_declared_queries"><a class="anchor" href="#_declared_queries"></a>    <div class="translateArticle">
      쿼리들 선언
    </div>
    <div class="originalArticle">
      Declared queries
    </div>  

      </h5>
<div class="paragraph">
    <div class="translateArticle">
      <p>비록 메소드 네임으로 쿼리를 얻는 것이 편리하지만, 어떤 경우에는 메소드네임 파서가 사용하고자 하는 키워드를 지원하지 않거나,  메소드 네임이 불필요하게 보기 불편해질 때가 있을 것입니다. 그럴때 당신은 JPA named qeury 를 사용하거나(더 많은 정보는 <a href="#jpa.query-methods.named-queries">Using JPA NamedQueries</a>를 참조 ) 당신의 쿼리 메소드에 <code>@Query</code>어노테이션을 붙일 수도 있을 것입니다.(더 많은 정보 : <a href="#jpa.query-methods.at-query">Using @Query</a> 참조) </p>
    </div>
    <div class="originalArticle">
      <p>Although getting a query derived from the method name is quite convenient, one might face the situation in which either the method name parser does not support the keyword one wants to use or the method name would get unnecessarily ugly. So you can either use JPA named queries through a naming convention (see <a href="#jpa.query-methods.named-queries">Using JPA NamedQueries</a> for more information) or rather annotate your query method with <code>@Query</code> (see <a href="#jpa.query-methods.at-query">Using @Query</a> for details).</p>
    </div>  

      
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query-methods.query-creation"><a class="anchor" href="#jpa.query-methods.query-creation"></a>    <div class="translateArticle">
      4.3.2. 쿼리 생성
    </div>
    <div class="originalArticle">
      4.3.2. Query creation
    </div>  

      </h4>
<div class="paragraph">
    <div class="translateArticle">
      <p>일반적으로 JPA 에서 동작하는 쿼리 생성 메커니즘은 <a href="#repositories.query-methods">쿼리메소드</a> - 여기에 설명되어있습니다. 여기 JPA 쿼리 메소드 변환이 이뤄지는 짧은 예제가 있습니다. : </p>
    </div>
    <div class="originalArticle">
      <p>Generally the query creation mechanism for JPA works as described in <a href="#repositories.query-methods">Query methods</a>. Here&#8217;s a short example of what a JPA query method translates into:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 37. 메소드 이름으로 쿼리 생성
    </div>
    <div class="originalArticle">
      Example 37. Query creation from method names
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>public interface UserRepository extends Repository&lt;User, Long&gt; {

  List&lt;User&gt; findByEmailAddressAndLastname(String emailAddress, String lastname);
}</pre>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> 우리는 여기서 JPA 크리테리아 API를 이용하여서 쿼리를 생성할 것입니다. 하지만 기본적으로 이 전환은 다음 쿼리로 될 것입니다. <code>select u from User u where u.emailAddress = ?1 and u.lastname = ?2</code>. 스프링 데이터 JPA는 프로퍼티 검사를 할 것이며  <a href="#repositories.query-methods.query-property-expressions">Property expressions</a>에 설명된 중첩 프로퍼티들을 횡단(역주: 횡단 검사한다. 필드를 짜맞춰본다 이런뜻인듯하다. )해볼 것입니다. 여기에 JPA를 위해 지원되는 키워드들에 대한 오버뷰와 기본적으로 전환되는 키워드들을 포함하고 있는 메소드에 대한 오버뷰가 나옵니다. </p>
    </div>
    <div class="originalArticle">
      <p>We will create a query using the JPA criteria API from this but essentially this translates into the following query: <code>select u from User u where u.emailAddress = ?1 and u.lastname = ?2</code>. Spring Data JPA will do a property check and traverse nested properties as described in <a href="#repositories.query-methods.query-property-expressions">Property expressions</a>. Here&#8217;s an overview of the keywords supported for JPA and what a method containing that keyword essentially translates to.</p>
    </div>  

      
</div>
</div>
</div>
<table class="tableblock frame-all grid-all">
<caption class="title">    <div class="translateArticle">
      표 4. 메소드 이름 안에서 지원되는 키워드들
    </div>
    <div class="originalArticle">
      Table 4. Supported keywords inside method names
    </div>  

      </caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Keyword</th>
<th class="tableblock halign-left valign-top">Sample</th>
<th class="tableblock halign-left valign-top">JPQL snippet</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>And</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByLastnameAndFirstname</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.lastname = ?1 and x.firstname = ?2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Or</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByLastnameOrFirstname</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.lastname = ?1 or x.firstname = ?2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Is,Equals</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstname</code>,<code>findByFirstnameIs</code>,<code>findByFirstnameEquals</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname = 1?</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Between</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByStartDateBetween</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.startDate between 1? and ?2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeLessThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &lt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeLessThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &#8656; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeGreaterThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &gt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeGreaterThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &gt;= ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>After</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByStartDateAfter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.startDate &gt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Before</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByStartDateBefore</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.startDate &lt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsNull</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeIsNull</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age is null</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsNotNull,NotNull</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAge(Is)NotNull</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age not null</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Like</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameLike</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotLike</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameNotLike</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname not like ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StartingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameStartingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code> (parameter bound with appended <code>%</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EndingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameEndingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code> (parameter bound with prepended <code>%</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Containing</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameContaining</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code> (parameter bound wrapped in <code>%</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OrderBy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeOrderByLastnameDesc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age = ?1 order by x.lastname desc</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Not</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByLastnameNot</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.lastname &lt;&gt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>In</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeIn(Collection&lt;Age&gt; ages)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age in ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotIn</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeNotIn(Collection&lt;Age&gt; age)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age not in ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>True</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByActiveTrue()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.active = true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>False</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByActiveFalse()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.active = false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IgnoreCase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameIgnoreCase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where UPPER(x.firstame) = UPPER(?1)</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
    <div class="translateArticle">
      <p><code>In</code> 이나 <code>NotIn</code>은 또한 <code>Collection</code>의 하위클래스를 받거나 배열, 가변인자들을 받을 수 있습니다. 같은 논리적 연산 검사에 대한 다른 문법적인 내용들은 <a href="#repository-query-keywords">Repository query keywords</a>를 보시길 바랍니다..</p>
    </div>
    <div class="originalArticle">
      <p><code>In</code> and <code>NotIn</code> also take any subclass of <code>Collection</code> as parameter as well as arrays or varargs. For other syntactical versions of the very same logical operator check <a href="#repository-query-keywords">Repository query keywords</a>.</p>
    </div>  

      
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query-methods.named-queries"><a class="anchor" href="#jpa.query-methods.named-queries"></a>    <div class="translateArticle">
      4.3.3. JPA NamedQuery들 사용하기
    </div>
    <div class="originalArticle">
      4.3.3. Using JPA NamedQueries
    </div>  

      </h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
    <div class="translateArticle">
      <p> 이 예제는 간단하게  <code>&lt;named-query /&gt;</code>요소와 <code>@NamedQuery</code>어노테이션을 사용합니다. 이 설정 요소들을 위한 쿼리는 JPA 쿼리 언어로 정의되어야 합니다. 물론 당신은 <code>&lt;named-native-query /&gt;</code>나 <code>@NamedNativeQuery</code>또한 사용할 수 있습니다. 이러한 요소들은 데이터베이스 플랫폼 독립성을 잃으면서 ,  native SQL 문법을 사용하게 합니다. 
    </p>
    </div>
    <div class="originalArticle">
      <p>The examples use simple <code>&lt;named-query /&gt;</code> element and <code>@NamedQuery</code> annotation. The queries for these configuration elements have to be defined in JPA query language. Of course you can use <code>&lt;named-native-query /&gt;</code> or <code>@NamedNativeQuery</code> too. These elements allow you to define the query in native SQL by losing the database platform independence.</p>
    </div>  

      
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_xml_named_query_definition"><a class="anchor" href="#_xml_named_query_definition"></a>    <div class="translateArticle">
      XML named query 정의
    </div>
    <div class="originalArticle">
      XML named query definition
    </div>  

      </h5>
<div class="paragraph">
    <div class="translateArticle">
      <p> XML 설정을 단순히 사용하기 위해서 필요한 <code>&lt;named-query /&gt;</code> 요소를 클래스패스의 <code>META-INF</code>내에 위치한 <code>orm.xml</code> JPA 설정 파일에 넣어주세요. named query들의 자동적인 실행이 이름 컨벤션에 의해서 활성화됩니다. 더 많은 정보는 다음과 같습니다. 
        

      </p>
    </div>
    <div class="originalArticle">
      <p>To use XML configuration simply add the necessary <code>&lt;named-query /&gt;</code> element to the <code>orm.xml</code> JPA configuration file located in <code>META-INF</code> folder of your classpath. Automatic invocation of named queries is enabled by using some defined naming convention. For more details see below.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 38. XML 네임드 쿼리 설정
    </div>
    <div class="originalArticle">
      Example 38. XML named query configuration
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;named-query name="User.findByLastname"&gt;
  &lt;query&gt;select u from User u where u.lastname = ?1&lt;/query&gt;
&lt;/named-query&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>당신이 보듯이 query 는 런타임에서 resolve 되는데 사용되는 특수한 이름을 가지고 있어야 합니다. </p>
    </div>
    <div class="originalArticle">
      <p>As you can see the query has a special name which will be used to resolve it at runtime.</p>
    </div>  

      
</div>
</div>
<div class="sect4">
<h5 id="_annotation_configuration"><a class="anchor" href="#_annotation_configuration"></a>    <div class="translateArticle">
      어노테이션 설정
    </div>
    <div class="originalArticle">
      Annotation configuration
    </div>  

      </h5>
<div class="paragraph">
    <div class="translateArticle">
      <p>어노테이션 설정은 (아마 유지보수 비용이 줄어들 것같은) 다른 설정 파일이 필요하지 않다는 장점이 있습니다. 당신은 그러한 장점을 위해서, 각각의 새로운 쿼리 선언을 할 때마다 당신의 도메인 클래스를 재컴파일 해줄 필요가 있습니다.  </p>
    </div>
    <div class="originalArticle">
      <p>Annotation configuration has the advantage of not needing another configuration file to be edited, probably lowering maintenance costs. You pay for that benefit by the need to recompile your domain class for every new query declaration.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      예제 39. 어노테이션 기반의 named query 설정
    </div>
    <div class="originalArticle">
      Example 39. Annotation based named query configuration
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@NamedQuery(name = "User.findByEmailAddress",
  query = "select u from User u where u.emailAddress = ?1")
public class User {

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_declaring_interfaces"><a class="anchor" href="#_declaring_interfaces"></a>    <div class="translateArticle">
      인터페이스들 선언하기
    </div>
    <div class="originalArticle">
      Declaring interfaces
    </div>  

      </h5>
<div class="paragraph">
    <div class="translateArticle">
      <p>이러한 named query 를 실행하기 위해서는 당신이 해야할 것은 <code>UserRepository</code>에 다음과 같이 명시해주는 것입니다. : </p>
    </div>
    <div class="originalArticle">
      <p>To allow execution of these named queries all you need to do is to specify the <code>UserRepository</code> as follows:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 40. UserRepository 에 선언된 쿼리 메소드
    </div>
    <div class="originalArticle">
      Example 40. Query method declaration in UserRepository
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  List&lt;User&gt; findByLastname(String lastname);

  User findByEmailAddress(String emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>스프링 데이터는 이러한 namedquery에 대한 메소드들의 호출을 해석할 것입니다. 설정된 도메인 클래스의 간단한 이름과 함께 시작하기 위해, 다음의 메소드 이름은 dot(.)으로 분리됩니다. 그래서 여기의 예제에서는 메소드 이름으로 쿼리를 만드는 대신에 위의 정의된 named query를 사용하였습니다.</p>
    </div>
    <div class="originalArticle">
      <p>Spring Data will try to resolve a call to these methods to a named query, starting with the simple name of the configured domain class, followed by the method name separated by a dot. So the example here would use the named queries defined above instead of trying to create a query from the method name.</p>
    </div>  

      
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query-methods.at-query"><a class="anchor" href="#jpa.query-methods.at-query"></a>    <div class="translateArticle">
      4.3.4. @Query 사용하기
    </div>
    <div class="originalArticle">
      4.3.4. Using @Query
    </div>  

      </h4>
<div class="paragraph">
    <div class="translateArticle">
      <p> 엔티티들을 위해서 쿼리들을 선언하는 named 쿼리를 사용하는 것은 적은 수의 쿼리들에 대해 잘 동작하는 유효한 접근입니다. 쿼리 그들 스스로가 그들을 실행하는 자바메소드로 묶이는데, 당신은 실제적으로 Spring data jpa의 <code>@Query</code>메소드들 통해서 그들을 도메인 클래스에 어노테이션 하지 않고 직접적으로 바인딩할수가 있습니다. 

      이것은 도메인 클래스에서 영속 특징을 가진 정보를 없애게 해주며, 쿼리를 리파지토리 인터페이스근처로 위치하게 해줍니다. 
       </p>
    </div>
    <div class="originalArticle">
      <p>Using named queries to declare queries for entities is a valid approach and works fine for a small number of queries. As the queries themselves are tied to the Java method that executes them you actually can bind them directly using the Spring Data JPA <code>@Query</code> annotation rather than annotating them to the domain class. This will free the domain class from persistence specific information and co-locate the query to the repository interface.</p>
    </div>  

      
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> query method에 어노테이션된 쿼리들은 <code>@NamedQuery</code>나  <code>orm.xml</code>에 선언된 namedquery 에 비해서 우선시(precendence)됩니다. </p>
    </div>
    <div class="originalArticle">
      <p>Queries annotated to the query method will take precedence over queries defined using <code>@NamedQuery</code> or named queries declared in <code>orm.xml</code>.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 41. @Query를 사용하여서 쿼리메소드에 쿼리 선언하기 
    </div>
    <div class="originalArticle">
      Example 41. Declare query at the query method using @Query
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query("select u from User u where u.emailAddress = ?1")
  User findByEmailAddress(String emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> <code>LIKE</code>같이 advanced한 표현을 사용해볼까요.  수동적으로 @Query를 사용해 정의된 쿼리를 위한, 쿼리 실행 메커니즘은 쿼리 정의 내에서 <code>LIKE</code> 표현의 정의를 허용합니다.  (역주 : 영어표현에 군살이 많은데 그걸 그대로 옮겨적으면서 하다보니 보일러 플레이트한^^; 표현이 많은 것같기도 한 느낌이 듭니다. 가끔 주어없는 문장도 나오고, 오타도 있고 뭐..번역하기 애매한.. 그런것도 많아요.. 그냥 번역하다가 궁시렁 궁시렁 해봅니다.)
      </p>
    </div>
    <div class="originalArticle">
      <p>Using advanced <code>LIKE</code> expressionsThe query execution mechanism for manually defined queries using @Query allow the definition of advanced <code>LIKE</code> expressions inside the query definition.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 42. @Query 내에서 like같은 고급 표현 
    </div>
    <div class="originalArticle">
      Example 42. Advanced like-expressions in @Query
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query("select u from User u where u.firstname like %?1")
  List&lt;User&gt; findByFirstnameEndsWith(String firstname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> 
        방금전에 본 <code>LIKE</code>  구별자 문자  <code>%</code>가 인식이 되면서, 유효한 JPQL쿼리(<code>%</code>를 삭제하면서)로 변형되는 쿼리가 되게 됩니다. 쿼리 실행동안 메소드 호출쪽에 전해지는, 파라미터가 전에 인식된 <code>LIKE</code>패턴에 아규먼트화됩니다. (역주 : 파라미터가 like쪽에 간다. 이말인듯 ;; )

      </p>
    </div>
    <div class="originalArticle">
      <p>In the just shown sample <code>LIKE</code> delimiter character <code>%</code> is recognized and the query transformed into a valid JPQL query (removing the <code>%</code>). Upon query execution the parameter handed into the method call gets augmented with the previously recognized <code>LIKE</code> pattern.</p>
    </div>  

      
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> 네이티브 쿼리들. <code>@Query</code> 어노테이션은 <code>nativeQuery</code>를 true로 설정해서 네이티브 쿼리의 실행을 허용합니다. 우리는 현재 네이티브 쿼리를 위한 페이지네이션과 동적 정렬을 지원하지 않는다는 것을 알아둡시다. 
        (우리가 실제 선언된 쿼리를 만들어야하고, 우리는 Native SQL에 확실하게 이것-동적정렬, 페이징을 할수 없기 때문에 )
      </p>
    </div>
    <div class="originalArticle">
      <p>Native queriesThe <code>@Query</code> annotation allows to execute native queries by setting the <code>nativeQuery</code> flag to true. Note, that we currently don&#8217;t support execution of pagination or dynamic sorting for native queries as we&#8217;d have to manipulate the actual query declared and we cannot do this reliably for native SQL.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 43. @Query를 사용하여 쿼리 메소드에서 네이티브 쿼리 선언하기
    </div>
    <div class="originalArticle">
      Example 43. Declare a native query at the query method using @Query
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query(value = "SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?0", nativeQuery = true)
  User findByEmailAddress(String emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.named-parameters"><a class="anchor" href="#jpa.named-parameters"></a>4.3.5. Using named parameters</h4>
<div class="paragraph">
    <div class="translateArticle">
      <p>
        기본적으로 Spring Data JPA 는 예전의 샘플에서도 설명했듯이, 파라미터 바인딩에 기반한 포지션을 사용합니다. 
        이것은 파라미터 포지션에 대해서 쿼리 메소드가 리팩토링해야할 작은 에러들을 만들기 쉽게 합니다. 이것을 해결하기 위해서 당신은 <code>@Param</code> 어노테이션을 이용하여서, 메소드 파라미터에 구체적인 이름을 주고 쿼리에 그 이름으로 바인딩시킬 수가 있습니다. 
      </p>
    </div>
    <div class="originalArticle">
      <p>By default Spring Data JPA will use position based parameter binding as described in all the samples above. This makes query methods a little error prone to refactoring regarding the parameter position. To solve this issue you can use <code>@Param</code> annotation to give a method parameter a concrete name and bind the name in the query.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 44. named parameter 이용하기
    </div>
    <div class="originalArticle">
      Example 44. Using named parameters
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query("select u from User u where u.firstname = :firstname or u.lastname = :lastname")
  User findByLastnameOrFirstname(@Param("lastname") String lastname,
                                 @Param("firstname") String firstname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>
        정의된 쿼리의 발생에 따라 메소드 파라미터가 교환됩니다. 
      </p>
    </div>
    <div class="originalArticle">
      <p>Note that the method parameters are switched according to the occurrence in the query defined.</p>
    </div>  

      
</div>
</div>
<div class="sect3">
<h4 id="jpa.query.spel-expressions"><a class="anchor" href="#jpa.query.spel-expressions"></a>    <div class="translateArticle">
      4.3.6. SpEL 표현 사용하기
    </div>
    <div class="originalArticle">
      4.3.6. Using SpEL expressions
    </div>  

      </h4>
<div class="paragraph">
    <div class="translateArticle">
      <p> Spring data 1.4 버젼부터 우리는 제한된 SpEL템플릿 표현을 <code>@Query</code>를 통해서 수동으로 정해진 쿼리에, 사용할 수 있게 하였습니다. 쿼리가 실행되면서 이러한 표현들은 미리 정의된 변수들의 집합에 대하여 평가됩니다. 우리는 수동쿼리에서 사용될 다음 변수들의 리스트를 지원합니다. 
      </p>
    </div>
    <div class="originalArticle">
      <p>As of Spring Data JPA release 1.4 we support the usage of restricted SpEL template expressions in manually defined queries via <code>@Query</code>. Upon query execution these expressions are evaluated against a predefined set of variables. We support the following list of variables to be used in a manual query.</p>
    </div>  

      
</div>
<table class="tableblock frame-all grid-all">
<caption class="title">    <div class="translateArticle">
      Table 5. 쿼리 템플릿 기반에서 SpEL 안의 지원되는 변수들
    </div>
    <div class="originalArticle">
      Table 5. Supported variables inside SpEL based query templates
    </div>  

      </caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
   
<th class="tableblock halign-left valign-top">변수</th>
<th class="tableblock halign-left valign-top">사용</th>
<th class="tableblock halign-left valign-top">설명</th>
    


      
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>entityName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>select x from #{#entityName} x</code></p></td>
<td class="tableblock halign-left valign-top">    

    <div class="translateArticle">
      <p class="tableblock"> 주어진 repository에 관련된 도메인 타입의 <code>entityName</code> 를 삽입하세요. <code>entityName</code>는 다음과 같이 해석됩니다 : 
        
      만약 <code>@Entity</code>어노테이션에서 도메인 타입 이름을 정한다면 , 그것은 사용될 것입니다. 
      그렇지 않으면 도메인 타입의 간단한  class-name이 사용될 것입니다. (역주: 그냥 뒤의 예제들을 조금 살펴보자^^; )</p>
    </div>
    <div class="originalArticle">
      <p class="tableblock">Inserts the <code>entityName</code> of the domain type associated with the given Repository. The <code>entityName</code> is resolved as follows: If the domain type has set the name property on the <code>@Entity</code> annotation then it will be used. Otherwise the simple class-name of the domain type will be used.</p>
    </div>  

      </td>
</tr>
</tbody>
</table>
<div class="paragraph">
    <div class="translateArticle">
      <p> 다음 예제는 쿼리 문자열에서 <code>#{#entityName}</code> 표현의 사용 예제를 하나 보여줍니다. (일부러 짧은 표현 쓰다.) <code>@Query</code>어노테이션의 쿼리 문자열에서 실제적인 엔티티 이름을 기술하지 않기 위해서 <code>#{#entityName}</code>변수를 쓴 것입니다. </p>
    </div>
    <div class="originalArticle">
      <p>The following example demonstrates one use case for the <code>#{#entityName}</code> expression in a query string where you want to define a repository interface with a query method with a manually defined query. In order not to have to state the actual entity name in the query string of a <code>@Query</code> annotation one can use the <code>#{#entityName}</code> Variable.</p>
    </div>  

      
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
    <div class="translateArticle">
      <p><code>entityName</code>은 <code>@Entity</code>어노테이션을 통해 커스터마이징 됩니다. <code>orm.xml</code>를 통한 커스텀화는 SpEL표현에서 지원되지 않습니다.  </p>
    </div>
    <div class="originalArticle">
      <p>The <code>entityName</code> can be customized via the <code>@Entity</code> annotation. Customizations via <code>orm.xml</code> are not supported for the SpEL expressions.</p>
    </div>  

      
</div>
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 45. entityName - 리파지토리 쿼리 메소드에서 SpEl표현을 사용하기
    </div>
    <div class="originalArticle">
      Example 45. Using SpEL expressions in repository query methods - entityName
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
public class User {

  @Id
  @GeneratedValue
  Long id;

  String lastname;
}

public interface UserRepository extends JpaRepository&lt;User,Long&gt; {

  @Query("select u from #{#entityName} u where u.lastname = ?1")
  List&lt;User&gt; findByLastname(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> 물론 당신은 쿼리 선언에서 직접적으로 User 를 직접적으로 사용했을 것입니다만 이것은 쿼리를 변경할 것을 요구합니다.(역주: 나중에 변경한다는 얘기인듯?).. <code>#entityName</code>는 미래에 잠재적으로, 다른 엔티티 이름을 가지는(예를 들자면 <code>@Entity(name = "MyUser"를 사용하는)</code> User클래스의 재매핑을 선택합니다.   </p>
    </div>
    <div class="originalArticle">
      <p>Of course you could have just used User in the query declaration directly but that would require you to change the query as well. The reference to <code>#entityName</code> will pick up potential future remappings of the User class to a different entity name (e.g. by using <code>@Entity(name = "MyUser")</code>.</p>
    </div>  

      
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>
        쿼리 문자열에서 다른 <code>#{#entityName}</code> 표현의 유스케이스는, 만약 당신이 제너릭 리파지토리 인터페이스를 구체적인 도메인 타입을 가진 특별화된 리파지토리 인터페이스와 같이 사용하고 싶을 때입니다.  
        
        구체적인 인터페이스에서 커스텀 쿼리 메소드들의 반복적인 정의를 피하기 위해, 당신은 제너릭 리파지토리 인터페이스의 <code>@Query</code>어노테이션의, 쿼리문자열에서- 엔티티네임 표현을  사용할 수가 있습니다. 
      </p>
    </div>
    <div class="originalArticle">
      <p>Another use case for the <code>#{#entityName}</code> expression in a query string is if you want to define a generic repository interface with specialized repository interfaces for a concrete domain type. 

        In order not to have to repeat the definition of custom query methods on the concrete interfaces 

        you can use the entity name expression in the query string of the <code>@Query</code> annotation in the generic repository interface.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 46. SpEL 표현을 리파지토리 쿼리 메소드에서 사용하기 - entityName with inheritance
    </div>
    <div class="originalArticle">
      Example 46. Using SpEL expressions in repository query methods - entityName with inheritance
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@MappedSuperclass
public abstract class AbstractMappedType {
  …
  String attribute
}

@Entity
public class ConcreteType extends AbstractMappedType { … }

@NoRepositoryBean
public interface MappedTypeRepository&lt;T extends AbstractMappedType&gt;
  extends Repository&lt;T, Long&gt; {

  @Query("select t from #{#entityName} t where t.attribute = ?1")
  List&lt;T&gt; findAllByAttribute(String attribute);
}

public interface ConcreteRepository
  extends MappedTypeRepository&lt;ConcreteType&gt; { … }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>이 예제에서 <code>MappedTypeRepository</code> 인터페이스는,  <code>AbstractMappedType</code>를 상속하는 적은 도메인들을 위한 평범한 부모 인터페이스입니다. 이것은 또한 제너릭 메소드<code>findAllByAttribute(…)</code>를 정의하여 이것은 구체화된 리파지토리 인터페이스의 인스턴스에서 사용될 수 있습니다. 
      
      만약 당신이 <code>ConcreteRepository</code>에서의 <code>findByAllAttribute(…)</code>를 실행시킨다면, 실행되는 쿼리는 <code>select t from ConcreteType t where t.attribute = ?1</code>가 될 것입니다. 

       </p>
    </div>
    <div class="originalArticle">
      <p>In the example the interface <code>MappedTypeRepository</code> is the common parent interface for a few domain types extending <code>AbstractMappedType</code>. It also defines the generic method <code>findAllByAttribute(…)</code> which can be used on instances of the specialized repository interfaces. If you now invoke <code>findByAllAttribute(…)</code> on <code>ConcreteRepository</code> the query being executed will be <code>select t from ConcreteType t where t.attribute = ?1</code>.</p>
    </div>  

      
</div>
</div>
<div class="sect3">
<h4 id="jpa.modifying-queries"><a class="anchor" href="#jpa.modifying-queries"></a>    <div class="translateArticle">
      4.3.7. 쿼리 수정하기 -  Modifying queries
    </div>
    <div class="originalArticle">
      4.3.7. Modifying queries
    </div>  

      </h4>
<div class="paragraph">
    <div class="translateArticle">
      <p>
        위의 모든 섹션들은 어떻게 주어진 엔티티나 엔티티들의 콜렉션에 접근하는 쿼리들을 선언하는 지를 설명합니다. 물론 당신은 <a href="#repositories.custom-implementations">Custom implementations for Spring Data repositories</a>에 설명한 기능들을 이용하여서 커스텀 수정 행동을 추가할 수도 있습니다. 이러한 접근은 포괄적인 커스텀 기능에서 실현가능하지만, 당신은 실제로, 쿼리 메소드에 <code>@Modifying</code>로 어노테이션 하면서, 오직 파라미터 바인딩만을 필요로 하는 수정쿼리의 실행을 할 수 있습니다. 
      </p>
    </div>
    <div class="originalArticle">
      <p>All the sections above describe how to declare queries to access a given entity or collection of entities. Of course you can add custom modifying behaviour by using facilities described in <a href="#repositories.custom-implementations">Custom implementations for Spring Data repositories</a>. As this approach is feasible for comprehensive custom functionality, you can achieve the execution of modifying queries that actually only need parameter binding by annotating the query method with <code>@Modifying</code>:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 47. manipuling 쿼리들의 정의
    </div>
    <div class="originalArticle">
      Example 47. Declaring manipulating queries
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Modifying
@Query("update User u set u.firstname = ?1 where u.lastname = ?2")
int setFixedFirstnameFor(String firstname, String lastname);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">  
    <div class="translateArticle">
      <p>

        이것은 하나를 선택하는 대신에 updating하는 쿼리를 동작시킵니다. <code>EntityManager</code>가 아마 수정쿼리의 실행한 이후에 오래된 엔티리를 가지고 있는 까닭에, 우리는 자동적으로 clear it 할 필요가 없습니다. (세부적인 사항을 보려면 자바Doc의 <code>EntityManager.clear()</code> 를 보세요). 이것은 <code>EntityManager</code>안에서 여전히 대기중인 모든 flush되지 않은 변화들을 효과적으로 drop할 것이기 때문입니다. 만약 당신이 <code>EntityManager</code>가 자동적으로 cleared되기를 원한다면, 당신은 <code>@Modifying</code>어노테이션의 <code>clearAutomatically</code>속성을 true로 하면 됩니다. (역주: 조회수 같은 것 올릴 때 이 속성을 걸고 할 때가 있었다. 테스트하면서 이상하게 안 걸리는 경우가 있었는데 명시적으로 이 옵션을 true까지 다 주니까 되었던 기억이 남;; )
      </p>
    </div>
    <div class="originalArticle">
      <p>This will trigger the query annotated to the method as updating query instead of a selecting one. As the <code>EntityManager</code> might contain outdated entities after the execution of the modifying query, we do not automatically clear it (see JavaDoc of <code>EntityManager.clear()</code> for details) since this will effectively drop all non-flushed changes still pending in the <code>EntityManager</code>. If you wish the <code>EntityManager</code> to be cleared automatically you can set <code>@Modifying</code> annotation&#8217;s <code>clearAutomatically</code> attribute to <code>true</code>.</p>
    </div>  

      
</div>
</div>
<div class="sect3">
<h4 id="jpa.query-hints"><a class="anchor" href="#jpa.query-hints"></a>    <div class="translateArticle">
      4.3.8. 쿼리 힌트 적용
    </div>
    <div class="originalArticle">
      4.3.8. Applying query hints
    </div>  

      </h4>
<div class="paragraph">
    <div class="translateArticle">
      <p>당신의 리파지토리 인터페이스에 선언된 쿼리에 쿼리 힌트를 적용하기 위해, <code>@QueryHints</code>어노테이션을 사용할 수가 있습니다. 이것은 JPA <code>@QueryHint</code> 의 배열을 사용하고, 잠재적으로 힌트를 사용하지 않도록 하는 boolean flag가 있습니다. 페이지네이션을 적용할 때 발동되는 카운트 쿼리에 이 flag는 적용이 됩니다. (역주 : 맞는 번역인지 하는 고민) </p>
    </div>
    <div class="originalArticle">
      <p>To apply JPA query hints to the queries declared in your repository interface you can use the <code>@QueryHints</code> annotation. It takes an array of JPA <code>@QueryHint</code> annotations plus a boolean flag to potentially disable the hints applied to the addtional count query triggered when applying pagination.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 48. repository 메소드와 함께 QueryHints 사용하기
    </div>
    <div class="originalArticle">
      Example 48. Using QueryHints with a repository method
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface UserRepository extends Repository&lt;User, Long&gt; {

  @QueryHints(value = { @QueryHint(name = "name", value = "value")},
              forCounting = false)
  Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>
        방금 보여진 선언은 실제 쿼리를 위하여, 설정된 <code>@QueryHint</code>에 적용될 수 있습니다. 하지만 전체 페이지 숫자를 계산하기 위해 발동되는 카운트쿼리는 생략될 수 있습니다. (역주: 확인필요)
      </p>
    </div>
    <div class="originalArticle">
      <p>The just shown declaration would apply the configured <code>@QueryHint</code> for that actually query but omit applying it to the count query triggered to calculate the total number of pages.</p>
    </div>  

      
</div>
</div>
<div class="sect3">
<h4 id="jpa.entity-graph"><a class="anchor" href="#jpa.entity-graph"></a>    <div class="translateArticle">
      4.3.9. Fetch- and LoadGraphs 설정
    </div>
    <div class="originalArticle">
      4.3.9. Configuring Fetch- and LoadGraphs
    </div>  

      </h4>
<div class="paragraph">
    <div class="translateArticle">
      <p>
        JPA 2.1 스펙은 Fetch- 와 LoadGraphs에 대한 지원을 소개합니다. 우리는 <code>@NamedEntityGraph</code> 정의에 대한 참조를 허용하는 <code>@EntityGraph</code>어노테이션을 통해서 LoadGraph를 지원합니다. @NamedEntityGraph는 엔티에 어노테이션되어서 resulting쿼리에 대한 fetch plan을 설정하는데 사용됩니다. 

        fetching의 타입 (Fetch/Load) 는 <code>@EntityGraph</code>어노테이션의 <code>type</code>  속성을 통해서 설정될 수 있습니다. 더 나은 레퍼런스를 위해서 JPA 2.1 Spec 3.7.4를 살펴보시길 바랍니다. </p>
    </div>
    <div class="originalArticle">
      <p>The JPA 2.1 specification introduced support for specifiying Fetch- and LoadGraphs that we also support via the <code>@EntityGraph</code> annotation which allows to reference a <code>@NamedEntityGraph</code> definition, that can be annotated on an entity, to be used to configure the fetch plan of the resulting query. The type (Fetch / Load) of the fetching can be configured via the <code>type</code> attribute on the <code>@EntityGraph</code> annotation. Please have a look at the JPA 2.1 Spec 3.7.4 for further reference.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 49. 엔티티에서 엔티티 그래프의 이름정의하기
    </div>
    <div class="originalArticle">
      Example 49. Defining a named entity graph on an entity.
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 50. repository 쿼리 메소드에서 이름지어진 엔티티 그래프 정의 참조하기 
    </div>
    <div class="originalArticle">
      Example 50. Referencing a named entity graph definition on an repository query method.
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.stored-procedures"><a class="anchor" href="#jpa.stored-procedures"></a>    <div class="translateArticle">
      4.4. 스토어 프로시져 - Stored procedures
    </div>
    <div class="originalArticle">
      4.4. Stored procedures
    </div>  

      </h3>
<div class="paragraph">
    <div class="translateArticle">
      <p> JPA 2.1 스펙은 JPA 크리테리아 API를 통한 스토어 프로시져 호출을 지원을 소개합니다. 우리는 리파지토리 메소드에서 저장된 프로시져 메타데이터를 선언하는 <code>@Procedure</code>어노테이션을 소개했었습니다. </p>
    </div>
    <div class="originalArticle">
      <p>The JPA 2.1 specification introduced support for calling stored procedures via the JPA criteria query API. We Introduced the <code>@Procedure</code> annotation for declaring stored procedure metadata on a repository method.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 51. HSQL DB 에서 pus1inout procedure 정의 하기 
    </div>
    <div class="originalArticle">
      Example 51. The definition of the pus1inout procedure in HSQL DB.
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-sql" data-lang="sql">/;
DROP procedure IF EXISTS plus1inout
/;
CREATE procedure plus1inout (IN arg int, OUT res int)
BEGIN ATOMIC
 set res = arg ` 1;
END
/;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>스토어 프로시져를 위한 메타데이터는 엔티티 타입에 <code>NamedStoredProcedureQuery</code>어노테이션을 통해서 설정 될 수 있습니다.  </p>
    </div>
    <div class="originalArticle">
      <p>Metadata for stored procedures can be configured via the <code>NamedStoredProcedureQuery</code> annotation on an entity type.</p>
    </div>  

      
</div>
<div id="jpa.stored-procedure-entity-metadata" class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 52. 엔티티에서의 StoredProcedure 메타데이터 정의
    </div>
    <div class="originalArticle">
      Example 52. StoredProcedure metadata definitions on an entity.
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@NamedStoredProcedureQuery(name = "User.plus1", procedureName = "plus1inout", parameters = {
  @StoredProcedureParameter(mode = ParameterMode.IN, name = "arg", type = Integer.class),
  @StoredProcedureParameter(mode = ParameterMode.OUT, name = "res", type = Integer.class) })
public class User {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> 스토어 프로시져는 다양한 방법으로 리파지토리 메소드에서 참조될 수 있습니다. 호출되는 stored procedure 는 <code>value</code>나  <code>@Procedure</code>의 <code>procedureName</code>속성을 통해 직접적으로 정의될 수 있기도하고, 아니면 <code>name</code> 속성을 통해 간접적으로 정의되기도 합니다. 어떠한 이름도 설정되지 않으면 리파지토리 메소드 이름이 fallback으로 사용됩니다. </p>
    </div>
    <div class="originalArticle">
      <p>Stored procedures can be referenced from a repository method in multiple ways. The stored procedure to be called can either be defined directly via the <code>value</code> or <code>procedureName</code> attribute of the <code>@Procedure</code> annotation or indirectly via the <code>name</code> attribute. If no name is configured the name of the repository method is used as a fallback.</p>
    </div>  

      
</div>
<div id="jpa.stored-procedure-reference" class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 53. 데이터베이스에 명시적으로 매핑된 프로시져  "plus1inout" 참조
    </div>
    <div class="originalArticle">
      Example 53. Referencing explicitly mapped procedure with name "plus1inout" in database.
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Procedure("plus1inout")
Integer explicitlyNamedPlus1inout(Integer arg);</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 54. 데이터베이스에 암시적으로 매핑된 프로시져 "plus1inout" 을 통해 <code>procedureName</code> alias.으로 참조
    </div>
    <div class="originalArticle">
      Example 54. Referencing implicitly mapped procedure with name "plus1inout" in database via <code>procedureName</code> alias.
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Procedure(procedureName = "plus1inout")
Integer plus1inout(Integer arg);</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 55. 엔티티 매니저에서 명시적으로 매핑된 "User.plus1IO" stored procedure를 참조
    </div>
    <div class="originalArticle">
      Example 55. Referencing explicitly mapped named stored procedure "User.plus1IO" in EntityManager.
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Procedure(name = "User.plus1IO")
Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param("arg") Integer arg);</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 56. 암시적으로 엔티티 매니저에 매핑된 stored procedure "User.plus1" 를 메소드 네임을 통해 참조
    </div>
    <div class="originalArticle">
      Example 56. Referencing implicitly mapped named stored procedure "User.plus1" in EntityManager via method-name.
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Procedure
Integer plus1(@Param("arg") Integer arg);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="specifications"><a class="anchor" href="#specifications"></a>    <div class="translateArticle">
      4.5. 스페시피케이션 - Specifications(원문 그대로 가자)
    </div>
    <div class="originalArticle">
      4.5. Specifications
    </div>  

      </h3>
<div class="paragraph">
    <div class="translateArticle">
      <p> 
        JPA 2 는 프로그램적으로 쿼리를 만들어내는 크리테리아 API를 소개합니다. <code>criteria</code>를 쓰는 것은 당신이 실제로 도메인 클래스를 위해 쿼리의 where-구문을 정의한다는 것입니다. 이러한 크리테리아는 (JPA 크리테리아 API 제약에 의해 설명된)엔티티에 대해 predicate(서술어)로 여겨집니다.

      </p>
    </div>
    <div class="originalArticle">
      <p>JPA 2 introduces a criteria API that can be used to build queries programmatically. Writing a <code>criteria</code> you actually define the where-clause of a query for a domain class. Taking another step back these criteria can be regarded as predicate over the entity that is described by the JPA criteria API constraints.</p>
    </div>  

      
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>스프링 데이터 JPA는 에릭 에반스의 책"Domain Driven Design"에서 specification의 개념을 따와서, 같은 문법을 따라, 크리테리아 API 를 사용하는 그러한 specification을 정의하는 API를 제공하였습니다.  
      specifications를 지원하기 위해, 당신의 리파지토리 인터페이스를 <code>JpaSpecificationExecutor</code>인터페이스로 인터페이스와 함께 상속할 수 있습니다. 
      </p>
    </div>
    <div class="originalArticle">
      <p>Spring Data JPA takes the concept of a specification from Eric Evans' book "Domain Driven Design", following the same semantics and providing an API to define such specifications using the JPA criteria API. To support specifications you can extend your repository interface with the <code>JpaSpecificationExecutor</code> interface:</p>
    </div>  

      
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface CustomerRepository extends CrudRepository&lt;Customer, Long&gt;, JpaSpecificationExecutor {
 …
}</code></pre>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> 추가적인 인터페이스는 당신이 specification 를 다양한 방법으로 하게 해주는 메소드를 가지고 있습니다. 예를 들면 <code>findAll</code> 메소드는 speficiation에 맞는 모든 엔티티를 반환하여 줍니다. </p>
    </div>
    <div class="originalArticle">
      <p>The additional interface carries methods that allow you to execute specifications in a variety of ways. For example, the <code>findAll</code> method will return all entities that match the specification:</p>
    </div>  

      
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List&lt;T&gt; findAll(Specification&lt;T&gt; spec);</code></pre>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> <code>Specification</code>인터페이스는 다음과 같이 정의합니다. :</p>
    </div>
    <div class="originalArticle">
      <p>The <code>Specification</code> interface is defined as follows:</p>
    </div>  

      
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface Specification&lt;T&gt; {
  Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query,
            CriteriaBuilder builder);
}</code></pre>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
         <div class="translateArticle">
           <p>자, 그럼 뭐가 일반적인 유스케이스 일까요? Specification는 엔티티위에서 predicates들의 모음을 확장하게끔 하는 데 쉽게 사용될수 있어서, 매번 필요한 조합을 위한 쿼리를 선언할 필요없이 <code>JpaRepository</code>와 같이 사용되고 조합될 수 있습니다. 
            여기에 그 예제가 있습니다.  </p>
          </div>
          <div class="originalArticle">
            <p>Okay, so what is the typical use case? 

              Specifications can easily be used to build an extensible set of predicates on top of an entity that then can be combined and used with <code>JpaRepository</code> without the need to declare a query (method) for every needed combination. 

              Here&#8217;s an example:</p>
          </div>  
      
    </div>
    <div class="originalArticle">
      <p>Okay, so what is the typical use case? Specifications can easily be used to build an extensible set of predicates on top of an entity that then can be combined and used with <code>JpaRepository</code> without the need to declare a query (method) for every needed combination. Here&#8217;s an example:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 57. Customer를 위한 Spcifications
    </div>
    <div class="originalArticle">
      Example 57. Specifications for a Customer
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class CustomerSpecs {

  public static Specification&lt;Customer&gt; isLongTermCustomer() {
    return new Specification&lt;Customer&gt;() {
      public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query,
            CriteriaBuilder builder) {

         LocalDate date = new LocalDate().minusYears(2);
         return builder.lessThan(root.get(_Customer.createdAt), date);
      }
    };
  }

  public static Specification&lt;Customer&gt; hasSalesOfMoreThan(MontaryAmount value) {
    return new Specification&lt;Customer&gt;() {
      public Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query,
            CriteriaBuilder builder) {

         // build query here
      }
    };
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>
        인정하건대, 상당한 양의 보일러플레이트가 더 나은 향상을 위해 남아있지만(자바8 클로저로 좀더 줄어들기를 바랍니다), 클라이언트사이드는 보시는 바와 같이 좀 더 나아졌습니다. <code>_Customer</code>타입은 JPA 메타모델 generator를 이용하여 생성된메타모델 타입입니다.(see the <a href="http://docs.jboss.org/hibernate/jpamodelgen/1.0/reference/en-US/html_single/#whatisit">Hibernate implementation&#8217;s documentation for example</a>을 보세요 ) 
        
        그래서 이 표현-<code>_Customer.createdAt</code>은 <code>Date</code>의<code>createdAt</code>속성을 가지는  <code>Customer</code>를 가정합니다. 그 옆에는 우리는 비즈니스 요구사항 추상화 레벨에서 몇가지 크리테리아와 생성된 실행가능한 <code>Specifications</code>를 표현했습니다. 그럼 클라이언트는 다음과 같이 <code>Specification</code>를 사용할 것입니다. :

      </p>
    </div>
    <div class="originalArticle">
      <p>Admittedly the amount of boilerplate leaves room for improvement (that will hopefully be reduced by Java 8 closures) but the client side becomes much nicer as you will see below. The <code>_Customer</code> type is a metamodel type generated using the JPA Metamodel generator (see the <a href="http://docs.jboss.org/hibernate/jpamodelgen/1.0/reference/en-US/html_single/#whatisit">Hibernate implementation&#8217;s documentation for example</a>). So the expression <code>_Customer.createdAt</code> is asuming the <code>Customer</code> having a <code>createdAt</code> attribute of type <code>Date</code>. Besides that we have expressed some criteria on a business requirement abstraction level and created executable <code>Specifications</code>. So a client might use a <code>Specification</code> as follows:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 58.단순한 specification 사용하기
    </div>
    <div class="originalArticle">
      Example 58. Using a simple Specification
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List&lt;Customer&gt; customers = customerRepository.findAll(isLongTermCustomer());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>자, 왜 단순하게 이러한 종류의 데이터 접근을 위해 쿼리를 생성하지 않을까요? 당신이 맞습니다. 단순한 <code>Specification</code>을 사용하는 것은 단순한 평문 쿼리 선언에서는 많은 장점을 얻지 못합니다. specifications의 장점은 그들을 조합해서 새로운 <code>Specification</code>객체를 만들때 나타납니다. 당신은 <code>Specifications</code>helper 클래스(우리가 다음과 같이 표현을 만들기 위해 제공하는)를 통해서 이러한 점을 달성할 수 있습니다. :  </p>
    </div>
    <div class="originalArticle">
      <p>Okay, why not simply create a query for this kind of data access? You&#8217;re right. Using a single <code>Specification</code> does not gain a lot of benefit over a plain query declaration. The power of specifications really shines when you combine them to create new <code>Specification</code> objects. You can achieve this through the <code>Specifications</code> helper class we provide to build expressions like this:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 59. 조합된 Specifications
    </div>
    <div class="originalArticle">
      Example 59. Combined Specifications
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">MonetaryAmount amount = new MonetaryAmount(200.0, Currencies.DOLLAR);
List&lt;Customer&gt; customers = customerRepository.findAll(
  where(isLongTermCustomer()).or(hasSalesOfMoreThan(amount)));</code></pre>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>당신이 보듯이 <code>Specifications</code>는 <code>Specification</code>인스턴스를 체인하고 조합하기 위해 몇가지 glue-code 메소드를 제공합니다. 그러므로 당신의 데이터 접근 레이어를 확장하는 것은 단순히 새로운 <code>Specification</code> 구현체들을 만들어, 그들을 이미 존재하는 하나로 조합하는 일이 될 것입니다. </p>
    </div>
    <div class="originalArticle">
      <p>As you can see, <code>Specifications</code> offers some glue-code methods to chain and combine <code>Specification</code> instances. Thus extending your data access layer is just a matter of creating new <code>Specification</code> implementations and combining them with ones already existing.</p>
    </div>  

      
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transactions"><a class="anchor" href="#transactions"></a>4.6. Transactionality</h3>
<div class="paragraph">
    <div class="translateArticle">
      <p>리파지토리 인스턴스의 CRUD 메소드들은 기본적으로 transactional합니다. 읽기 작업을 위해서 트랜잭션 설정 <code>readOnly</code> flag가 true로 설정되고, 모든 다른 것들은 평문<code>@Transactional</code>로 설정되어 기본 트랜잭션이 적용되게 됩니다. 세부사항은 <code>CrudRepository</code>의 JavaDoc을 보시길 바랍니다. 만약 당신이 조금 다르게 리파지토리에 선언된 메소드들 중 하나의 트랜잭션 설정을 하고 싶다면, 단순히 다음과 같이 재선언해보세요   :</p>
    </div>
    <div class="originalArticle">
      <p>CRUD methods on repository instances are transactional by default. For reading operations the transaction configuration <code>readOnly</code> flag is set to true, all others are configured with a plain <code>@Transactional</code> so that default transaction configuration applies. For details see JavaDoc of <code>CrudRepository</code>. If you need to tweak transaction configuration for one of the methods declared in a repository simply redeclare the method in your repository interface as follows:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 60. CRUD 설정을 위한 커스텀 트랜잭션
    </div>
    <div class="originalArticle">
      Example 60. Custom transaction configuration for CRUD
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface UserRepository extends CrudRepository&lt;User, Long&gt; {

  @Override
  @Transactional(timeout = 10)
  public List&lt;User&gt; findAll();

  // Further query method declarations
}</code></pre>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>이것은 <code>findAll()</code>메소드가 <code>readOnly</code>flag없이 10초간의 시간제한안에 실행되게 할 것입니다.  </p>
    </div>
    <div class="originalArticle">
      <p>This will cause the <code>findAll()</code> method to be executed with a timeout of 10 seconds and without the <code>readOnly</code> flag.</p>
    </div>  

      
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>트랜잭션 행동을 변경하는 다른 가능성은 facade나 일반적으로 하나이상의 리파지토리를 다루는 서비스구현체를 사용하는 것입니다. 그것의 목적은 non-CRUD 작업에 대해 트랜잭션 경계선을 정의하는 데 있습니다. </p>
    </div>
    <div class="originalArticle">
      <p>Another possibility to alter transactional behaviour is using a facade or service implementation that typically covers more than one repository. Its purpose is to define transactional boundaries for non-CRUD operations:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 61. 여러개의 리파지토리 호출을 위해 트랜잭션을 호출하는 facade 사용하기 
    </div>
    <div class="originalArticle">
      Example 61. Using a facade to define transactions for multiple repository calls
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Service
class UserManagementImpl implements UserManagement {

  private final UserRepository userRepository;
  private final RoleRepository roleRepository;

  @Autowired
  public UserManagementImpl(UserRepository userRepository,
    RoleRepository roleRepository) {
    this.userRepository = userRepository;
    this.roleRepository = roleRepository;
  }

  @Transactional
  public void addRoleToAllUsers(String roleName) {

    Role role = roleRepository.findByName(roleName);

    for (User user : userRepository.findAll()) {
      user.addRole(role);
      userRepository.save(user);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>
        이것은 <code>addRoleToAllUsers(…)</code>에 대한 호출을 일으키고, 트랜잭션 내부에서 동작하게 할 것입니다. (특별히 존재하는 트랜잭션에 참여시키거나, 아무것도 실행되지 않는다면 새로운 것을 만들것입니다). 이 리파지토리의 트랜잭션 설정은 실제 사용되기로 결정한 다른 바깥 쪽의 트랜잭션 설정때문에 무시(neglected)될 것입니다. 당신은 <code>&lt;tx:annotation-driven /&gt;</code>을 활성화시키거나  <code>@EnableTransactionManagement</code> 를 명시적으로 사용하여서  facades가 동작하는 어노테이션 기반의 설정 을 얻어야 합니다. 위의 예제는 당신이 컴포넌트 스캐닝을 한다고 가정합니다. 

      </p>
    </div>
    <div class="originalArticle">
      <p>This will cause call to <code>addRoleToAllUsers(…)</code> to run inside a transaction (participating in an existing one or create a new one if none already running). The transaction configuration at the repositories will be neglected then as the outer transaction configuration determines the actual one used. Note that you will have to activate <code>&lt;tx:annotation-driven /&gt;</code> or use <code>@EnableTransactionManagement</code> explicitly to get annotation based configuration at facades working. The example above assumes you are using component scanning.</p>
    </div>  

      
</div>
</div>
</div>
<div class="sect3">
<h4 id="transactional-query-methods"><a class="anchor" href="#transactional-query-methods"></a>4.6.1. Transactional query methods</h4>
<div class="paragraph">
    <div class="translateArticle">
      <p>당신의 쿼리 메소드가 트랜잭션하기 위해 단순히 <code>@Transactional</code>을 레파지토리 인터페이스에 사용하세요.</p>
    </div>
    <div class="originalArticle">
      <p>To allow your query methods to be transactional simply use <code>@Transactional</code> at the repository interface you define.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 62. @Transactional 을 쿼리 메소드에 사용하기
    </div>
    <div class="originalArticle">
      Example 62. Using @Transactional at query methods
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Transactional(readOnly = true)
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  List&lt;User&gt; findByLastname(String lastname);

  @Modifying
  @Transactional
  @Query("delete from User u where u.active = false")
  void deleteInactiveUsers();
}</code></pre>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>일반적으로 대부분의 쿼리가 읽기 전용이기 때문에, 당신은 readOnly flag를 true로 설정하기를 원할 겁니다..이와는 대조적으로 <code>deleteInactiveUsers()</code>는 <code>@Modifying</code>어노테이션을 사용하여 트랜잭션 설정을 오버라이딩합니다. 그러므로 저 메소드는 <code>readOnly</code>가 <code>false</code>인 상태로 설정되어서 실행됩니다 </p>
    </div>
    <div class="originalArticle">
      <p>Typically you will want the readOnly flag set to true as most of the query methods will only read data. In contrast to that <code>deleteInactiveUsers()</code> makes use of the <code>@Modifying</code> annotation and overrides the transaction configuration. Thus the method will be executed with <code>readOnly</code> flag set to <code>false</code>.</p>
    </div>  

      
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
    <div class="translateArticle">
      <p> 읽기전용 쿼리를 위해 트랜잭션을 사용하는 것은 절대적으로 합리적입니다. 우리는 <code>readOnly</code>flag 같은 것을 설정함으로써 그것들(읽기전용쿼리들)을 mark하는 것이 가능합니다.  하지만 당신이 manipulating하는 쿼리를 동작시키지 않았는지 체크하는 것은 되지가 않습니다.  (비록 몇몇 데이터베이스가 읽기전용 트랜잭션 내의 <code>INSERT</code> 와 <code>UPDATE</code> 문을 거절하지만)

      <code>readOnly</code> flag는 대신에 성능 최적화를 위해 JDBC 드라이버에게 hint를 전파시킵니다(propagated). 더군다나 스프링은 몇가지 JPA provider에 대핸 최적화를 제공합니다. 예를 들자면 하이버네이트를 사용할 때, flush 모드가 <code>NEVER</code>로 된 경우 당신은 트랜잭션을 <code>readOnly</code>로 설정하여 하이너네이트의 변경감지를 skip합니다.(large 객체 trees에서는 주목할만한 향상이 있습니다.)
</p>
    </div>
    <div class="originalArticle">
      <p>It&#8217;s definitely reasonable to use transactions for read only queries and we can mark them as such by setting the <code>readOnly</code> flag. 

        This will not, however, act as check that you do not trigger a manipulating query (although some databases reject <code>INSERT</code> and <code>UPDATE</code> statements inside a read only transaction). 

        The <code>readOnly</code> flag instead is propagated as hint to the underlying JDBC driver for performance optimizations. Furthermore, Spring will perform some optimizations on the underlying JPA provider. E.g. when used with Hibernate the flush mode is set to <code>NEVER</code> when you configure a transaction as <code>readOnly</code> which causes Hibernate to skip dirty checks (a noticeable improvement on large object trees).</p>
    </div>  

      
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="locking"><a class="anchor" href="#locking"></a>4.7. Locking</h3>
<div class="paragraph">
    <div class="translateArticle">
      <p> 사용할 lock 모드를 명시하기 위해 <code>@Lock</code>어노테이션이 쿼리메소드에서 사용될 수 있습니다. </p>
    </div>
    <div class="originalArticle">
      <p>To specify the lock mode to be used the <code>@Lock</code> annotation can be used on query methods:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 63. 쿼리메소드에 락 메타데이터 정의하기
    </div>
    <div class="originalArticle">
      Example 63. Defining lock metadata on query methods
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">interface UserRepository extends Repository&lt;User, Long&gt; {

  // Plain query method
  @Lock(LockModeType.READ)
  List&lt;User&gt; findByLastname(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>이 메소드 선언은 동작될 쿼리가 <code>LockModeType</code> <code>READ</code>를 갖추게 할 것입니다. 당신은 또한 CRUD 메소드를 위한 locking을 리파지토리 인터페이스에서 재선언하고 <code>@Lock</code>어노테이션을 추가함으로써 정의할 수 있습니다.  </p>
    </div>
    <div class="originalArticle">
      <p>This method declaration will cause the query being triggered to be equipped with the <code>LockModeType</code> <code>READ</code>. You can also define locking for CRUD methods by redeclaring them in your repository interface and adding the <code>@Lock</code> annotation:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 64. CRUD메소드들에 대해 락 메타데이터를 정의하기
    </div>
    <div class="originalArticle">
      Example 64. Defining lock metadata on CRUD methods
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">interface UserRepository extends Repository&lt;User, Long&gt; {

  // Redeclaration of a CRUD method
  @Lock(LockModeType.READ);
  List&lt;User&gt; findAll();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="auditing"><a class="anchor" href="#auditing"></a>4.8. 감사 - Auditing</h3>
<div class="sect3">
<h4 id="auditing.basics"><a class="anchor" href="#auditing.basics"></a>4.8.1. 기초 - Basics</h4>
<div class="paragraph">
    <div class="translateArticle">
      <p>스프링 데이터는 엔티티를 누가 만들었고 변경했는지, 발생한 시간 지점에 관한 것들을 투명하게 추적하는 세련된 지원을 제공합니다.  이러한 기능의 장점을 누리기 위해 당신은 엔티티 클래스에 어노테이션을 사용하거나 인터페이스를 구현하여서 정의되는 auditing 메타데이터를 넣을 수 있습니다. 
        
      </p>
    </div>
    <div class="originalArticle">
      <p>Spring Data provides sophisticated support to transparently keep track of who created or changed an entity and the point in time this happened. To benefit from that functionality you have to equip your entity classes with auditing metadata that can be defined either using annotations or by implementing an interface.</p>
    </div>  

      
</div>
<div class="sect4">
<h5 id="auditing.annotations"><a class="anchor" href="#auditing.annotations"></a>    <div class="translateArticle">
     어노테이션 기반 auditing 메타데이터
    </div>
    <div class="originalArticle">
      Annotation based auditing metadata
    </div>  

      </h5>
<div class="paragraph">
    <div class="translateArticle">
      <p>우리는<code>@CreatedBy</code>, <code>@LastModifiedBy</code> 를 제공하여 누가  엔티티를 생성하였고 수정하였는지 캡쳐할 뿐만 아니라 <code>@CreatedDate</code> and <code>@LastModifiedDate</code>를 사용하여 어떠한 시점에 발생하였는지 캡쳐합니다.</p>
    </div>
    <div class="originalArticle">
      <p>We provide <code>@CreatedBy</code>, <code>@LastModifiedBy</code> to capture the user who created or modified the entity as well as <code>@CreatedDate</code> and <code>@LastModifiedDate</code> to capture the point in time this happened.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 65. 감사된 엔티티  - An audited entity
    </div>
    <div class="originalArticle">
      Example 65. An audited entity
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">class Customer {

  @CreatedBy
  private User user;

  @CreatedDate
  private DateTime createdDate;

  // … further properties omitted
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>당신이 보듯이, 당신이 캡쳐하고 싶은 정보에 따라 선택적으로 어노테이션이 적용 가능합니다. 제 시간 지점을 캡쳐하는 어노테이션을 위해 다음의 타입들이 사용가능합니다 => JodaTimes <code>DateTime</code>, legacy Java <code>Date</code> and <code>Calendar</code>, JDK8 date/time types as well as <code>long</code>/<code>Long</code> </p>
    </div>
    <div class="originalArticle">
      <p>As you can see, the annotations can be applied selectively, depending on which information you&#8217;d like to capture. For the annotations capturing the points in time can be used on properties of type JodaTimes <code>DateTime</code>, legacy Java <code>Date</code> and <code>Calendar</code>, JDK8 date/time types as well as <code>long</code>/<code>Long</code>.</p>
    </div>  

      
</div>
</div>
<div class="sect4">
<h5 id="auditing.interfaces"><a class="anchor" href="#auditing.interfaces"></a>    <div class="translateArticle">
      인터페이스 기반 감사 메타데이터
    </div>
    <div class="originalArticle">
      Interface-based auditing metadata
    </div>  

      </h5>
<div class="paragraph">
    <div class="translateArticle">
      <p>당신이 auditing메타데이터를 정의하지 않는 경우에, 당신은 도메인 클래스에 <code>Auditable</code>인터페이스를 구현할 수가 있습니다. 이것은 모든 auditing 속성을 위한 setter메소드를 노출시킵니다. </p>
    </div>
    <div class="originalArticle">
      <p>In case you don&#8217;t want to use annotations to define auditing metadata you can let your domain class implement the <code>Auditable</code> interface. It exposes setter methods for all of the auditing properties.</p>
    </div>  

      
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>또한  <code>AbstractAuditable</code> 기반의 편리한 클래스가 있는데, 이것으로 상속을 할 수가 있어서, 수동적으로 인터페이스 메소드를 구현할 필요로를 피하게 합니다. 이것은 스프링 데이터에 대한 도메인클래스들에, 피하고 싶어할 지도 모르는 커플링을 증가시킨다는 것을 알아둡시다. 보통 auditing 메타데이터를 정의하는 어노테이션 기반ㅇ 방법은 좀 더 유연하고 덜 침투적이기 때문에 선호됩니다. </p>
    </div>
    <div class="originalArticle">
      <p>There&#8217;s also a convenience base class <code>AbstractAuditable</code> which you can extend to avoid the need to manually implement the interface methods. Be aware that this increases the coupling of your domain classes to Spring Data which might be something you want to avoid. Usually the annotation based way of defining auditing metadata is preferred as it is less invasive and more flexible.</p>
    </div>  

      
</div>
</div>
<div class="sect4">
<h5 id="auditing.auditor-aware"><a class="anchor" href="#auditing.auditor-aware"></a>AuditorAware</h5>
<div class="paragraph">
    <div class="translateArticle">
      <p>당신이 <code>@CreatedBy</code> 나  <code>@LastModifiedBy</code>같은 것을 사용하고 싶은 경우에, auditing인프라스트럭처는 어떻게든 현재 printcipal 에 대해 알게될 필요가 있습니다. 그렇게 하기 위해 우리는  <code>AuditorAware&lt;T&gt;</code> SPI interface를 제공을 하는데, 이것은 누가 어플리케이션과 시스템 상호작용을 하는 지, 누가 현재 유저인지 인프라스트럭쳐에게 알려주기 위해 구현을 합니다. 제너릭 타입 <code>T</code> 는 <code>@CreatedBy</code> 나 <code>@LastModifiedBy</code>가 어노테이션되는 속성이 어떤 속성인지 정의합니다.  </p>
    </div>
    <div class="originalArticle">
      <p>In case you use either <code>@CreatedBy</code> or <code>@LastModifiedBy</code>, the auditing infrastructure somehow needs to become aware of the current principal. To do so, we provide an <code>AuditorAware&lt;T&gt;</code> SPI interface that you have to implement to tell the infrastructure who the current user or system interacting with the application is. The generic type <code>T</code> defines of what type the properties annotated with <code>@CreatedBy</code> or <code>@LastModifiedBy</code> have to be.</p>
    </div>  

      
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>여기에 Spring 시큐리티 <code>Authentication</code>객체를 사용하는 인터페이스 구현에 대한 예제가 있습니다</p>
    </div>
    <div class="originalArticle">
      <p>Here&#8217;s an example implementation of the interface using Spring Security&#8217;s <code>Authentication</code> object:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 66. 스프링 시큐리티 기반의 AuditorAware구현
    </div>
    <div class="originalArticle">
      Example 66. Implementation of AuditorAware based on Spring Security
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">class SpringSecurityAuditorAware implements AuditorAware&lt;User&gt; {

  public User getCurrentAuditor() {

    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

    if (authentication == null || !authentication.isAuthenticated()) {
      return null;
    }

    return ((MyUserDetails) authentication.getPrincipal()).getUser();
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> 저 구현은 스프링시큐리티에 의해 제공된 <code>Authentication</code>객체에 접근하고, 당신이 생성한 <code>UserDetailsService</code>구현에서 커스텀 <code>UserDetails</code>을 탐색합니다. 우리는 여기서 당신이 도메인user를 <code>UserDetails</code>구현을 통해 노출했다고 가정하지만, 당신은 또한  <code>Authentication</code>가 발견될 수 있는 어디에서건 검색을 할 수가 있습니다. </p>
    </div>
    <div class="originalArticle">
      <p>The implementation is accessing the <code>Authentication</code> object provided by Spring Security and looks up the custom <code>UserDetails</code> instance from it that you have created in your <code>UserDetailsService</code> implementation. We&#8217;re assuming here that you are exposing the domain user through that <code>UserDetails</code> implementation but you could also look it up from anywhere based on the <code>Authentication</code> found.</p>
    </div>  

      
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.auditing"><a class="anchor" href="#jpa.auditing"></a>4.9. JPA Auditing</h3>
<div class="sect3">
<h4 id="jpa.auditing.configuration"><a class="anchor" href="#jpa.auditing.configuration"></a>    <div class="translateArticle">
      4.9.1. 일반적인 auditing 설정
    </div>
    <div class="originalArticle">
      4.9.1. General auditing configuration
    </div>  

      </h4>
<div class="paragraph">
    <div class="translateArticle">
      <p>스프링 데이터 JPA는 엔티티리스너를 가지고 있습니다. 엔티티리스너는 auditing 정보를 캡쳐하는 데 사용될 수가 있습니다. 먼저 당신은 <code>orm.xml</code> 내에 <code>AuditingEntityListener</code>를 등록을 해야 합니다. 당신의 영속성 컨텍스트에서 모든 엔티티가 사용할 수 있게 말이죠 .</p>
    </div>
    <div class="originalArticle">
      <p>Spring Data JPA ships with an entity listener that can be used to trigger capturing auditing information. So first you have to register the <code>AuditingEntityListener</code> inside your <code>orm.xml</code> to be used for all entities in your persistence contexts:</p>
    </div>  

      
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> auditing 기능은 클래스패스에<code>spring-aspects.jar</code> 를 필요로 합니다.</p>
    </div>
    <div class="originalArticle">
      <p>Note that the auditing feature requires <code>spring-aspects.jar</code> to be on the classpath.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 67. Auditing 설정 orm.xml
    </div>
    <div class="originalArticle">
      Example 67. Auditing configuration orm.xml
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;persistence-unit-metadata&gt;
  &lt;persistence-unit-defaults&gt;
    &lt;entity-listeners&gt;
      &lt;entity-listener class="….data.jpa.domain.support.AuditingEntityListener" /&gt;
    &lt;/entity-listeners&gt;
  &lt;/persistence-unit-defaults&gt;
&lt;/persistence-unit-metadata&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>이제 auditing기능을 활성화시키는 것은 스프링 데이터 JPA의 <code>auditing</code> 네임스페이스 요소를 당신의 설정에 추가하면됩니다.  :</p>
    </div>
    <div class="originalArticle">
      <p>Now activating auditing functionality is just a matter of adding the Spring Data JPA <code>auditing</code> namespace element to your configuration:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 68. XML 설정을 이용한  auditing 활성화
    </div>
    <div class="originalArticle">
      Example 68. Activating auditing using XML configuration
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;jpa:auditing auditor-aware-ref="yourAuditorAwareBean" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> Spring data jpa 1.5 에서는 auditing 은 @EnableJpaAuditing설정이 클래스에 의해서도 활성화 될 수가 있습니다</p>
    </div>
    <div class="originalArticle">
      <p>As of Spring Data JPA 1.5, auditing can be enabled by annotating a configuration class with the @EnableJpaAuditing annotation.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 69. 자바 설정을 통해 auditing 활성화 시키기
    </div>
    <div class="originalArticle">
      Example 69. Activating auditing via Java configuration
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJpaAuditing
class Config {

  @Bean
  public AuditorAware&lt;AuditableUser&gt; auditorProvider() {
    return new AuditorAwareImpl();
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> 만약 당신이 어플리케이션 콘텍스트에 AuditorAware의 빈타입을 노출시킨다면 auditing인프라스트럭쳐는 자동적으로 그것을 pick up해서 현재 user를 도메인 타입을 결정하는 데 그것을 사용할 것입니다. 만약 당신이 어플리케이션 내에 여러개의 구현체를 등록시켰다면, 당신은 명시적으로 @EnableJpaAuditing의 <code>auditorAwareRef</code>속성을 설정하여 그 중에 하나를 고를 수가 있습니다.   </p>
    </div>
    <div class="originalArticle">
      <p>If you expose a bean of type AuditorAware to the ApplicationContext, the auditing infrastructure will pick it up automatically and use it to determine the current user to be set on domain types. If you have multiple implementations registered in the ApplicationContext, you can select the one to be used by explicitly setting the <code>auditorAwareRef</code> attribute of @EnableJpaAuditing.</p>
    </div>  

      
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jpa.misc"><a class="anchor" href="#jpa.misc"></a>    <div class="translateArticle">
      5. 오해
    </div>
    <div class="originalArticle">
      5. Miscellaneous
    </div>  

      </h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="jpa.misc.merging-persistence-units"><a class="anchor" href="#jpa.misc.merging-persistence-units"></a>    <div class="translateArticle">
      5.1. persistence 유닛을 합병(merging)하기
    </div>
    <div class="originalArticle">
      5.1. Merging persistence units
    </div>  

      </h3>
<div class="paragraph">
    <div class="translateArticle">
      <p>
        스프링은 여러개의 영속 유닛을 가지는 것을 지원합니다. 하지만 때때로 당신은 어플리케이션을 모듈화하면서도, 여전히 이런 모듈들이 런타임 시에 단일 영속 유닛 내부에서 실행되기를 확인하고 싶을 것입니다. 이렇게 하기 위해 스프링데이터JPA는 <code>PersistenceUnitManager</code>구현체를 제공하여, 그들의 이름에 기반하여 영속 유닛들을 자동적으로 merge하게 해줍니다. 

      </p>
    </div>
    <div class="originalArticle">
      <p>Spring supports having multiple persistence units out of the box. Sometimes, however, you might want to modularize your application but still make sure that all these modules run inside a single persistence unit at runtime. To do so Spring Data JPA offers a <code>PersistenceUnitManager</code> implementation that automatically merges persistence units based on their name.</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 70. MergingPersistenceUnitmanager 사용
    </div>
    <div class="originalArticle">
      Example 70. Using MergingPersistenceUnitmanager
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;bean class="….LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="persistenceUnitManager"&gt;
    &lt;bean class="….MergingPersistenceUnitManager" /&gt;
  &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.misc.entity-scanning"><a class="anchor" href="#jpa.misc.entity-scanning"></a>    <div class="translateArticle">
      5.1.1. JPA매핑파일과 @Entity 클래스들을 위한 클래스 패스 스캐닝
    </div>
    <div class="originalArticle">
      5.1.1. Classpath scanning for @Entity classes and JPA mapping files
    </div>  

      </h4>
<div class="paragraph">
    <div class="translateArticle">
      <p> 
        평범한 JPA설정은 <code>orm.xml</code>에 리스트된 모든 어노테이션 매핑된 엔티티 클래스들을 필요로 합니다. 
        스프링데이터 JPA는 ClasspathScanningPersistenceUnitPostProcessor를 제공하는데, 이것은 base package 설정을 얻고, 선택적인 매핑 파일이름 패턴을 가집니다. 이것은 그후, 주어진 패키지에서 @Entity 나 @MappedSuperclass 로 어노테이션된 클래스들을 스캔하고, 파일이름패턴과 매칭되는 설정파일을 불러와 JPA설정에 그것들을 전달합니다. PostProcessor가 다음과 같이 설정되어야 합니다. : 

      </p>
    </div>
    <div class="originalArticle">
      <p>A plain JPA setup requires all annotation mapped entity classes listed in <code>orm.xml</code>. Same applies to XML mapping files. Spring Data JPA provides a ClasspathScanningPersistenceUnitPostProcessor that gets a base package configured and optionally takes a mapping filename pattern. It will then scan the given package for classes annotated with @Entity or @MappedSuperclass and also loads the configuration files matching the filename pattern and hands them to the JPA configuration. The PostProcessor has to be configured like this:</p>
    </div>  

      
</div>
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 71. ClasspathScanningPersistenceUnitPostProcessor사용
    </div>
    <div class="originalArticle">
      Example 71. Using ClasspathScanningPersistenceUnitPostProcessor
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;bean class="….LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="persistenceUnitPostProcessors"&gt;
    &lt;list&gt;
      &lt;bean class="org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor"&gt;
        &lt;constructor-arg value="com.acme.domain" /&gt;
        &lt;property name="mappingFileNamePattern" value="**/*Mapping.xml" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
    <div class="translateArticle">
      <p> 스프링 3.1 이후로, 스캔할 패키지는 LocalContainerEntityManagerFactoryBean에 직접적으로 설정되어 엔티티클래스르들을 위한 클래스패스 스캐닝을 활성화시킬수가 있습니다. 더 자세한 사항은 <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html#setPackagesToScan(java.lang.String...)">JavaDoc</a>을 참고하세요  </p>
    </div>
    <div class="originalArticle">
      <p>As of Spring 3.1 a package to scan can be configured on the LocalContainerEntityManagerFactoryBean directly to enable classpath scanning for entity classes. See the <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html#setPackagesToScan(java.lang.String...)">JavaDoc</a> for details.</p>
    </div>  

      
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpd.misc.cdi-integration"><a class="anchor" href="#jpd.misc.cdi-integration"></a>    <div class="translateArticle">
      5.2. CDI 통합
    </div>
    <div class="originalArticle">
      5.2. CDI integration
    </div>  

      </h3>
<div class="paragraph">
    <div class="translateArticle">
      <p>repository 인터페이스의 인스턴스는 보통 컨테이너에 의해 생성됩니다. 이는 스프링데이터와 작업할 때 가장 자연스런 선택입니다.  <a href="#repositories.create-instances">리파지토리 인스턴스</a>에 나왔던, 빈 인스턴스를 생성하는 방법을 스프링에서 쉽게 설정하는 세련된 방법이 있습니다.  스프링데이터  버젼 1.1.0  부터  CDI환경의 리파지토리 추상화를 사용하는 커스텀 CDI 확장(extension)을 가질 수가 있습니다. 이 extension은 Jar의 일부이며, 당신이 해야할 모든 것은 스프링 데이터 JPA jar 를 클래스패스에 두는 것입니다. </p>
    </div>
    <div class="originalArticle">
      <p>Instances of the repository interfaces are usually created by a container, which Spring is the most natural choice when working with Spring Data. There&#8217;s sophisticated support to easily set up Spring to create bean instances documented in <a href="#repositories.create-instances">Creating repository instances</a>. As of version 1.1.0 Spring Data JPA ships with a custom CDI extension that allows using the repository abstraction in CDI environments. The extension is part of the JAR so all you need to do to activate it is dropping the Spring Data JPA JAR into your classpath.</p>
    </div>  

      
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>Y당신은 그러면 <code>EntityManagerFactory</code> 와 <code>EntityManager</code>를 위한  CDI Producer를 구현함으로써 인프라스트럭쳐를 설정할 수가 있게 됩니다. :</p>
    </div>
    <div class="originalArticle">
      <p>You can now set up the infrastructure by implementing a CDI Producer for the <code>EntityManagerFactory</code> and <code>EntityManager</code>:</p>
    </div>  

      
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">class EntityManagerFactoryProducer {

  @Produces
  @ApplicationScoped
  public EntityManagerFactory createEntityManagerFactory() {
    return Persistence.createEntityManagerFactory("my-presistence-unit");
  }

  public void close(@Disposes EntityManagerFactory entityManagerFactory) {
    entityManagerFactory.close();
  }

  @Produces
  @RequestScoped
  public EntityManager createEntityManager(EntityManagerFactory entityManagerFactory) {
    return entityManagerFactory.createEntityManager();
  }

  public void close(@Disposes EntityManager entityManager) {
    entityManager.close();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> 필요한 설치는 당신이 운영하는 JAVA EE 환경에 따라 매우 다양해질 수가 있지만 또한 다음과 같이 CDI빈으로서 <code>EntityManager</code>를 재선언하는 것으로 충분할 수도 있습니다.  </p>
    </div>
    <div class="originalArticle">
      <p>The necessary setup can vary depending on the JavaEE environment you run in. It might also just be enough to redeclare a <code>EntityManager</code> as CDI bean as follows:</p>
    </div>  

      
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">class CdiConfig {

  @Produces
  @RequestScoped
  @PersistenceContext
  public EntityManager entityManager;
}</code></pre>
</div>
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p>이 예제에서 컨테이너는 <code>EntityManagers</code>를 생성 할 수 있습니다.  여기서 설정이 하는 것은  CDI빈으로써 JPA<code>EntityManager</code>을 다시 export시키는 것입니다. </p>
    </div>
    <div class="originalArticle">
      <p>In this example, the container has to be capable of creating JPA <code>EntityManagers</code> itself. All the configuration does is re-exporting the JPA <code>EntityManager</code> as CDI bean.</p>
    </div>  

      
</div>
<div class="paragraph">
    <div class="translateArticle">
      <p> 스프링 데이터 JPA CDI 확장은 모든 EntityManagers 를 CDI빈으로 고를수 있게(pick up) 해주며, 리파지토리 타입의 빈이 컨테이너에 의해 요청될때마다 스프링 데이터 리파지토리를 위한 프록시를 생성합니다. 그러므로 스프링데이터 리파지토리의 인스턴스를 얻는 것은 <code>@Injected</code>속성을 선언하기만 하면 됩니다 </p>
    </div>
    <div class="originalArticle">
      <p>The Spring Data JPA CDI extension will pick up all EntityManagers availables as CDI beans and create a proxy for a Spring Data repository whenever an bean of a repository type is requested by the container. Thus obtaining an instance of a Spring Data repository is a matter of declaring an <code>@Injected</code> property:</p>
    </div>  

      
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">class RepositoryClient {

  @Inject
  PersonRepository repository;

  public void businessMethod() {
    List&lt;Person&gt; people = repository.findAll();
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<h1 id="appendix" class="sect0"><a class="anchor" href="#appendix"></a>부록</h1>
<div class="sect1">
<h2 id="repositories.namespace-reference"><a class="anchor" href="#repositories.namespace-reference"></a>    <div class="translateArticle">
      부록 A: 네임스페이스 레퍼런스
    </div>
    <div class="originalArticle">
      Appendix A: Namespace reference
    </div>  

      </h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="populator.namespace-dao-config"><a class="anchor" href="#populator.namespace-dao-config"></a>The &lt;repositories /&gt; element</h3>
<div class="paragraph">
    <div class="translateArticle">
      <p><code>&lt;repositories /&gt;</code> 요소는 스프링 데이터 리파지토리 인프라스트럭쳐의 설정을 동작시킵니다. 
            가장 중요한 속성은 <code>base-package</code> 로 이것은 스프링 데이터 리파지토리 인터페이스<span class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote.">3</a>]</span>를 찾을 패키지를 스캔하게 해줍니다. </p>
    </div>
    <div class="originalArticle">
     <p> The <code>&lt;repositories /&gt;</code> element triggers the setup of the Spring Data repository infrastructure. The most important attribute is <code>base-package</code> which defines the package to scan for Spring Data repository interfaces.<span class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote.">3</a>]</span></p>
    </div> 

      
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 6. 속성들</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>base-package</code></p></td>
<td class="tableblock halign-left valign-top"> <div class="translateArticle"><p class="tableblock">   
      *Repository를 상속하는 리파지토리 인터페이스를 자동 감지 모드 아래 스캔하기 위해 사용됨. (실제 인터페이스는 스프링 데이터 모듈에 따라 결정된다.) 설정된 패키지의 아래 있는 모든 패키지는 스캔되며 와일드 카드 또한 가능하다. </p>
    </div>
    <div class="originalArticle"><p class="tableblock">   
      Defines the package to be used to be scanned for repository interfaces extending *Repository (actual interface is determined by specific Spring Data module) in auto detection mode. All packages below the configured package will be scanned, too. Wildcards are allowed.</p>
    </div>  

      </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>repository-impl-postfix</code></p></td>
<td class="tableblock halign-left valign-top"><div class="translateArticle"><p class="tableblock">커스텀 리파지토리 구현체를 자동감지하기 위한 접미사를 설정한다. 설정된 접미사를 가진 클래스들은 그 후보로 고려되며 기본값은 <code>Impl</code>이다. </p>
    </div>
    <div class="originalArticle">
      <p class="tableblock">
      transDefines the postfix to autodetect custom repository implementations. Classes whose names end with the configured postfix will be considered as candidates. Defaults to <code>Impl</code>.</p>
    </div>  

      </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>query-lookup-strategy</code></p></td>
<td class="tableblock halign-left valign-top">    <div class="translateArticle"><p class="tableblock">쿼리 검색자를 만드는데 사용되는 전략을 결정하기 위함. <a href="#repositories.query-methods.query-lookup-strategies">쿼리 탐색 전략</a>을 보시고 기본값은 <code>create-if-not-found</code>이다. </p>
    </div>
    <div class="originalArticle">
      <p class="tableblock">
      Determines the strategy to be used to create finder queries. See <a href="#repositories.query-methods.query-lookup-strategies">Query lookup strategies</a> for details. Defaults to <code>create-if-not-found</code>.</p>
    </div>  

      </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>named-queries-location</code></p></td>
<td class="tableblock halign-left valign-top">   <div class="translateArticle"><p class="tableblock"> 
      외부적으로 정의된 쿼리들을 포함하는 설정파일을 찾기 위한 위치를 정의함</p>
    </div>
    <div class="originalArticle">
      Defines the location to look for a Properties file containing externally defined queries.
    </div>  

      </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>consider-nested-repositories</code></p></td>
<td class="tableblock halign-left valign-top">    <div class="translateArticle"><p class="tableblock">
      중첩(nested) 리파지토리 인터페이스 정의를 조정할지 고려함. 기본값은  <code>false</code>.</p>
    </div>
    <div class="originalArticle"><p class="tableblock">
      Controls whether nested repository interface definitions should be considered. Defaults to <code>false</code>.</p>
    </div>  

      </p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="populator.namespace-reference"><a class="anchor" href="#populator.namespace-reference"></a>    <div class="translateArticle">
      부록 B : Populators 네임스페이스 레퍼런스
    </div>
    <div class="originalArticle">
      Appendix B: Populators namespace reference
    </div>  

      </h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="namespace-dao-config"><a class="anchor" href="#namespace-dao-config"></a>The &lt;populator /&gt; element</h3>
<div class="paragraph">
<p>    <div class="translateArticle">
       <code>&lt;populator /&gt;</code> 요소는 저장소를 Spring data 리파지토리 인프라스트럭쳐<span class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnote_4" title="View footnote.">4</a>]를 통해 채울 있게 해준다. 
    </div>
    <div class="originalArticle">
      The <code>&lt;populator /&gt;</code> element allows to populate the a data store via the Spring Data repository infrastructure.<span class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnote_4" title="View footnote.">4</a>]</span>
    </div>  

      </p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 7. Attributes</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>locations</code></p></td>
<td class="tableblock halign-left valign-top">   <div class="translateArticle"><p class="tableblock"> 
      어디서 저장소를 채울 객체를 읽어들일 파일들을 발견할지 정함.</p>
    </div>
    <div class="originalArticle">
      <p class="tableblock"> 
      Where to find the files to read the objects from the repository shall be populated with.</p>
    </div>  

      </p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="repository-query-keywords"><a class="anchor" href="#repository-query-keywords"></a>    <div class="translateArticle">
      부록 C : 리파지토리 쿼리 키워드들
    </div>
    <div class="originalArticle">
      Appendix C: Repository query keywords
    </div>  

      </h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_supported_query_keywords"><a class="anchor" href="#_supported_query_keywords"></a>    <div class="translateArticle">
      지원되는 쿼리 키워드들
    </div>
    <div class="originalArticle">
      Supported query keywords
    </div>  

      </h3>
<div class="paragraph">
  <div class="translateArticle">
      <p>다음의 테이블은 일반적으로 스프링데이터리파지토리 쿼리 추론 메커니즘에서 지원되는 키워드들을 나타낸다  그러나 특정 디비에서 정확히 지원되는 키워드를 위해 저장소 문서를 참조하기를 바란다. 왜냐하면 몇몇 리스트는 특정 데이터 저장소에서 지원이 되지 않기 때문이다. </p>
    </div>
    <div class="originalArticle">
     <p> The following table lists the keywords generally supported by the Spring Data repository query derivation mechanism. However, consult the store-specific documentation for the exact list of supported keywords, because some listed here might not be supported in a particular store.</p>
    </div>  

      </p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 8. Query keywords</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Logical keyword</th>
<th class="tableblock halign-left valign-top">Keyword expressions</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AND</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>And</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Or</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AFTER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>After</code>, <code>IsAfter</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BEFORE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Before</code>, <code>IsBefore</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONTAINING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Containing</code>, <code>IsContaining</code>, <code>Contains</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BETWEEN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Between</code>, <code>IsBetween</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENDING_WITH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EndingWith</code>, <code>IsEndingWith</code>, <code>EndsWith</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXISTS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Exists</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>False</code>, <code>IsFalse</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GREATER_THAN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThan</code>, <code>IsGreaterThan</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GREATER_THAN_EQUALS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThanEqual</code>, <code>IsGreaterThanEqual</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>In</code>, <code>IsIn</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Is</code>, <code>Equals</code>, (or no keyword)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS_NOT_NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotNull</code>, <code>IsNotNull</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS_NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Null</code>, <code>IsNull</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LESS_THAN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThan</code>, <code>IsLessThan</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LESS_THAN_EQUAL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThanEqual</code>, <code>IsLessThanEqual</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LIKE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Like</code>, <code>IsLike</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NEAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Near</code>, <code>IsNear</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Not</code>, <code>IsNot</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOT_IN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotIn</code>, <code>IsNotIn</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOT_LIKE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotLike</code>, <code>IsNotLike</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REGEX</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Regex</code>, <code>MatchesRegex</code>, <code>Matches</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>STARTING_WITH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StartingWith</code>, <code>IsStartingWith</code>, <code>StartsWith</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>True</code>, <code>IsTrue</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WITHIN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Within</code>, <code>IsWithin</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="repository-query-return-types"><a class="anchor" href="#repository-query-return-types"></a>    <div class="translateArticle">
      부록 D : 리파지토리 쿼리 리턴 타입
    </div>
    <div class="originalArticle">
      Appendix D: Repository query return types
    </div>  

      </h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_supported_query_return_types"><a class="anchor" href="#_supported_query_return_types"></a>    <div class="translateArticle">
      지원되는 쿼리 리턴 타입
    </div>
    <div class="originalArticle">
      Supported query return types
    </div>  

      </h3>
<div class="paragraph">
<p>    <div class="translateArticle">
      다음의 테이블은 일반적으로 스프링 데이터 리파지토리에서 지원되는 리턴 타입들을 나타냅니다. 그러나 앞서 말씀드린 대로 데이터 저장소 문서를 참조하세요. 
    </div>
    <div class="originalArticle">
      The following table lists the return types generally supported by Spring Data repositories. However, consult the store-specific documentation for the exact list of supported return types, because some listed here might not be supported in a particular store.
    </div>  

      </p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
    <div class="translateArticle">
      <code>GeoResult</code>, <code>GeoResults</code>, <code>GeoPage</code>와 같은 지역기반 타입 은 오직 지역기반 쿼리를 지원하는 데이터저장소에서만 사용가능합니다. 
    </div>
    <div class="originalArticle">
      Geospatial types like (<code>GeoResult</code>, <code>GeoResults</code>, <code>GeoPage</code>) are only available for data stores that support geospatial queries.
    </div>  

      
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">    <div class="translateArticle">
      표 6. 쿼리 리턴 타입
    </div>
    <div class="originalArticle">
      Table 6. Query return types
    </div>  

      </caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">    <div class="translateArticle">
      아무런 리턴 타입 없다.
    </div>
    <div class="originalArticle">
      Denotes no return value.
    </div>  

      </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primitives</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">    <div class="translateArticle">
      자바 주요요소
    </div>
    <div class="originalArticle">
      Java primitives.
    </div>  

      </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Wrapper types</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">    <div class="translateArticle">
      자바 래퍼 타입
    </div>
    <div class="originalArticle">
      Java wrapper types.
    </div>  

      </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">    <div class="translateArticle">
      유니크 엔티티. 대부분 쿼리 메소드가 하나의 결과를 돌려주기를 예상합니다. 어떠한 결과도 발견되지 않은 경우 <code>null</code>이 반환될 것입니다.  하나 이상의 결과가 나오게 되면  <code>IncorrectResultSizeDataAccessException</code>가 나올 것입니다. 
    </div>
    <div class="originalArticle">
      An unique entity. Expects the query method to return one result at most. In case no result is found <code>null</code> is returned. More than one result will trigger an <code>IncorrectResultSizeDataAccessException</code>.
    </div>  

      </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Iterator&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">    <div class="translateArticle">
      <code>반복자</code>.
    </div>
    <div class="originalArticle">
      An <code>Iterator</code>.
    </div>  

      </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Collection&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <code>Collection</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <code>List</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Optional&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">    <div class="translateArticle">
      자바8 이나 Guava <code>Optional</code>입니다. 쿼리메소드가 대부분 하나의 결과값을 리턴하기를 기대하며 어떠한 결과도 없으면 <code>Optional.empty()</code>/<code>Optional.absent()</code>가 반환됩니다. 하나 이상의 결과에는 <code>IncorrectResultSizeDataAccessException</code>가 동작할 것입니다. 
    </div>
    <div class="originalArticle">
      A Java 8 or Guava <code>Optional</code>. Expects the query method to return one result at most. In case no result is found <code>Optional.empty()</code>/<code>Optional.absent()</code> is returned. More than one result will trigger an <code>IncorrectResultSizeDataAccessException</code>.
    </div>  

      </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Stream&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A Java 8 <code>Stream</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Slice</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">    <div class="translateArticle">
      더 이상의 데이터가 가능한지에 대한 정보가 같이 있는 데이터의 덩어리입니다. <code>Pageable</code>를 메소드 파라미터로 필요로 합니다 .
    </div>
    <div class="originalArticle">
      A sized chunk of data with information whether there is more data available. Requires a <code>Pageable</code> method parameter.
    </div>  

      </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Page&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">    <div class="translateArticle">
       <code>Slice</code> 와 추가적인 정보가 있는 (예를 들자면 결과의 총 개수) 타입입니다. <code>Pageable</code> 를 메소드 파라미터로 필요로 합니다. 
    </div>
    <div class="originalArticle">
      A <code>Slice</code> with additional information, e.g. the total number of results. Requires a <code>Pageable</code> method parameter.
    </div>  

      </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GeoResult&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">    <div class="translateArticle">
      추가적인 정보(참조 위치에 대한 거리)와 함께 있는 결과 엔트리 
    </div>
    <div class="originalArticle">
      A result entry with additional information, e.g. distance to a reference location.
    </div>  

      </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GeoResults&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">    <div class="translateArticle">
      추가적인 정보(참조 위치에 대한 평균 거리 )와 함께 있는 <code>GeoResult&lt;T&gt;</code>의 리스트 
    </div>
    <div class="originalArticle">
      A list of <code>GeoResult&lt;T&gt;</code> with additional information, e.g. average distance to a reference location.
    </div>  

      </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GeoPage&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">    <div class="translateArticle">
      <code>Page</code> 와  <code>GeoResult&lt;T&gt;</code>,예를 들면 참조 위치와 평균 거리
    </div>
    <div class="originalArticle">
      A <code>Page</code> with <code>GeoResult&lt;T&gt;</code>, e.g. average distance to a reference location.
    </div>  

      </p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="faq"><a class="anchor" href="#faq"></a>    <div class="translateArticle">
      부록 E: 자주묻는 질문들
    </div>
    <div class="originalArticle">
      Appendix E: Frequently asked questions
    </div>  

      </h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_common"><a class="anchor" href="#_common"></a>    <div class="translateArticle">
      흔한 질문
    </div>
    <div class="originalArticle">
      Common
    </div>  

      </h3>
<div class="qlist qanda">
<ol>
<li>
    <div class="translateArticle">
      <p><em>저는 <code>JpaRepository</code>내에서 호출되는 메소드들에 대해 좀더 상세한 로깅을 얻고 싶은데 어떻게 할까요? </em></p>
      <p>당신으 스프링에서 제공되는 <code>CustomizableTraceInterceptor</code> 를 이용할 수가 있습니다 :</p>
    </div>
    <div class="originalArticle">
      <p><em>I&#8217;d like to get more detailed logging information on what methods are called inside <code>JpaRepository</code>, e.g. How can I gain them?</em></p>
      <p>You can make use of <code>CustomizableTraceInterceptor</code> provided by Spring:</p>
    </div>  

      
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;bean id="customizableTraceInterceptor" class="
  org.springframework.aop.interceptor.CustomizableTraceInterceptor"&gt;
  &lt;property name="enterMessage" value="Entering $[methodName]($[arguments])"/&gt;
  &lt;property name="exitMessage" value="Leaving $[methodName](): $[returnValue]"/&gt;
&lt;/bean&gt;

&lt;aop:config&gt;
  &lt;aop:advisor advice-ref="customizableTraceInterceptor"
    pointcut="execution(public * org.springframework.data.jpa.repository.JpaRepository+.*(..))"/&gt;
&lt;/aop:config&gt;</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_infrastructure"><a class="anchor" href="#_infrastructure"></a>    <div class="translateArticle">
      인프라스트럭쳐
    </div>
    <div class="originalArticle">
      Infrastructure
    </div>  

      </h3>
<div class="qlist qanda">
<ol>
<li>
    <div class="translateArticle">
      <p> 현재 저는 <code>HibernateDaoSupport</code>에 기반하는 리파지토리 레이어를 구현했습니다. 저는 스프링의 <code>AnnotationSessionFactoryBean</code>를 이용하여서 <code>SessionFactory</code>를 만들었습니다. 어떻게 이런 환경에서 스프링 데이터 리파지토리들을 얻을 수 있을까요? </p>
    </div>
    <div class="originalArticle">
      <p><em>Currently I have implemented a repository layer based on <code>HibernateDaoSupport</code>. I create a <code>SessionFactory</code> by using Spring&#8217;s <code>AnnotationSessionFactoryBean</code>. How do I get Spring Data repositories working in this environment?</em></p>
    </div>  

      
    <div class="translateArticle">
      <p>당신은 다음과 같이 <code>AnnotationSessionFactoryBean</code> 을 <code>HibernateJpaSessionFactoryBean</code>로 바꾸시면 됩니다. : </p>
    </div>
    <div class="originalArticle">
      <p>You have to replace <code>AnnotationSessionFactoryBean</code> with the <code>HibernateJpaSessionFactoryBean</code> as follows:</p>
    </div>  

      
<div class="exampleblock">
<div class="title">    <div class="translateArticle">
      Example 72. SessionFactoryHibernateEntityManagerFactory로부터 SessionFactory탐색
    </div>
    <div class="originalArticle">
      Example 72. Looking up a SessionFactory from a HibernateEntityManagerFactory
    </div>  

      </div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;bean id="sessionFactory" class="org.springframework.orm.jpa.vendor.HibernateJpaSessionFactoryBean"&gt;
  &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_auditing"><a class="anchor" href="#_auditing"></a>Auditing</h3>
<div class="qlist qanda">
<ol>
<li>
    <div class="translateArticle">
      <p><em>저는 스프링 데이터 auditing 기능들을 사용하고 싶지만 제 데이터베이스는 이미 엔티티들에 수정,생성날짜를 설정해두었습니다. 어떻게 스프링데이터가 date를 programmatically하게 설정하는 것을 막아둘까요?  </em></p>
       <p>네임스페이스 요소 <code>auditing</code>의 <code>set-dates</code> 속성을 false로 하세요 </p>
    </div>
    <div class="originalArticle">
      <p><em>I want to use Spring Data JPA auditing capabilities but have my database already set up to set modification and creation date on entities. How to prevent Spring Data from setting the date programmatically.</em></p>
      <p>Just use the <code>set-dates</code> attribute of the <code>auditing</code> namespace element to false.</p>
    </div>  

      
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="glossary"><a class="anchor" href="#glossary"></a>    <div class="translateArticle">
      부록 F: 용어집
    </div>
    <div class="originalArticle">
      Appendix F: Glossary
    </div>  

      </h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">AOP</dt>
<dd>
    <div class="translateArticle">
      <p>관점 지향 프로그래밍</p>
    </div>
    <div class="originalArticle">
      <p>Aspect oriented programming</p>
    </div>  

      
</dd>
<dt class="hdlist1">Commons DBCP</dt>
<dd>
    <div class="translateArticle">
      <p>Commons DataBase Connection Pools - 데이터 소스 인터페이스를 구현하는 pooling 구현체. 아파치 단체의 라이브러리</p>
    </div>
    <div class="originalArticle">
      <p>Commons DataBase Connection Pools - Library of the Apache foundation offering pooling implementations of the DataSource interface.</p>
    </div>  

      
</dd>
<dt class="hdlist1">CRUD</dt>
<dd>
    <div class="translateArticle">
      <p>만들고, 읽고, 수정하고, 삭제하는 기본적인 작업 Create, Read, Update, Delete - Basic persistence operations</p>
    </div>
    <div class="originalArticle">
      <p>Create, Read, Update, Delete - Basic persistence operations</p>
    </div>  

      
</dd>
<dt class="hdlist1">DAO</dt>
<dd>
    <div class="translateArticle">
      <p>데이터 접근 객체 - 영속화되는 객체로부터 분리된, 영속하는 logic</p>
    </div>
    <div class="originalArticle">
      <p>Data Access Object - Pattern to separate persisting logic from the object to be persisted</p>
    </div>  

      
</dd>
<dt class="hdlist1">Dependency Injection</dt>
<dd>
    <div class="translateArticle">
      <p> 컴포넌트의 의존성을 바깥에 있는 컴포넌트로 전달하는 패턴. 자신이 스스로 의존성을 탐색해야되는 것에서 자유롭게 합니다. 더 나은 정보는 <a href="http://en.wikipedia.org/wiki/Dependency_Injection"><a href="http://en.wikipedia.org/wiki/Dependency_Injection" class="bare">http://en.wikipedia.org/wiki/Dependency_Injection</a>
    </p>
    </div>
    <div class="originalArticle">
      <p>Pattern to hand a component&#8217;s dependency to the component from outside, freeing the component to lookup the dependant itself. For more information see <a href="http://en.wikipedia.org/wiki/Dependency_Injection"><a href="http://en.wikipedia.org/wiki/Dependency_Injection" class="bare">http://en.wikipedia.org/wiki/Dependency_Injection</a></a>.</p>
    </div>  

      
</dd>
<dt class="hdlist1">EclipseLink</dt>
<dd>
    <div class="translateArticle">
      <p>JPA를 구현하는 객체관계매퍼 - <a href="http://www.eclipselink.org"><a href="http://www.eclipselink.org" class="bare">http://www.eclipselink.org</a></a></p>
    </div>
    <div class="originalArticle">
      <p>Object relational mapper implementing JPA - <a href="http://www.eclipselink.org"><a href="http://www.eclipselink.org" class="bare">http://www.eclipselink.org</a></a></p>
    </div>  

      
</dd>
<dt class="hdlist1">Hibernate</dt>
<dd>
    <div class="translateArticle">
      <p>JPA를 구현하는 객체관계매퍼 - <a href="http://www.hibernate.org"><a href="http://www.hibernate.org" class="bare">http://www.hibernate.org</a></a></p>
    </div>
    <div class="originalArticle">
      <p>Object relational mapper implementing JPA - <a href="http://www.hibernate.org"><a href="http://www.hibernate.org" class="bare">http://www.hibernate.org</a></a></p>
    </div>  

      
</dd>
<dt class="hdlist1">JPA</dt>
<dd>
    <div class="translateArticle">
      <p>자바 영속 API </p>
    </div>
    <div class="originalArticle">
      <p>Java Persistence API</p>
    </div>  

      
</dd>
<dt class="hdlist1">Spring</dt>
<dd>
    <div class="translateArticle">
      <p> 자바 어플리케이션 프레임 워크 - <a href="http://projects.spring.io/spring-framework"><a href="http://projects.spring.io/spring-framework" class="bare">http://projects.spring.io/spring-framework</a></a></p>
    </div>
    <div class="originalArticle">
      <p>Java application framework - <a href="http://projects.spring.io/spring-framework"><a href="http://projects.spring.io/spring-framework" class="bare">http://projects.spring.io/spring-framework</a></a></p>
    </div>  

      
</dd>
</dl>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. <a href="http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/beans.html#beans-java">JavaConfig in the Spring reference documentation</a>
</div>
<div class="footnote" id="_footnote_2">
<a href="#_footnoteref_2">2</a>. Spring HATEOAS - <a href="https://github.com/SpringSource/spring-hateoas"><a href="https://github.com/SpringSource/spring-hateoas" class="bare">https://github.com/SpringSource/spring-hateoas</a></a>
</div>
<div class="footnote" id="_footnote_3">
<a href="#_footnoteref_3">3</a>. see <a href="#repositories.create-instances.spring">XML configuration</a>
</div>
<div class="footnote" id="_footnote_4">
<a href="#_footnoteref_4">4</a>. see <a href="#repositories.create-instances.spring">XML configuration</a>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.8.1.RELEASE<br>
Last updated 2015-06-23 19:14:27 MESZ
<br>
번역자 : 아라한사 (fb.com/me.adunhansa) 오역 제보 감사합니다 :) 
</div>
</div>
 

</body>
</html>